{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_connectedPromise, _AbstractChatCompletionRunner_resolveConnectedPromise, _AbstractChatCompletionRunner_rejectConnectedPromise, _AbstractChatCompletionRunner_endPromise, _AbstractChatCompletionRunner_resolveEndPromise, _AbstractChatCompletionRunner_rejectEndPromise, _AbstractChatCompletionRunner_listeners, _AbstractChatCompletionRunner_ended, _AbstractChatCompletionRunner_errored, _AbstractChatCompletionRunner_aborted, _AbstractChatCompletionRunner_catchingPromiseCreated, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_handleError, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\n\nimport { APIUserAbortError, OpenAIError } from 'openai/error';\nimport { isRunnableFunctionWithParse } from \"./RunnableFunction.mjs\";\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from \"./chatCompletionUtils.mjs\";\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport class AbstractChatCompletionRunner {\n  constructor() {\n    _AbstractChatCompletionRunner_instances.add(this);\n\n    this.controller = new AbortController();\n\n    _AbstractChatCompletionRunner_connectedPromise.set(this, void 0);\n\n    _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {});\n\n    _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {});\n\n    _AbstractChatCompletionRunner_endPromise.set(this, void 0);\n\n    _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {});\n\n    _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {});\n\n    _AbstractChatCompletionRunner_listeners.set(this, {});\n\n    this._chatCompletions = [];\n    this.messages = [];\n\n    _AbstractChatCompletionRunner_ended.set(this, false);\n\n    _AbstractChatCompletionRunner_errored.set(this, false);\n\n    _AbstractChatCompletionRunner_aborted.set(this, false);\n\n    _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);\n\n    _AbstractChatCompletionRunner_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_errored, true, \"f\");\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _AbstractChatCompletionRunner_aborted, true, \"f\");\n\n        return this._emit('abort', error);\n      }\n\n      if (error instanceof OpenAIError) {\n        return this._emit('error', error);\n      }\n\n      if (error instanceof Error) {\n        const openAIError = new OpenAIError(error.message); // @ts-ignore\n\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n      }\n\n      return this._emit('error', new OpenAIError(String(error)));\n    });\n\n    __classPrivateFieldSet(this, _AbstractChatCompletionRunner_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_resolveConnectedPromise, resolve, \"f\");\n\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n\n    __classPrivateFieldSet(this, _AbstractChatCompletionRunner_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_resolveEndPromise, resolve, \"f\");\n\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_rejectEndPromise, reject, \"f\");\n    }), \"f\"); // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n\n\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_connectedPromise, \"f\").catch(() => {});\n\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_endPromise, \"f\").catch(() => {});\n  }\n\n  _run(executor) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n\n        this._emit('end');\n      }, __classPrivateFieldGet(this, _AbstractChatCompletionRunner_handleError, \"f\"));\n    }, 0);\n  }\n\n  _addChatCompletion(chatCompletion) {\n    this._chatCompletions.push(chatCompletion);\n\n    this._emit('chatCompletion', chatCompletion);\n\n    const message = chatCompletion.choices[0]?.message;\n    if (message) this._addMessage(message);\n    return chatCompletion;\n  }\n\n  _addMessage(message) {\n    let emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.messages.push(message);\n\n    if (emit) {\n      this._emit('message', message);\n\n      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content);\n      } else if (isAssistantMessage(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n\n  _connected() {\n    if (this.ended) return;\n\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_resolveConnectedPromise, \"f\").call(this);\n\n    this._emit('connect');\n  }\n\n  get ended() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_ended, \"f\");\n  }\n\n  get errored() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_errored, \"f\");\n  }\n\n  get aborted() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_aborted, \"f\");\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n\n\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n\n\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event];\n\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n\n\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n\n\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, \"f\");\n\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n\n  async done() {\n    __classPrivateFieldSet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, \"f\");\n\n    await __classPrivateFieldGet(this, _AbstractChatCompletionRunner_endPromise, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n\n\n  async finalChatCompletion() {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n\n\n  async finalContent() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n\n\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n\n\n  async finalFunctionCall() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n  }\n\n  async finalFunctionCallResult() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n  }\n\n  async totalUsage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n  }\n\n  allChatCompletions() {\n    return [...this._chatCompletions];\n  }\n\n  _emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // make sure we don't emit any events after end\n    if (__classPrivateFieldGet(this, _AbstractChatCompletionRunner_ended, \"f\")) return;\n\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_ended, true, \"f\");\n\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_resolveEndPromise, \"f\").call(this);\n    }\n\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event];\n\n    if (listeners) {\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(_ref => {\n        let {\n          listener\n        } = _ref;\n        return listener(...args);\n      });\n    }\n\n    if (event === 'abort') {\n      const error = args[0];\n\n      if (!__classPrivateFieldGet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        Promise.reject(error);\n      }\n\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectConnectedPromise, \"f\").call(this, error);\n\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectEndPromise, \"f\").call(this, error);\n\n      this._emit('end');\n\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n\n      if (!__classPrivateFieldGet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectConnectedPromise, \"f\").call(this, error);\n\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectEndPromise, \"f\").call(this, error);\n\n      this._emit('end');\n    }\n  }\n\n  _emitFinal() {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = this.messages[this.messages.length - 1];\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n\n    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n\n    if (finalContent) this._emit('finalContent', finalContent);\n\n    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n\n    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n\n    if (this._chatCompletions.some(c => c.usage)) {\n      this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n    }\n  }\n\n  async _createChatCompletion(completions, params, options) {\n    const signal = options?.signal;\n\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n\n    const chatCompletion = await completions.create({ ...params,\n      stream: false\n    }, { ...options,\n      signal: this.controller.signal\n    });\n\n    this._connected();\n\n    return this._addChatCompletion(chatCompletion);\n  }\n\n  async _runChatCompletion(completions, params, options) {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    return await this._createChatCompletion(completions, params, options);\n  }\n\n  async _runFunctions(completions, params, options) {\n    const role = 'function';\n    const {\n      function_call = 'auto',\n      stream,\n      ...restParams\n    } = params;\n    const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    const functionsByName = {};\n\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n\n    const functions = params.functions.map(f => ({\n      name: f.name || f.function.name,\n      parameters: f.parameters,\n      description: f.description\n    }));\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion = await this._createChatCompletion(completions, { ...restParams,\n        function_call,\n        functions,\n        messages: [...this.messages]\n      }, options);\n      const message = chatCompletion.choices[0]?.message;\n\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n\n      if (!message.function_call) return;\n      const {\n        name,\n        arguments: args\n      } = message.function_call;\n      const fn = functionsByName[name];\n\n      if (!fn) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map(f => JSON.stringify(f.name)).join(', ')}. Please try again`;\n\n        this._addMessage({\n          role,\n          name,\n          content\n        });\n\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n\n        this._addMessage({\n          role,\n          name,\n          content\n        });\n\n        continue;\n      }\n\n      let parsed;\n\n      try {\n        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error)\n        });\n\n        continue;\n      } // @ts-expect-error it can't rule out `never` type.\n\n\n      const rawContent = await fn.function(parsed, this);\n\n      const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n\n      this._addMessage({\n        role,\n        name,\n        content\n      });\n\n      if (singleFunctionToCall) return;\n    }\n  }\n\n  async _runTools(completions, params, options) {\n    const role = 'tool';\n    const {\n      tool_choice = 'auto',\n      stream,\n      ...restParams\n    } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    const functionsByName = {};\n\n    for (const f of params.tools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n\n    const tools = 'tools' in params ? params.tools.map(t => t.type === 'function' ? {\n      type: 'function',\n      function: {\n        name: t.function.name || t.function.function.name,\n        parameters: t.function.parameters,\n        description: t.function.description\n      }\n    } : t) : undefined;\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion = await this._createChatCompletion(completions, { ...restParams,\n        tool_choice,\n        tools,\n        messages: [...this.messages]\n      }, options);\n      const message = chatCompletion.choices[0]?.message;\n\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n\n      if (!message.tool_calls) return;\n\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const {\n          name,\n          arguments: args\n        } = tool_call.function;\n        const fn = functionsByName[name];\n\n        if (!fn) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${tools.map(f => JSON.stringify(f.function.name)).join(', ')}. Please try again`;\n\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n\n          continue;\n        }\n\n        let parsed;\n\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n\n          continue;\n        } // @ts-expect-error it can't rule out `never` type.\n\n\n        const rawContent = await fn.function(parsed, this);\n\n        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n\n        this._addMessage({\n          role,\n          tool_call_id,\n          content\n        });\n\n        if (singleFunctionToCall) return;\n      }\n    }\n  }\n\n}\n_AbstractChatCompletionRunner_connectedPromise = new WeakMap(), _AbstractChatCompletionRunner_resolveConnectedPromise = new WeakMap(), _AbstractChatCompletionRunner_rejectConnectedPromise = new WeakMap(), _AbstractChatCompletionRunner_endPromise = new WeakMap(), _AbstractChatCompletionRunner_resolveEndPromise = new WeakMap(), _AbstractChatCompletionRunner_rejectEndPromise = new WeakMap(), _AbstractChatCompletionRunner_listeners = new WeakMap(), _AbstractChatCompletionRunner_ended = new WeakMap(), _AbstractChatCompletionRunner_errored = new WeakMap(), _AbstractChatCompletionRunner_aborted = new WeakMap(), _AbstractChatCompletionRunner_catchingPromiseCreated = new WeakMap(), _AbstractChatCompletionRunner_handleError = new WeakMap(), _AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n  return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n  let i = this.messages.length;\n\n  while (i-- > 0) {\n    const message = this.messages[i];\n\n    if (isAssistantMessage(message)) {\n      return message;\n    }\n  }\n\n  throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    const message = this.messages[i];\n\n    if (isAssistantMessage(message) && message?.function_call) {\n      return message.function_call;\n    }\n  }\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    const message = this.messages[i];\n\n    if (isFunctionMessage(message) && message.content != null) {\n      return message.content;\n    }\n  }\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n  const total = {\n    completion_tokens: 0,\n    prompt_tokens: 0,\n    total_tokens: 0\n  };\n\n  for (const {\n    usage\n  } of this._chatCompletions) {\n    if (usage) {\n      total.completion_tokens += usage.completion_tokens;\n      total.prompt_tokens += usage.prompt_tokens;\n      total.total_tokens += usage.total_tokens;\n    }\n  }\n\n  return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n  if (params.n != null && params.n > 1) {\n    throw new OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n  }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n  return typeof rawContent === 'string' ? rawContent : rawContent === undefined ? 'undefined' : JSON.stringify(rawContent);\n};","map":{"version":3,"mappings":"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","names":["APIUserAbortError","OpenAIError","isRunnableFunctionWithParse","isAssistantMessage","isFunctionMessage","isToolMessage","DEFAULT_MAX_CHAT_COMPLETIONS","AbstractChatCompletionRunner","constructor","AbortController","_AbstractChatCompletionRunner_connectedPromise","_AbstractChatCompletionRunner_resolveConnectedPromise","_AbstractChatCompletionRunner_rejectConnectedPromise","_AbstractChatCompletionRunner_endPromise","_AbstractChatCompletionRunner_resolveEndPromise","_AbstractChatCompletionRunner_rejectEndPromise","_AbstractChatCompletionRunner_listeners","_AbstractChatCompletionRunner_ended","_AbstractChatCompletionRunner_errored","_AbstractChatCompletionRunner_aborted","_AbstractChatCompletionRunner_catchingPromiseCreated","_AbstractChatCompletionRunner_handleError","error","__classPrivateFieldSet","Error","name","_emit","openAIError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","_run","executor","setTimeout","then","_emitFinal","_addChatCompletion","chatCompletion","_chatCompletions","push","choices","_addMessage","emit","messages","content","function_call","tool_calls","tool_call","type","function","_connected","ended","call","errored","aborted","abort","controller","on","event","listener","listeners","off","index","findIndex","l","splice","once","emitted","done","finalChatCompletion","completion","length","finalContent","_AbstractChatCompletionRunner_instances","_AbstractChatCompletionRunner_getFinalContent","finalMessage","_AbstractChatCompletionRunner_getFinalMessage","finalFunctionCall","_AbstractChatCompletionRunner_getFinalFunctionCall","finalFunctionCallResult","_AbstractChatCompletionRunner_getFinalFunctionCallResult","totalUsage","_AbstractChatCompletionRunner_calculateTotalUsage","allChatCompletions","args","filter","forEach","some","c","usage","_createChatCompletion","completions","params","options","signal","addEventListener","_AbstractChatCompletionRunner_validateParams","create","stream","_runChatCompletion","_runFunctions","role","restParams","singleFunctionToCall","maxChatCompletions","functionsByName","f","functions","map","parameters","description","i","arguments","fn","JSON","stringify","join","parsed","parse","rawContent","_AbstractChatCompletionRunner_stringifyFunctionCallResult","_runTools","tool_choice","tools","t","undefined","tool_call_id","id","total","completion_tokens","prompt_tokens","total_tokens","n"],"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/openai/src/lib/AbstractChatCompletionRunner.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { type CompletionUsage } from \"../resources/completions\";\nimport {\n  type Completions,\n  type ChatCompletion,\n  type ChatCompletionMessage,\n  type ChatCompletionMessageParam,\n  type ChatCompletionCreateParams,\n  type ChatCompletionAssistantMessageParam,\n  type ChatCompletionTool,\n} from \"../resources/chat/completions\";\nimport { APIUserAbortError, OpenAIError } from \"../error\";\nimport {\n  type RunnableFunction,\n  isRunnableFunctionWithParse,\n  type BaseFunctionsArgs,\n} from './RunnableFunction';\nimport { ChatCompletionFunctionRunnerParams, ChatCompletionToolRunnerParams } from './ChatCompletionRunner';\nimport {\n  ChatCompletionStreamingFunctionRunnerParams,\n  ChatCompletionStreamingToolRunnerParams,\n} from './ChatCompletionStreamingRunner';\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from './chatCompletionUtils';\n\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport interface RunnerOptions extends Core.RequestOptions {\n  /** How many requests to make before canceling. Default 10. */\n  maxChatCompletions?: number;\n}\n\nexport abstract class AbstractChatCompletionRunner<\n  Events extends CustomEvents<any> = AbstractChatCompletionRunnerEvents,\n> {\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: OpenAIError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: OpenAIError) => void = () => {};\n\n  #listeners: { [Event in keyof Events]?: ListenersForEvent<Events, Event> } = {};\n\n  protected _chatCompletions: ChatCompletion[] = [];\n  messages: ChatCompletionMessageParam[] = [];\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, this.#handleError);\n    }, 0);\n  }\n\n  protected _addChatCompletion(chatCompletion: ChatCompletion): ChatCompletion {\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = chatCompletion.choices[0]?.message;\n    if (message) this._addMessage(message as ChatCompletionMessageParam);\n    return chatCompletion;\n  }\n\n  protected _addMessage(message: ChatCompletionMessageParam, emit = true) {\n    this.messages.push(message);\n    if (emit) {\n      this._emit('message', message);\n      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content as string);\n      } else if (isAssistantMessage(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n\n  protected _connected() {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners: ListenersForEvent<Events, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners: ListenersForEvent<Events, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof Events>(\n    event: Event,\n  ): Promise<\n    EventParameters<Events, Event> extends [infer Param] ? Param\n    : EventParameters<Events, Event> extends [] ? void\n    : EventParameters<Events, Event>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion(): Promise<ChatCompletion> {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n\n  #getFinalContent(): string | null {\n    return this.#getFinalMessage().content;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent(): Promise<string | null> {\n    await this.done();\n    return this.#getFinalContent();\n  }\n\n  #getFinalMessage(): ChatCompletionAssistantMessageParam {\n    let i = this.messages.length;\n    while (i-- > 0) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message)) {\n        return message;\n      }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage(): Promise<ChatCompletionMessage> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalFunctionCall(): ChatCompletionMessage.FunctionCall | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message) && message?.function_call) {\n        return message.function_call;\n      }\n    }\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall(): Promise<ChatCompletionMessage.FunctionCall | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCall();\n  }\n\n  #getFinalFunctionCallResult(): string | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isFunctionMessage(message) && message.content != null) {\n        return message.content as string;\n      }\n    }\n  }\n\n  async finalFunctionCallResult(): Promise<string | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCallResult();\n  }\n\n  #calculateTotalUsage(): CompletionUsage {\n    const total: CompletionUsage = {\n      completion_tokens: 0,\n      prompt_tokens: 0,\n      total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n      if (usage) {\n        total.completion_tokens += usage.completion_tokens;\n        total.prompt_tokens += usage.prompt_tokens;\n        total.total_tokens += usage.total_tokens;\n      }\n    }\n    return total;\n  }\n\n  async totalUsage(): Promise<CompletionUsage> {\n    await this.done();\n    return this.#calculateTotalUsage();\n  }\n\n  allChatCompletions(): ChatCompletion[] {\n    return [...this._chatCompletions];\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const openAIError: OpenAIError = new OpenAIError(error.message);\n      // @ts-ignore\n      openAIError.cause = error;\n      return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n  };\n\n  protected _emit<Event extends keyof Events>(event: Event, ...args: EventParameters<Events, Event>) {\n    // make sure we don't emit any events after end\n    if (this.#ended) return;\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: ListenersForEvent<Events, Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as OpenAIError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = this.messages[this.messages.length - 1];\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = this.#getFinalContent();\n    if (finalContent) this._emit('finalContent', finalContent);\n\n    const finalFunctionCall = this.#getFinalFunctionCall();\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n\n    const finalFunctionCallResult = this.#getFinalFunctionCallResult();\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n\n    if (this._chatCompletions.some((c) => c.usage)) {\n      this._emit('totalUsage', this.#calculateTotalUsage());\n    }\n  }\n\n  #validateParams(params: ChatCompletionCreateParams): void {\n    if (params.n != null && params.n > 1) {\n      throw new OpenAIError(\n        'ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.',\n      );\n    }\n  }\n\n  protected async _createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#validateParams(params);\n\n    const chatCompletion = await completions.create(\n      { ...params, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addChatCompletion(chatCompletion);\n  }\n\n  protected async _runChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(completions, params, options);\n  }\n\n  protected async _runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    completions: Completions,\n    params:\n      | ChatCompletionFunctionRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'function' as const;\n    const { function_call = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n\n    const functions: ChatCompletionCreateParams.Function[] = params.functions.map(\n      (f): ChatCompletionCreateParams.Function => ({\n        name: f.name || f.function.name,\n        parameters: f.parameters as Record<string, unknown>,\n        description: f.description,\n      }),\n    );\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        completions,\n        {\n          ...restParams,\n          function_call,\n          functions,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.function_call) return;\n      const { name, arguments: args } = message.function_call;\n      const fn = functionsByName[name];\n      if (!fn) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n          .map((f) => JSON.stringify(f.name))\n          .join(', ')}. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(\n          singleFunctionToCall,\n        )} requested. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      }\n\n      let parsed;\n      try {\n        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error),\n        });\n        continue;\n      }\n\n      // @ts-expect-error it can't rule out `never` type.\n      const rawContent = await fn.function(parsed, this);\n      const content = this.#stringifyFunctionCallResult(rawContent);\n\n      this._addMessage({ role, name, content });\n\n      if (singleFunctionToCall) return;\n    }\n  }\n\n  protected async _runTools<FunctionsArgs extends BaseFunctionsArgs>(\n    completions: Completions,\n    params:\n      | ChatCompletionToolRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingToolRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'tool' as const;\n    const { tool_choice = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of params.tools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n\n    const tools: ChatCompletionTool[] =\n      'tools' in params ?\n        params.tools.map((t) =>\n          t.type === 'function' ?\n            {\n              type: 'function',\n              function: {\n                name: t.function.name || t.function.function.name,\n                parameters: t.function.parameters as Record<string, unknown>,\n                description: t.function.description,\n              },\n            }\n          : (t as unknown as ChatCompletionTool),\n        )\n      : (undefined as any);\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        completions,\n        {\n          ...restParams,\n          tool_choice,\n          tools,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.tool_calls) return;\n\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const { name, arguments: args } = tool_call.function;\n        const fn = functionsByName[name];\n\n        if (!fn) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${tools\n            .map((f) => JSON.stringify(f.function.name))\n            .join(', ')}. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(\n            singleFunctionToCall,\n          )} requested. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        let parsed;\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = this.#stringifyFunctionCallResult(rawContent);\n        this._addMessage({ role, tool_call_id, content });\n\n        if (singleFunctionToCall) return;\n      }\n    }\n  }\n\n  #stringifyFunctionCallResult(rawContent: unknown): string {\n    return (\n      typeof rawContent === 'string' ? rawContent\n      : rawContent === undefined ? 'undefined'\n      : JSON.stringify(rawContent)\n    );\n  }\n}\n\ntype CustomEvents<Event extends string> = {\n  [k in Event]: k extends keyof AbstractChatCompletionRunnerEvents ? AbstractChatCompletionRunnerEvents[k]\n  : (...args: any[]) => void;\n};\n\ntype ListenerForEvent<\n  Events extends CustomEvents<any>,\n  Event extends keyof Events,\n> = Event extends keyof AbstractChatCompletionRunnerEvents ? AbstractChatCompletionRunnerEvents[Event]\n: Events[Event];\n\ntype ListenersForEvent<Events extends CustomEvents<any>, Event extends keyof Events> = Array<{\n  listener: ListenerForEvent<Events, Event>;\n  once?: boolean;\n}>;\ntype EventParameters<Events extends CustomEvents<any>, Event extends keyof Events> = Parameters<\n  ListenerForEvent<Events, Event>\n>;\n\nexport interface AbstractChatCompletionRunnerEvents {\n  connect: () => void;\n  functionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  message: (message: ChatCompletionMessageParam) => void;\n  chatCompletion: (completion: ChatCompletion) => void;\n  finalContent: (contentSnapshot: string) => void;\n  finalMessage: (message: ChatCompletionMessageParam) => void;\n  finalChatCompletion: (completion: ChatCompletion) => void;\n  finalFunctionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  functionCallResult: (content: string) => void;\n  finalFunctionCallResult: (content: string) => void;\n  error: (error: OpenAIError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n  totalUsage: (usage: CompletionUsage) => void;\n}\n"]},"metadata":{},"sourceType":"module"}