{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\n/** @typedef {{ alias: string|string[], extension: string }} ExtensionAliasOption */\n\n\nmodule.exports = class ExtensionAliasPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {ExtensionAliasOption} options options\n   * @param {string | ResolveStepHook} target target\n   */\n  constructor(source, options, target) {\n    this.source = source;\n    this.options = options;\n    this.target = target;\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  apply(resolver) {\n    const target = resolver.ensureHook(this.target);\n    const {\n      extension,\n      alias\n    } = this.options;\n    resolver.getHook(this.source).tapAsync(\"ExtensionAliasPlugin\", (request, resolveContext, callback) => {\n      const requestPath = request.request;\n      if (!requestPath || !requestPath.endsWith(extension)) return callback();\n      const isAliasString = typeof alias === \"string\";\n      /**\n       * @param {string} alias extension alias\n       * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n       * @param {number} [index] index\n       * @returns {void}\n       */\n\n      const resolve = (alias, callback, index) => {\n        const newRequest = `${requestPath.slice(0, -extension.length)}${alias}`;\n        return resolver.doResolve(target, { ...request,\n          request: newRequest,\n          fullySpecified: true\n        }, `aliased from extension alias with mapping '${extension}' to '${alias}'`, resolveContext, (err, result) => {\n          // Throw error if we are on the last alias (for multiple aliases) and it failed, always throw if we are not an array or we have only one alias\n          if (!isAliasString && index) {\n            if (index !== this.options.alias.length) {\n              if (resolveContext.log) {\n                resolveContext.log(`Failed to alias from extension alias with mapping '${extension}' to '${alias}' for '${newRequest}': ${err}`);\n              }\n\n              return callback(null, result);\n            }\n\n            return callback(err, result);\n          } else {\n            callback(err, result);\n          }\n        });\n      };\n      /**\n       * @param {null|Error} [err] error\n       * @param {null|ResolveRequest} [result] result\n       * @returns {void}\n       */\n\n\n      const stoppingCallback = (err, result) => {\n        if (err) return callback(err);\n        if (result) return callback(null, result); // Don't allow other aliasing or raw request\n\n        return callback(null, null);\n      };\n\n      if (isAliasString) {\n        resolve(alias, stoppingCallback);\n      } else if (alias.length > 1) {\n        forEachBail(alias, resolve, stoppingCallback);\n      } else {\n        resolve(alias[0], stoppingCallback);\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js"],"names":["forEachBail","require","module","exports","ExtensionAliasPlugin","constructor","source","options","target","apply","resolver","ensureHook","extension","alias","getHook","tapAsync","request","resolveContext","callback","requestPath","endsWith","isAliasString","resolve","index","newRequest","slice","length","doResolve","fullySpecified","err","result","log","stoppingCallback"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {{ alias: string|string[], extension: string }} ExtensionAliasOption */\n\nmodule.exports = class ExtensionAliasPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {ExtensionAliasOption} options options\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = options;\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tconst { extension, alias } = this.options;\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ExtensionAliasPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst requestPath = request.request;\n\t\t\t\tif (!requestPath || !requestPath.endsWith(extension)) return callback();\n\t\t\t\tconst isAliasString = typeof alias === \"string\";\n\t\t\t\t/**\n\t\t\t\t * @param {string} alias extension alias\n\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t * @param {number} [index] index\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst resolve = (alias, callback, index) => {\n\t\t\t\t\tconst newRequest = `${requestPath.slice(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t-extension.length\n\t\t\t\t\t)}${alias}`;\n\n\t\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\trequest: newRequest,\n\t\t\t\t\t\t\tfullySpecified: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t`aliased from extension alias with mapping '${extension}' to '${alias}'`,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t// Throw error if we are on the last alias (for multiple aliases) and it failed, always throw if we are not an array or we have only one alias\n\t\t\t\t\t\t\tif (!isAliasString && index) {\n\t\t\t\t\t\t\t\tif (index !== this.options.alias.length) {\n\t\t\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\t\t\t\t`Failed to alias from extension alias with mapping '${extension}' to '${alias}' for '${newRequest}': ${err}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(err, result);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t\t/**\n\t\t\t\t * @param {null|Error} [err] error\n\t\t\t\t * @param {null|ResolveRequest} [result] result\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst stoppingCallback = (err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t};\n\t\t\t\tif (isAliasString) {\n\t\t\t\t\tresolve(alias, stoppingCallback);\n\t\t\t\t} else if (alias.length > 1) {\n\t\t\t\t\tforEachBail(alias, resolve, stoppingCallback);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(alias[0], stoppingCallback);\n\t\t\t\t}\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}