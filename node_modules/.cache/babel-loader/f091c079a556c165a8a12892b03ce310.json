{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode = decode;\n\nvar _helperApiError = require(\"@webassemblyjs/helper-api-error\");\n\nvar ieee754 = _interopRequireWildcard(require(\"@webassemblyjs/ieee754\"));\n\nvar utf8 = _interopRequireWildcard(require(\"@webassemblyjs/utf8\"));\n\nvar t = _interopRequireWildcard(require(\"@webassemblyjs/ast\"));\n\nvar _leb = require(\"@webassemblyjs/leb128\");\n\nvar _helperWasmBytecode = _interopRequireDefault(require(\"@webassemblyjs/helper-wasm-bytecode\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\n\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n\n  function isEOF() {\n    return offset >= buf.length;\n  }\n\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n\n    return arr;\n  }\n\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n\n  function readU32() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n\n  function read32() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeInt32)(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n\n  function read64() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeInt64)(buffer);\n  }\n\n  function readU64() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt64)(buffer);\n  }\n\n  function readByte() {\n    return readBytes(1)[0];\n  }\n\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var header = readBytes(4);\n\n    if (byteArrayEq(_helperWasmBytecode[\"default\"].magicModuleHeader, header) === false) {\n      throw new _helperApiError.CompileError(\"magic header not detected\");\n    }\n\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var version = readBytes(4);\n\n    if (byteArrayEq(_helperWasmBytecode[\"default\"].moduleVersion, version) === false) {\n      throw new _helperApiError.CompileError(\"unknown binary version\");\n    }\n\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n\n    if (length === 0) {\n      return [];\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < length; i++) {\n      var _byte = readByte();\n\n      eatBytes(1);\n      var value = cast(_byte);\n      dump([_byte], value);\n\n      if (typeof value === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n\n      elements.push(value);\n    }\n\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n\n      if (type == _helperWasmBytecode[\"default\"].types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          return _helperWasmBytecode[\"default\"].valtypes[b];\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(\n          /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return _helperWasmBytecode[\"default\"].valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = _helperWasmBytecode[\"default\"].importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n\n      if (typeof descrType === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n\n      var importDescr = void 0;\n\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new _helperApiError.CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"memory\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new _helperApiError.CompileError(\"Unsupported import of type: \" + descrType);\n      }\n\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n\n      if (typeof signature === \"undefined\") {\n        throw new _helperApiError.CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n          signature = void 0;\n\n      if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n\n        if (typeof func === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n\n        if (typeof table === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown table \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Memory\") {\n        var memNode = state.memoriesInModule[index];\n\n        if (typeof memNode === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown memory \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n\n        if (typeof global === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown global \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: _helperWasmBytecode[\"default\"].exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = [];\n      /**\n       * Parse locals\n       */\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = _helperWasmBytecode[\"default\"].valtypes[valtypeByte];\n        var args = [];\n\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n\n        locals.push(localNode);\n        dump([valtypeByte], type);\n\n        if (typeof type === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n\n      if (instructionByte === 0xfe) {\n        instructionByte = 0xfe00 + readByte();\n        eatBytes(1);\n      }\n\n      var instruction = _helperWasmBytecode[\"default\"].symbolsByByte[instructionByte];\n\n      if (typeof instruction === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n\n        code.push(node);\n        break;\n      }\n\n      var args = [];\n      var namedArgs = void 0;\n\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n\n        var blocktypeByte = readByte();\n        eatBytes(1);\n        var blocktype = _helperWasmBytecode[\"default\"].blockTypes[blocktypeByte];\n        dump([blocktypeByte], \"blocktype\");\n\n        if (typeof blocktype === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected blocktype: \" + toHex(blocktypeByte));\n        }\n\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n\n        var _blocktypeByte = readByte();\n\n        eatBytes(1);\n        var _blocktype = _helperWasmBytecode[\"default\"].blockTypes[_blocktypeByte];\n        dump([_blocktypeByte], \"blocktype\");\n\n        if (typeof _blocktype === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte));\n        }\n\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n\n        var _blocktypeByte2 = readByte();\n\n        eatBytes(1);\n        var _blocktype2 = _helperWasmBytecode[\"default\"].blockTypes[_blocktypeByte2];\n        dump([_blocktypeByte2], \"blocktype\");\n\n        if (typeof _blocktype2 === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte2));\n        }\n\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new _helperApiError.CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n\n        if (flag !== 0) {\n          throw new _helperApiError.CompileError(\"zero flag expected\");\n        }\n\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n          if (namedArgs === undefined) namedArgs = {};\n          namedArgs.offset = t.numberLiteralFromRaw(_offset2);\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n              low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n              _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else if (instructionByte >= 0xfe00 && instructionByte <= 0xfeff) {\n        /**\n         * Atomic memory instructions\n         */\n        var align32 = readU32();\n        var _align = align32.value;\n        eatBytes(align32.nextIndex);\n        dump([_align], \"align\");\n\n        var _offsetu = readU32();\n\n        var _offset3 = _offsetu.value;\n        eatBytes(_offsetu.nextIndex);\n        dump([_offset3], \"offset\");\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    var shared = limitType === 0x03;\n    dump([limitType], \"limit type\" + (shared ? \" (shared)\" : \"\"));\n    var min, max;\n\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n\n    return t.limit(min, max, shared);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = _helperWasmBytecode[\"default\"].tableTypes[elementTypeByte];\n\n    if (typeof elementType === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Unknown element type in table: \" + toHex(elementType));\n    }\n\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = _helperWasmBytecode[\"default\"].valtypes[valtypeByte];\n    dump([valtypeByte], type);\n\n    if (typeof type === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = _helperWasmBytecode[\"default\"].globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n\n    if (typeof globalType === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n\n    return functionNames;\n  }\n\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n\n      metadata.producers.push(fields[fieldName.value]);\n    }\n\n    return metadata;\n  }\n\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n\n    return globals;\n  }\n\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n\n      var tableindexu32 = readU32();\n      var tableindex = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([tableindex], \"table index\");\n      /**\n       * Parse instructions\n       */\n\n      var instr = [];\n      parseInstructionBlock(instr);\n      /**\n       * Parse ( vector function index ) *\n       */\n\n      var indicesu32 = readU32();\n      var indices = indicesu32.value;\n      eatBytes(indicesu32.nextIndex);\n      dump([indices], \"num indices\");\n      var indexValues = [];\n\n      for (var _i5 = 0; _i5 < indices; _i5++) {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        indexValues.push(t.indexLiteral(index));\n      }\n\n      var elemNode = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.elem(t.indexLiteral(tableindex), instr, indexValues), endLoc, _startLoc12);\n      }();\n\n      elems.push(elemNode);\n    }\n\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n\n      if (hasExtraInstrs) {\n        throw new _helperApiError.CompileError(\"data section offset must be a single instruction\");\n      }\n\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n\n    if (sectionId >= sectionIndex || sectionIndex === _helperWasmBytecode[\"default\"].sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== _helperWasmBytecode[\"default\"].sections.custom) throw new _helperApiError.CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n\n    switch (sectionId) {\n      case _helperWasmBytecode[\"default\"].sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc13 = getPosition();\n\n          var _u = readU32();\n\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n          var metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n          var nodes = parseTypeSection(numberOfTypes);\n          return {\n            nodes: nodes,\n            metadata: metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc14 = getPosition();\n\n          var _u2 = readU32();\n\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n\n          var _metadata = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n\n          var _nodes = parseTableSection(numberOfTable);\n\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections[\"import\"]:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc15 = getPosition();\n\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n\n          var _metadata2 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n\n          var _nodes2 = parseImportSection(numberOfImports);\n\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc16 = getPosition();\n\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n\n          var _metadata3 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n\n          parseFuncSection(numberOfFunctions);\n          var _nodes3 = [];\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections[\"export\"]:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc17 = getPosition();\n\n          var _u3 = readU32();\n\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n\n          var _metadata4 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n\n          parseExportSection(numberOfExport);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc18 = getPosition();\n\n          var _u4 = readU32();\n\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n\n          var _metadata5 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata6 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n\n          var _nodes6 = [parseStartSection()];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc19 = getPosition();\n\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n\n          var _metadata7 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n\n          var _nodes7 = parseElemSection(numberOfElements);\n\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc20 = getPosition();\n\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n\n          var _metadata8 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n\n          var _nodes8 = parseGlobalSection(numberOfGlobals);\n\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc21 = getPosition();\n\n          var _numberOfElementsu = readU32();\n\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n\n          var _metadata9 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n\n          var _nodes9 = parseMemorySection(_numberOfElements);\n\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata10 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n\n          var _startLoc22 = getPosition();\n\n          var _numberOfElementsu2 = readU32();\n\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n\n          _metadata10.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes10 = parseDataSection(_numberOfElements2);\n\n            return {\n              nodes: _nodes10,\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata11 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n\n            try {\n              _metadata11.push.apply(_metadata11, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n\n            try {\n              _metadata11.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n\n          return {\n            nodes: [],\n            metadata: _metadata11,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n\n    if (opts.errorOnUnknownSection) {\n      throw new _helperApiError.CompileError(\"Unexpected section: \" + toHex(sectionId));\n    } else {\n      dumpSep(\"section \" + toHex(sectionId));\n      dump([sectionId], \"section code\");\n      dump([sectionSizeInBytes], \"section size\");\n      eatBytes(sectionSizeInBytes);\n      dumpSep(\"ignoring (\" + sectionSizeInBytes + \" bytes)\");\n      return {\n        nodes: [],\n        metadata: [],\n        nextSectionIndex: 0\n      };\n    }\n  }\n\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n        nodes = _parseSection.nodes,\n        metadata = _parseSection.metadata,\n        nextSectionIndex = _parseSection.nextSectionIndex;\n\n    moduleFields.push.apply(moduleFields, _toConsumableArray(nodes));\n    var metadataArray = Array.isArray(metadata) ? metadata : [metadata];\n    metadataArray.forEach(function (metadataItem) {\n      // $FlowIgnore\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new _helperApiError.CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n\n      body = decodedElementInCodeSection.code;\n    }\n\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n          endLoc = decodedElementInCodeSection.endLoc,\n          bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@webassemblyjs/wasm-parser/lib/decoder.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","exports","value","decode","_helperApiError","require","ieee754","_interopRequireWildcard","utf8","t","_leb","_helperWasmBytecode","_interopRequireDefault","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","toString","slice","name","Array","from","test","iter","isArray","len","length","i","arr2","toHex","Number","byteArrayEq","l","r","ab","opts","buf","Uint8Array","getUniqueName","getUniqueNameGenerator","offset","getPosition","line","column","dump","b","msg","pad","str","map","join","console","log","dumpSep","state","elementsInFuncSection","elementsInExportSection","elementsInCodeSection","memoriesInModule","typesInModule","functionsInModule","tablesInModule","globalsInModule","isEOF","eatBytes","readBytesAtOffset","_offset","numberOfBytes","push","readBytes","readF64","bytes","NUMBER_OF_BYTE_F64","decodeF64","Math","sign","Infinity","inf","nextIndex","isNaN","mantissa","pow","nan","readF32","NUMBER_OF_BYTE_F32","decodeF32","readUTF8String","lenu32","readU32","strlen","MAX_NUMBER_OF_BYTE_U32","buffer","Buffer","decodeUInt32","readVaruint32","readVaruint7","read32","decodeInt32","read64","MAX_NUMBER_OF_BYTE_U64","decodeInt64","readU64","decodeUInt64","readByte","parseModuleHeader","Error","header","magicModuleHeader","CompileError","parseVersion","version","moduleVersion","parseVec","cast","u32","elements","_byte","parseTypeSection","numberOfTypes","typeInstructionNodes","_startLoc","type","types","func","paramValtypes","valtypes","params","v","funcParam","result","endLoc","withLoc","typeInstruction","undefined","signature","parseImportSection","numberOfImports","imports","_startLoc2","moduleName","concat","descrTypeByte","descrType","importTypes","importDescr","indexU32","typeindex","id","funcImportDescr","identifier","isExternal","parseGlobalType","globalNode","global","parseTableType","memoryNode","parseMemoryType","moduleImport","parseFuncSection","numberOfFunctions","withRaw","parseExportSection","numberOfExport","_startLoc3","typeIndex","indexu32","index","exportTypes","numberLiteralFromRaw","String","table","memNode","warn","startLoc","parseCodeSection","numberOfFuncs","_startLoc4","bodySizeU32","code","funcLocalNumU32","funcLocalNum","locals","_i","_startLoc5","localCountU32","localCount","valtypeByte","args","_i2","valtypeLiteral","localNode","instruction","apply","parseInstructionBlock","bodySize","_startLoc6","instructionAlreadyCreated","instructionByte","symbolsByByte","object","node","namedArgs","_startLoc7","blocktypeByte","blocktype","blockTypes","instr","label","loopNode","loopInstruction","_startLoc8","_blocktypeByte","_blocktype","testIndex","ifBody","elseIndex","_instr","consequentInstr","alternate","testInstrs","ifNode","ifInstruction","_startLoc9","_blocktypeByte2","_blocktype2","_instr2","_label","blockNode","blockInstruction","callNode","callInstruction","indexLiteral","_startLoc10","_callNode","callIndirectInstruction","flagU32","flag","indicesu32","indices","_indexu","_index","_indexU","_index2","aligun32","align","offsetu32","_offset2","value32","valueu32","_value","value64","_value2","high","low","_node","valueu64","_value3","_high","_low","_node2","valuef32","_value4","floatLiteral","valuef64","_value5","align32","_align","_offsetu","_offset3","_i3","numberOfArgs","_node3","objectInstruction","_node4","parseLimits","limitType","shared","min","max","u32min","parseInt","u32max","_u32min","limit","elementTypeByte","elementType","tableTypes","limits","globalTypeByte","globalType","globalTypes","parseNameSectionFunctions","functionNames","numberOfFunctionsu32","numbeOfFunctions","functionNameMetadata","parseNameSectionLocals","localNames","numbeOfFunctionsu32","functionIndexu32","functionIndex","numLocalsu32","numLocals","_i4","localIndexu32","localIndex","localNameMetadata","parseNameSection","remainingBytes","nameMetadata","initialOffset","sectionTypeByte","subSectionSizeInBytesu32","parseProducersSection","metadata","producersSectionMetadata","fields","language","sdk","fieldI","fieldName","valueCount","producerI","producerName","producerVersion","producerMetadataVersionedName","producers","parseGlobalSection","numberOfGlobals","globals","_startLoc11","init","parseElemSection","numberOfElements","elems","_startLoc12","tableindexu32","tableindex","indexValues","_i5","elemNode","elem","memory","parseTableSection","tables","tablesNode","parseMemorySection","memories","parseStartSection","startFuncIndex","start","parseDataSection","dataEntries","memoryIndexu32","memoryIndex","instrs","hasExtraInstrs","filter","data","memIndexLiteral","byteArray","parseSection","sectionIndex","sectionId","sections","custom","nextSectionIndex","startOffset","sectionSizeInBytes","sectionSizeInBytesNode","_startLoc13","_u","sectionMetadata","nodes","_startLoc14","_u2","numberOfTable","_metadata","_nodes","_startLoc15","numberOfImportsu32","_metadata2","_nodes2","_startLoc16","_metadata3","_nodes3","_startLoc17","_u3","_metadata4","_nodes4","_startLoc18","_u4","_metadata5","ignoreCodeSection","_nodes5","_metadata6","_nodes6","element","_startLoc19","numberOfElementsu32","_metadata7","_nodes7","_startLoc20","numberOfGlobalsu32","_metadata8","_nodes8","_startLoc21","_numberOfElementsu","_numberOfElements","_metadata9","_nodes9","_metadata10","_startLoc22","_numberOfElementsu2","_numberOfElements2","vectorOfSize","ignoreDataSection","_remainingBytes","_nodes10","_metadata11","sectionName","_remainingBytes2","e","message","_initialOffset","JSON","stringify","errorOnUnknownSection","moduleFields","moduleMetadata","_parseSection","metadataArray","forEach","metadataItem","funcIndex","body","decodedElementInCodeSection","funcNode","_startLoc23","moduleExport","moduleExportDescr","module","program"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode = decode;\n\nvar _helperApiError = require(\"@webassemblyjs/helper-api-error\");\n\nvar ieee754 = _interopRequireWildcard(require(\"@webassemblyjs/ieee754\"));\n\nvar utf8 = _interopRequireWildcard(require(\"@webassemblyjs/utf8\"));\n\nvar t = _interopRequireWildcard(require(\"@webassemblyjs/ast\"));\n\nvar _leb = require(\"@webassemblyjs/leb128\");\n\nvar _helperWasmBytecode = _interopRequireDefault(require(\"@webassemblyjs/helper-wasm-bytecode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\n\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n\n  function isEOF() {\n    return offset >= buf.length;\n  }\n\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n\n    return arr;\n  }\n\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n\n  function readU32() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n\n  function read32() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeInt32)(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n\n  function read64() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeInt64)(buffer);\n  }\n\n  function readU64() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return (0, _leb.decodeUInt64)(buffer);\n  }\n\n  function readByte() {\n    return readBytes(1)[0];\n  }\n\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var header = readBytes(4);\n\n    if (byteArrayEq(_helperWasmBytecode[\"default\"].magicModuleHeader, header) === false) {\n      throw new _helperApiError.CompileError(\"magic header not detected\");\n    }\n\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var version = readBytes(4);\n\n    if (byteArrayEq(_helperWasmBytecode[\"default\"].moduleVersion, version) === false) {\n      throw new _helperApiError.CompileError(\"unknown binary version\");\n    }\n\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n\n    if (length === 0) {\n      return [];\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < length; i++) {\n      var _byte = readByte();\n\n      eatBytes(1);\n      var value = cast(_byte);\n      dump([_byte], value);\n\n      if (typeof value === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n\n      elements.push(value);\n    }\n\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n\n      if (type == _helperWasmBytecode[\"default\"].types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          return _helperWasmBytecode[\"default\"].valtypes[b];\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(\n          /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return _helperWasmBytecode[\"default\"].valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = _helperWasmBytecode[\"default\"].importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n\n      if (typeof descrType === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n\n      var importDescr = void 0;\n\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new _helperApiError.CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"memory\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new _helperApiError.CompileError(\"Unsupported import of type: \" + descrType);\n      }\n\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n\n      if (typeof signature === \"undefined\") {\n        throw new _helperApiError.CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n          signature = void 0;\n\n      if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n\n        if (typeof func === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n\n        if (typeof table === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown table \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Memory\") {\n        var memNode = state.memoriesInModule[index];\n\n        if (typeof memNode === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown memory \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n\n        if (typeof global === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown global \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: _helperWasmBytecode[\"default\"].exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = [];\n      /**\n       * Parse locals\n       */\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = _helperWasmBytecode[\"default\"].valtypes[valtypeByte];\n        var args = [];\n\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n\n        locals.push(localNode);\n        dump([valtypeByte], type);\n\n        if (typeof type === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n\n      if (instructionByte === 0xfe) {\n        instructionByte = 0xfe00 + readByte();\n        eatBytes(1);\n      }\n\n      var instruction = _helperWasmBytecode[\"default\"].symbolsByByte[instructionByte];\n\n      if (typeof instruction === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n\n        code.push(node);\n        break;\n      }\n\n      var args = [];\n      var namedArgs = void 0;\n\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n\n        var blocktypeByte = readByte();\n        eatBytes(1);\n        var blocktype = _helperWasmBytecode[\"default\"].blockTypes[blocktypeByte];\n        dump([blocktypeByte], \"blocktype\");\n\n        if (typeof blocktype === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected blocktype: \" + toHex(blocktypeByte));\n        }\n\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n\n        var _blocktypeByte = readByte();\n\n        eatBytes(1);\n        var _blocktype = _helperWasmBytecode[\"default\"].blockTypes[_blocktypeByte];\n        dump([_blocktypeByte], \"blocktype\");\n\n        if (typeof _blocktype === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte));\n        }\n\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n\n        var _blocktypeByte2 = readByte();\n\n        eatBytes(1);\n        var _blocktype2 = _helperWasmBytecode[\"default\"].blockTypes[_blocktypeByte2];\n        dump([_blocktypeByte2], \"blocktype\");\n\n        if (typeof _blocktype2 === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte2));\n        }\n\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new _helperApiError.CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n\n        if (flag !== 0) {\n          throw new _helperApiError.CompileError(\"zero flag expected\");\n        }\n\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n          if (namedArgs === undefined) namedArgs = {};\n          namedArgs.offset = t.numberLiteralFromRaw(_offset2);\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n              low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n              _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else if (instructionByte >= 0xfe00 && instructionByte <= 0xfeff) {\n        /**\n         * Atomic memory instructions\n         */\n        var align32 = readU32();\n        var _align = align32.value;\n        eatBytes(align32.nextIndex);\n        dump([_align], \"align\");\n\n        var _offsetu = readU32();\n\n        var _offset3 = _offsetu.value;\n        eatBytes(_offsetu.nextIndex);\n        dump([_offset3], \"offset\");\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    var shared = limitType === 0x03;\n    dump([limitType], \"limit type\" + (shared ? \" (shared)\" : \"\"));\n    var min, max;\n\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n\n    return t.limit(min, max, shared);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = _helperWasmBytecode[\"default\"].tableTypes[elementTypeByte];\n\n    if (typeof elementType === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Unknown element type in table: \" + toHex(elementType));\n    }\n\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = _helperWasmBytecode[\"default\"].valtypes[valtypeByte];\n    dump([valtypeByte], type);\n\n    if (typeof type === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = _helperWasmBytecode[\"default\"].globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n\n    if (typeof globalType === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n\n    return functionNames;\n  }\n\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n\n      metadata.producers.push(fields[fieldName.value]);\n    }\n\n    return metadata;\n  }\n\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n\n    return globals;\n  }\n\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n\n      var tableindexu32 = readU32();\n      var tableindex = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([tableindex], \"table index\");\n      /**\n       * Parse instructions\n       */\n\n      var instr = [];\n      parseInstructionBlock(instr);\n      /**\n       * Parse ( vector function index ) *\n       */\n\n      var indicesu32 = readU32();\n      var indices = indicesu32.value;\n      eatBytes(indicesu32.nextIndex);\n      dump([indices], \"num indices\");\n      var indexValues = [];\n\n      for (var _i5 = 0; _i5 < indices; _i5++) {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        indexValues.push(t.indexLiteral(index));\n      }\n\n      var elemNode = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.elem(t.indexLiteral(tableindex), instr, indexValues), endLoc, _startLoc12);\n      }();\n\n      elems.push(elemNode);\n    }\n\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n\n      if (hasExtraInstrs) {\n        throw new _helperApiError.CompileError(\"data section offset must be a single instruction\");\n      }\n\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n\n    if (sectionId >= sectionIndex || sectionIndex === _helperWasmBytecode[\"default\"].sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== _helperWasmBytecode[\"default\"].sections.custom) throw new _helperApiError.CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n\n    switch (sectionId) {\n      case _helperWasmBytecode[\"default\"].sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc13 = getPosition();\n\n          var _u = readU32();\n\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n          var metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n          var nodes = parseTypeSection(numberOfTypes);\n          return {\n            nodes: nodes,\n            metadata: metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc14 = getPosition();\n\n          var _u2 = readU32();\n\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n\n          var _metadata = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n\n          var _nodes = parseTableSection(numberOfTable);\n\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections[\"import\"]:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc15 = getPosition();\n\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n\n          var _metadata2 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n\n          var _nodes2 = parseImportSection(numberOfImports);\n\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc16 = getPosition();\n\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n\n          var _metadata3 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n\n          parseFuncSection(numberOfFunctions);\n          var _nodes3 = [];\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections[\"export\"]:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc17 = getPosition();\n\n          var _u3 = readU32();\n\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n\n          var _metadata4 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n\n          parseExportSection(numberOfExport);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc18 = getPosition();\n\n          var _u4 = readU32();\n\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n\n          var _metadata5 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata6 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n\n          var _nodes6 = [parseStartSection()];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc19 = getPosition();\n\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n\n          var _metadata7 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n\n          var _nodes7 = parseElemSection(numberOfElements);\n\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc20 = getPosition();\n\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n\n          var _metadata8 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n\n          var _nodes8 = parseGlobalSection(numberOfGlobals);\n\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc21 = getPosition();\n\n          var _numberOfElementsu = readU32();\n\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n\n          var _metadata9 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n\n          var _nodes9 = parseMemorySection(_numberOfElements);\n\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata10 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n\n          var _startLoc22 = getPosition();\n\n          var _numberOfElementsu2 = readU32();\n\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n\n          _metadata10.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes10 = parseDataSection(_numberOfElements2);\n\n            return {\n              nodes: _nodes10,\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata11 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n\n            try {\n              _metadata11.push.apply(_metadata11, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n\n            try {\n              _metadata11.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n\n          return {\n            nodes: [],\n            metadata: _metadata11,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n\n    if (opts.errorOnUnknownSection) {\n      throw new _helperApiError.CompileError(\"Unexpected section: \" + toHex(sectionId));\n    } else {\n      dumpSep(\"section \" + toHex(sectionId));\n      dump([sectionId], \"section code\");\n      dump([sectionSizeInBytes], \"section size\");\n      eatBytes(sectionSizeInBytes);\n      dumpSep(\"ignoring (\" + sectionSizeInBytes + \" bytes)\");\n      return {\n        nodes: [],\n        metadata: [],\n        nextSectionIndex: 0\n      };\n    }\n  }\n\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n        nodes = _parseSection.nodes,\n        metadata = _parseSection.metadata,\n        nextSectionIndex = _parseSection.nextSectionIndex;\n\n    moduleFields.push.apply(moduleFields, _toConsumableArray(nodes));\n    var metadataArray = Array.isArray(metadata) ? metadata : [metadata];\n    metadataArray.forEach(function (metadataItem) {\n      // $FlowIgnore\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new _helperApiError.CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n\n      body = decodedElementInCodeSection.code;\n    }\n\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n          endLoc = decodedElementInCodeSection.endLoc,\n          bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}"]},"metadata":{},"sourceType":"script"}