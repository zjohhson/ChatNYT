{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\n\nconst ExternalModule = require(\"../ExternalModule\");\n\nconst Template = require(\"../Template\");\n\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\n/**\n * @typedef {Object} AmdLibraryPluginOptions\n * @property {LibraryType} type\n * @property {boolean=} requireAsWrapper\n */\n\n/**\n * @typedef {Object} AmdLibraryPluginParsed\n * @property {string} name\n * @property {string} amdContainer\n */\n\n/**\n * @typedef {AmdLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AmdLibraryPluginParsed>}\n */\n\n\nclass AmdLibraryPlugin extends AbstractLibraryPlugin {\n  /**\n   * @param {AmdLibraryPluginOptions} options the plugin options\n   */\n  constructor(options) {\n    super({\n      pluginName: \"AmdLibraryPlugin\",\n      type: options.type\n    });\n    this.requireAsWrapper = options.requireAsWrapper;\n  }\n  /**\n   * @param {LibraryOptions} library normalized library option\n   * @returns {T | false} preprocess as needed by overriding\n   */\n\n\n  parseOptions(library) {\n    const {\n      name,\n      amdContainer\n    } = library;\n\n    if (this.requireAsWrapper) {\n      if (name) {\n        throw new Error(`AMD library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    } else {\n      if (name && typeof name !== \"string\") {\n        throw new Error(`AMD library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    }\n\n    return {\n      name:\n      /** @type {string} */\n      name,\n      amdContainer:\n      /** @type {string} */\n      amdContainer\n    };\n  }\n  /**\n   * @param {Source} source source\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n\n\n  render(source, _ref, _ref2) {\n    let {\n      chunkGraph,\n      chunk,\n      runtimeTemplate\n    } = _ref;\n    let {\n      options,\n      compilation\n    } = _ref2;\n    const modern = runtimeTemplate.supportsArrowFunction();\n    const modules = chunkGraph.getChunkModules(chunk).filter(m => m instanceof ExternalModule);\n    const externals =\n    /** @type {ExternalModule[]} */\n    modules;\n    const externalsDepsArray = JSON.stringify(externals.map(m => typeof m.request === \"object\" && !Array.isArray(m.request) ? m.request.amd : m.request));\n    const externalsArguments = externals.map(m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${chunkGraph.getModuleId(m)}`)}__`).join(\", \");\n    const iife = runtimeTemplate.isIIFE();\n    const fnStart = (modern ? `(${externalsArguments}) => {` : `function(${externalsArguments}) {`) + (iife || !chunk.hasRuntime() ? \" return \" : \"\\n\");\n    const fnEnd = iife ? \";\\n}\" : \"\\n}\";\n    let amdContainerPrefix = \"\";\n\n    if (options.amdContainer) {\n      amdContainerPrefix = `${options.amdContainer}.`;\n    }\n\n    if (this.requireAsWrapper) {\n      return new ConcatSource(`${amdContainerPrefix}require(${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);\n    } else if (options.name) {\n      const name = compilation.getPath(options.name, {\n        chunk\n      });\n      return new ConcatSource(`${amdContainerPrefix}define(${JSON.stringify(name)}, ${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);\n    } else if (externalsArguments) {\n      return new ConcatSource(`${amdContainerPrefix}define(${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);\n    } else {\n      return new ConcatSource(`${amdContainerPrefix}define(${fnStart}`, source, `${fnEnd});`);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Hash} hash hash\n   * @param {ChunkHashContext} chunkHashContext chunk hash context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n\n\n  chunkHash(chunk, hash, chunkHashContext, _ref3) {\n    let {\n      options,\n      compilation\n    } = _ref3;\n    hash.update(\"AmdLibraryPlugin\");\n\n    if (this.requireAsWrapper) {\n      hash.update(\"requireAsWrapper\");\n    } else if (options.name) {\n      hash.update(\"named\");\n      const name = compilation.getPath(options.name, {\n        chunk\n      });\n      hash.update(name);\n    } else if (options.amdContainer) {\n      hash.update(\"amdContainer\");\n      hash.update(options.amdContainer);\n    }\n  }\n\n}\n\nmodule.exports = AmdLibraryPlugin;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/library/AmdLibraryPlugin.js"],"names":["ConcatSource","require","ExternalModule","Template","AbstractLibraryPlugin","AmdLibraryPlugin","constructor","options","pluginName","type","requireAsWrapper","parseOptions","library","name","amdContainer","Error","COMMON_LIBRARY_NAME_MESSAGE","render","source","chunkGraph","chunk","runtimeTemplate","compilation","modern","supportsArrowFunction","modules","getChunkModules","filter","m","externals","externalsDepsArray","JSON","stringify","map","request","Array","isArray","amd","externalsArguments","toIdentifier","getModuleId","join","iife","isIIFE","fnStart","hasRuntime","fnEnd","amdContainerPrefix","getPath","chunkHash","hash","chunkHashContext","update","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst ExternalModule = require(\"../ExternalModule\");\nconst Template = require(\"../Template\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\n/**\n * @typedef {Object} AmdLibraryPluginOptions\n * @property {LibraryType} type\n * @property {boolean=} requireAsWrapper\n */\n\n/**\n * @typedef {Object} AmdLibraryPluginParsed\n * @property {string} name\n * @property {string} amdContainer\n */\n\n/**\n * @typedef {AmdLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AmdLibraryPluginParsed>}\n */\nclass AmdLibraryPlugin extends AbstractLibraryPlugin {\n\t/**\n\t * @param {AmdLibraryPluginOptions} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tsuper({\n\t\t\tpluginName: \"AmdLibraryPlugin\",\n\t\t\ttype: options.type\n\t\t});\n\t\tthis.requireAsWrapper = options.requireAsWrapper;\n\t}\n\n\t/**\n\t * @param {LibraryOptions} library normalized library option\n\t * @returns {T | false} preprocess as needed by overriding\n\t */\n\tparseOptions(library) {\n\t\tconst { name, amdContainer } = library;\n\t\tif (this.requireAsWrapper) {\n\t\t\tif (name) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`AMD library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name && typeof name !== \"string\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`AMD library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: /** @type {string} */ (name),\n\t\t\tamdContainer: /** @type {string} */ (amdContainer)\n\t\t};\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trender(\n\t\tsource,\n\t\t{ chunkGraph, chunk, runtimeTemplate },\n\t\t{ options, compilation }\n\t) {\n\t\tconst modern = runtimeTemplate.supportsArrowFunction();\n\t\tconst modules = chunkGraph\n\t\t\t.getChunkModules(chunk)\n\t\t\t.filter(m => m instanceof ExternalModule);\n\t\tconst externals = /** @type {ExternalModule[]} */ (modules);\n\t\tconst externalsDepsArray = JSON.stringify(\n\t\t\texternals.map(m =>\n\t\t\t\ttypeof m.request === \"object\" && !Array.isArray(m.request)\n\t\t\t\t\t? m.request.amd\n\t\t\t\t\t: m.request\n\t\t\t)\n\t\t);\n\t\tconst externalsArguments = externals\n\t\t\t.map(\n\t\t\t\tm =>\n\t\t\t\t\t`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(\n\t\t\t\t\t\t`${chunkGraph.getModuleId(m)}`\n\t\t\t\t\t)}__`\n\t\t\t)\n\t\t\t.join(\", \");\n\n\t\tconst iife = runtimeTemplate.isIIFE();\n\t\tconst fnStart =\n\t\t\t(modern\n\t\t\t\t? `(${externalsArguments}) => {`\n\t\t\t\t: `function(${externalsArguments}) {`) +\n\t\t\t(iife || !chunk.hasRuntime() ? \" return \" : \"\\n\");\n\t\tconst fnEnd = iife ? \";\\n}\" : \"\\n}\";\n\n\t\tlet amdContainerPrefix = \"\";\n\t\tif (options.amdContainer) {\n\t\t\tamdContainerPrefix = `${options.amdContainer}.`;\n\t\t}\n\n\t\tif (this.requireAsWrapper) {\n\t\t\treturn new ConcatSource(\n\t\t\t\t`${amdContainerPrefix}require(${externalsDepsArray}, ${fnStart}`,\n\t\t\t\tsource,\n\t\t\t\t`${fnEnd});`\n\t\t\t);\n\t\t} else if (options.name) {\n\t\t\tconst name = compilation.getPath(options.name, {\n\t\t\t\tchunk\n\t\t\t});\n\n\t\t\treturn new ConcatSource(\n\t\t\t\t`${amdContainerPrefix}define(${JSON.stringify(\n\t\t\t\t\tname\n\t\t\t\t)}, ${externalsDepsArray}, ${fnStart}`,\n\t\t\t\tsource,\n\t\t\t\t`${fnEnd});`\n\t\t\t);\n\t\t} else if (externalsArguments) {\n\t\t\treturn new ConcatSource(\n\t\t\t\t`${amdContainerPrefix}define(${externalsDepsArray}, ${fnStart}`,\n\t\t\t\tsource,\n\t\t\t\t`${fnEnd});`\n\t\t\t);\n\t\t} else {\n\t\t\treturn new ConcatSource(\n\t\t\t\t`${amdContainerPrefix}define(${fnStart}`,\n\t\t\t\tsource,\n\t\t\t\t`${fnEnd});`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Hash} hash hash\n\t * @param {ChunkHashContext} chunkHashContext chunk hash context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tchunkHash(chunk, hash, chunkHashContext, { options, compilation }) {\n\t\thash.update(\"AmdLibraryPlugin\");\n\t\tif (this.requireAsWrapper) {\n\t\t\thash.update(\"requireAsWrapper\");\n\t\t} else if (options.name) {\n\t\t\thash.update(\"named\");\n\t\t\tconst name = compilation.getPath(options.name, {\n\t\t\t\tchunk\n\t\t\t});\n\t\t\thash.update(name);\n\t\t} else if (options.amdContainer) {\n\t\t\thash.update(\"amdContainer\");\n\t\t\thash.update(options.amdContainer);\n\t\t}\n\t}\n}\n\nmodule.exports = AmdLibraryPlugin;\n"]},"metadata":{},"sourceType":"script"}