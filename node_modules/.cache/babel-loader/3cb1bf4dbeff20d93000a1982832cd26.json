{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, function (exports) {\n  'use strict';\n\n  const comma = ','.charCodeAt(0);\n  const semicolon = ';'.charCodeAt(0);\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  const intToChar = new Uint8Array(64); // 64 possible chars.\n\n  const charToInt = new Uint8Array(128); // z is 122 in ASCII\n\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n  } // Provide a fallback for older environments.\n\n\n  const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode(buf) {\n      const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n\n  } : {\n    decode(buf) {\n      let out = '';\n\n      for (let i = 0; i < buf.length; i++) {\n        out += String.fromCharCode(buf[i]);\n      }\n\n      return out;\n    }\n\n  };\n\n  function decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n\n    do {\n      const semi = indexOf(mappings, index);\n      const line = [];\n      let sorted = true;\n      let lastCol = 0;\n      state[0] = 0;\n\n      for (let i = index; i < semi; i++) {\n        let seg;\n        i = decodeInteger(mappings, i, state, 0); // genColumn\n\n        const col = state[0];\n        if (col < lastCol) sorted = false;\n        lastCol = col;\n\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n\n          i = decodeInteger(mappings, i, state, 2); // sourceLine\n\n          i = decodeInteger(mappings, i, state, 3); // sourceColumn\n\n          if (hasMoreVlq(mappings, i, semi)) {\n            i = decodeInteger(mappings, i, state, 4); // namesIndex\n\n            seg = [col, state[1], state[2], state[3], state[4]];\n          } else {\n            seg = [col, state[1], state[2], state[3]];\n          }\n        } else {\n          seg = [col];\n        }\n\n        line.push(seg);\n      }\n\n      if (!sorted) sort(line);\n      decoded.push(line);\n      index = semi + 1;\n    } while (index <= mappings.length);\n\n    return decoded;\n  }\n\n  function indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n  }\n\n  function decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n\n    do {\n      const c = mappings.charCodeAt(pos++);\n      integer = charToInt[c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n\n    const shouldNegate = value & 1;\n    value >>>= 1;\n\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n\n    state[j] += value;\n    return pos;\n  }\n\n  function hasMoreVlq(mappings, i, length) {\n    if (i >= length) return false;\n    return mappings.charCodeAt(i) !== comma;\n  }\n\n  function sort(line) {\n    line.sort(sortComparator);\n  }\n\n  function sortComparator(a, b) {\n    return a[0] - b[0];\n  }\n\n  function encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n\n      if (i > 0) {\n        if (pos === bufLength) {\n          out += td.decode(buf);\n          pos = 0;\n        }\n\n        buf[pos++] = semicolon;\n      }\n\n      if (line.length === 0) continue;\n      state[0] = 0;\n\n      for (let j = 0; j < line.length; j++) {\n        const segment = line[j]; // We can push up to 5 ints, each int can take at most 7 chars, and we\n        // may push a comma.\n\n        if (pos > subLength) {\n          out += td.decode(sub);\n          buf.copyWithin(0, subLength, pos);\n          pos -= subLength;\n        }\n\n        if (j > 0) buf[pos++] = comma;\n        pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\n        if (segment.length === 1) continue;\n        pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n\n        pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n\n        pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\n        if (segment.length === 4) continue;\n        pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n      }\n    }\n\n    return out + td.decode(buf.subarray(0, pos));\n  }\n\n  function encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n\n    do {\n      let clamped = num & 0b011111;\n      num >>>= 5;\n      if (num > 0) clamped |= 0b100000;\n      buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n\n    return pos;\n  }\n\n  exports.decode = decode;\n  exports.encode = encode;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInt","i","length","c","td","TextDecoder","Buffer","decode","buf","out","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","mappings","state","Int32Array","decoded","index","semi","indexOf","line","sorted","lastCol","seg","decodeInteger","col","hasMoreVlq","push","sort","idx","pos","j","value","shift","integer","shouldNegate","sortComparator","a","b","encode","bufLength","subLength","sub","subarray","segment","copyWithin","encodeInteger","next","num","clamped"],"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts"],"sourcesContent":["export type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array) {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array) {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport function decode(mappings: string): SourceMapMappings {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const decoded: SourceMapMappings = [];\n\n  let index = 0;\n  do {\n    const semi = indexOf(mappings, index);\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    state[0] = 0;\n\n    for (let i = index; i < semi; i++) {\n      let seg: SourceMapSegment;\n\n      i = decodeInteger(mappings, i, state, 0); // genColumn\n      const col = state[0];\n      if (col < lastCol) sorted = false;\n      lastCol = col;\n\n      if (hasMoreVlq(mappings, i, semi)) {\n        i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n        i = decodeInteger(mappings, i, state, 2); // sourceLine\n        i = decodeInteger(mappings, i, state, 3); // sourceColumn\n\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 4); // namesIndex\n          seg = [col, state[1], state[2], state[3], state[4]];\n        } else {\n          seg = [col, state[1], state[2], state[3]];\n        }\n      } else {\n        seg = [col];\n      }\n\n      line.push(seg);\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    index = semi + 1;\n  } while (index <= mappings.length);\n\n  return decoded;\n}\n\nfunction indexOf(mappings: string, index: number): number {\n  const idx = mappings.indexOf(';', index);\n  return idx === -1 ? mappings.length : idx;\n}\n\nfunction decodeInteger(mappings: string, pos: number, state: SourceMapSegment, j: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = mappings.charCodeAt(pos++);\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  state[j] += value;\n  return pos;\n}\n\nfunction hasMoreVlq(mappings: string, i: number, length: number): boolean {\n  if (i >= length) return false;\n  return mappings.charCodeAt(i) !== comma;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const bufLength = 1024 * 16;\n  const subLength = bufLength - 36;\n  const buf = new Uint8Array(bufLength);\n  const sub = buf.subarray(0, subLength);\n  let pos = 0;\n  let out = '';\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) {\n      if (pos === bufLength) {\n        out += td.decode(buf);\n        pos = 0;\n      }\n      buf[pos++] = semicolon;\n    }\n    if (line.length === 0) continue;\n\n    state[0] = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      // We can push up to 5 ints, each int can take at most 7 chars, and we\n      // may push a comma.\n      if (pos > subLength) {\n        out += td.decode(sub);\n        buf.copyWithin(0, subLength, pos);\n        pos -= subLength;\n      }\n      if (j > 0) buf[pos++] = comma;\n\n      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\n      if (segment.length === 1) continue;\n      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\n      if (segment.length === 4) continue;\n      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n    }\n  }\n\n  return out + td.decode(buf.subarray(0, pos));\n}\n\nfunction encodeInteger(\n  buf: Uint8Array,\n  pos: number,\n  state: SourceMapSegment,\n  segment: SourceMapSegment,\n  j: number,\n): number {\n  const next = segment[j];\n  let num = next - state[j];\n  state[j] = next;\n\n  num = num < 0 ? (-num << 1) | 1 : num << 1;\n  do {\n    let clamped = num & 0b011111;\n    num >>>= 5;\n    if (num > 0) clamped |= 0b100000;\n    buf[pos++] = intToChar[clamped];\n  } while (num > 0);\n\n  return pos;\n}\n"]},"metadata":{},"sourceType":"script"}