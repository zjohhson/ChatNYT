{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n\n/** @typedef {import(\"./Resolver\").JsonValue} JsonValue */\n\n/** @typedef {import(\"./Resolver\").ResolveContext} ResolveContext */\n\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/**\n * @typedef {Object} DescriptionFileInfo\n * @property {JsonObject=} content\n * @property {string} path\n * @property {string} directory\n */\n\n/**\n * @callback ErrorFirstCallback\n * @param {Error|null=} error\n * @param {DescriptionFileInfo=} result\n */\n\n/**\n * @typedef {Object} Result\n * @property {string} path path to description file\n * @property {string} directory directory of description file\n * @property {JsonObject} content content of description file\n */\n\n/**\n * @param {Resolver} resolver resolver\n * @param {string} directory directory\n * @param {string[]} filenames filenames\n * @param {DescriptionFileInfo|undefined} oldInfo oldInfo\n * @param {ResolveContext} resolveContext resolveContext\n * @param {ErrorFirstCallback} callback callback\n */\n\n\nfunction loadDescriptionFile(resolver, directory, filenames, oldInfo, resolveContext, callback) {\n  (function findDescriptionFile() {\n    if (oldInfo && oldInfo.directory === directory) {\n      // We already have info for this directory and can reuse it\n      return callback(null, oldInfo);\n    }\n\n    forEachBail(filenames,\n    /**\n     * @param {string} filename filename\n     * @param {(err?: null|Error, result?: null|Result) => void} callback callback\n     * @returns {void}\n     */\n    (filename, callback) => {\n      const descriptionFilePath = resolver.join(directory, filename);\n\n      if (resolver.fileSystem.readJson) {\n        resolver.fileSystem.readJson(descriptionFilePath, (err, content) => {\n          if (err) {\n            if (typeof err.code !== \"undefined\") {\n              if (resolveContext.missingDependencies) {\n                resolveContext.missingDependencies.add(descriptionFilePath);\n              }\n\n              return callback();\n            }\n\n            if (resolveContext.fileDependencies) {\n              resolveContext.fileDependencies.add(descriptionFilePath);\n            }\n\n            return onJson(err);\n          }\n\n          if (resolveContext.fileDependencies) {\n            resolveContext.fileDependencies.add(descriptionFilePath);\n          }\n\n          onJson(null,\n          /** @type {JsonObject} */\n          content);\n        });\n      } else {\n        resolver.fileSystem.readFile(descriptionFilePath, (err, content) => {\n          if (err) {\n            if (resolveContext.missingDependencies) {\n              resolveContext.missingDependencies.add(descriptionFilePath);\n            }\n\n            return callback();\n          }\n\n          if (resolveContext.fileDependencies) {\n            resolveContext.fileDependencies.add(descriptionFilePath);\n          }\n          /** @type {JsonObject | undefined} */\n\n\n          let json;\n\n          if (content) {\n            try {\n              json = JSON.parse(content.toString());\n            } catch (\n            /** @type {unknown} */\n            e) {\n              return onJson(\n              /** @type {Error} */\n              e);\n            }\n          } else {\n            return onJson(new Error(\"No content in file\"));\n          }\n\n          onJson(null, json);\n        });\n      }\n      /**\n       * @param {null|Error} [err] error\n       * @param {JsonObject} [content] content\n       * @returns {void}\n       */\n\n\n      function onJson(err, content) {\n        if (err) {\n          if (resolveContext.log) resolveContext.log(descriptionFilePath + \" (directory description file): \" + err);else err.message = descriptionFilePath + \" (directory description file): \" + err;\n          return callback(err);\n        }\n\n        callback(null, {\n          content:\n          /** @type {JsonObject} */\n          content,\n          directory,\n          path: descriptionFilePath\n        });\n      }\n    },\n    /**\n     * @param {null|Error} [err] error\n     * @param {null|Result} [result] result\n     * @returns {void}\n     */\n    (err, result) => {\n      if (err) return callback(err);\n\n      if (result) {\n        return callback(null, result);\n      } else {\n        const dir = cdUp(directory);\n\n        if (!dir) {\n          return callback();\n        } else {\n          directory = dir;\n          return findDescriptionFile();\n        }\n      }\n    });\n  })();\n}\n/**\n * @param {JsonObject} content content\n * @param {string|string[]} field field\n * @returns {JsonValue | undefined} field data\n */\n\n\nfunction getField(content, field) {\n  if (!content) return undefined;\n\n  if (Array.isArray(field)) {\n    /** @type {JsonValue} */\n    let current = content;\n\n    for (let j = 0; j < field.length; j++) {\n      if (current === null || typeof current !== \"object\") {\n        current = null;\n        break;\n      }\n\n      current =\n      /** @type {JsonObject} */\n      current[field[j]];\n    }\n\n    return current;\n  } else {\n    return content[field];\n  }\n}\n/**\n * @param {string} directory directory\n * @returns {string|null} parent directory or null\n */\n\n\nfunction cdUp(directory) {\n  if (directory === \"/\") return null;\n  const i = directory.lastIndexOf(\"/\"),\n        j = directory.lastIndexOf(\"\\\\\");\n  const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;\n  if (p < 0) return null;\n  return directory.slice(0, p || 1);\n}\n\nexports.loadDescriptionFile = loadDescriptionFile;\nexports.getField = getField;\nexports.cdUp = cdUp;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js"],"names":["forEachBail","require","loadDescriptionFile","resolver","directory","filenames","oldInfo","resolveContext","callback","findDescriptionFile","filename","descriptionFilePath","join","fileSystem","readJson","err","content","code","missingDependencies","add","fileDependencies","onJson","readFile","json","JSON","parse","toString","e","Error","log","message","path","result","dir","cdUp","getField","field","undefined","Array","isArray","current","j","length","i","lastIndexOf","p","slice","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").JsonValue} JsonValue */\n/** @typedef {import(\"./Resolver\").ResolveContext} ResolveContext */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/**\n * @typedef {Object} DescriptionFileInfo\n * @property {JsonObject=} content\n * @property {string} path\n * @property {string} directory\n */\n\n/**\n * @callback ErrorFirstCallback\n * @param {Error|null=} error\n * @param {DescriptionFileInfo=} result\n */\n\n/**\n * @typedef {Object} Result\n * @property {string} path path to description file\n * @property {string} directory directory of description file\n * @property {JsonObject} content content of description file\n */\n\n/**\n * @param {Resolver} resolver resolver\n * @param {string} directory directory\n * @param {string[]} filenames filenames\n * @param {DescriptionFileInfo|undefined} oldInfo oldInfo\n * @param {ResolveContext} resolveContext resolveContext\n * @param {ErrorFirstCallback} callback callback\n */\nfunction loadDescriptionFile(\n\tresolver,\n\tdirectory,\n\tfilenames,\n\toldInfo,\n\tresolveContext,\n\tcallback\n) {\n\t(function findDescriptionFile() {\n\t\tif (oldInfo && oldInfo.directory === directory) {\n\t\t\t// We already have info for this directory and can reuse it\n\t\t\treturn callback(null, oldInfo);\n\t\t}\n\t\tforEachBail(\n\t\t\tfilenames,\n\t\t\t/**\n\t\t\t * @param {string} filename filename\n\t\t\t * @param {(err?: null|Error, result?: null|Result) => void} callback callback\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\t(filename, callback) => {\n\t\t\t\tconst descriptionFilePath = resolver.join(directory, filename);\n\t\t\t\tif (resolver.fileSystem.readJson) {\n\t\t\t\t\tresolver.fileSystem.readJson(descriptionFilePath, (err, content) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (typeof err.code !== \"undefined\") {\n\t\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\t\tresolveContext.missingDependencies.add(descriptionFilePath);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\t\tresolveContext.fileDependencies.add(descriptionFilePath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn onJson(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\tresolveContext.fileDependencies.add(descriptionFilePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonJson(null, /** @type {JsonObject} */ (content));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolver.fileSystem.readFile(descriptionFilePath, (err, content) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\tresolveContext.missingDependencies.add(descriptionFilePath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\tresolveContext.fileDependencies.add(descriptionFilePath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {JsonObject | undefined} */\n\t\t\t\t\t\tlet json;\n\n\t\t\t\t\t\tif (content) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tjson = JSON.parse(content.toString());\n\t\t\t\t\t\t\t} catch (/** @type {unknown} */ e) {\n\t\t\t\t\t\t\t\treturn onJson(/** @type {Error} */ (e));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn onJson(new Error(\"No content in file\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonJson(null, json);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @param {null|Error} [err] error\n\t\t\t\t * @param {JsonObject} [content] content\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tfunction onJson(err, content) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\tdescriptionFilePath + \" (directory description file): \" + err\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terr.message =\n\t\t\t\t\t\t\t\tdescriptionFilePath + \" (directory description file): \" + err;\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\tcontent: /** @type {JsonObject} */ (content),\n\t\t\t\t\t\tdirectory,\n\t\t\t\t\t\tpath: descriptionFilePath\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {null|Error} [err] error\n\t\t\t * @param {null|Result} [result] result\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = cdUp(directory);\n\t\t\t\t\tif (!dir) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdirectory = dir;\n\t\t\t\t\t\treturn findDescriptionFile();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t})();\n}\n\n/**\n * @param {JsonObject} content content\n * @param {string|string[]} field field\n * @returns {JsonValue | undefined} field data\n */\nfunction getField(content, field) {\n\tif (!content) return undefined;\n\tif (Array.isArray(field)) {\n\t\t/** @type {JsonValue} */\n\t\tlet current = content;\n\t\tfor (let j = 0; j < field.length; j++) {\n\t\t\tif (current === null || typeof current !== \"object\") {\n\t\t\t\tcurrent = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = /** @type {JsonObject} */ (current)[field[j]];\n\t\t}\n\t\treturn current;\n\t} else {\n\t\treturn content[field];\n\t}\n}\n\n/**\n * @param {string} directory directory\n * @returns {string|null} parent directory or null\n */\nfunction cdUp(directory) {\n\tif (directory === \"/\") return null;\n\tconst i = directory.lastIndexOf(\"/\"),\n\t\tj = directory.lastIndexOf(\"\\\\\");\n\tconst p = i < 0 ? j : j < 0 ? i : i < j ? j : i;\n\tif (p < 0) return null;\n\treturn directory.slice(0, p || 1);\n}\n\nexports.loadDescriptionFile = loadDescriptionFile;\nexports.getField = getField;\nexports.cdUp = cdUp;\n"]},"metadata":{},"sourceType":"script"}