{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  first\n} = require(\"./util/SetHelpers\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst {\n  compareModulesById,\n  compareIterables,\n  compareModulesByIdentifier,\n  concatComparators,\n  compareSelect,\n  compareIds\n} = require(\"./util/comparators\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst findGraphRoots = require(\"./util/findGraphRoots\");\n\nconst {\n  RuntimeSpecMap,\n  RuntimeSpecSet,\n  runtimeToString,\n  mergeRuntime,\n  forEachRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\n\n\nconst EMPTY_SET = new Set();\nconst ZERO_BIG_INT = BigInt(0);\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n  constructor(hash, renderedHash) {\n    this.hash = hash;\n    this.renderedHash = renderedHash;\n  }\n\n}\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\n\n\nconst getArray = set => {\n  return Array.from(set);\n};\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\n\n\nconst getModuleRuntimes = chunks => {\n  const runtimes = new RuntimeSpecSet();\n\n  for (const chunk of chunks) {\n    runtimes.add(chunk.runtime);\n  }\n\n  return runtimes;\n};\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\n\n\nconst modulesBySourceType = sourceTypesByModule => set => {\n  /** @type {Map<string, SortableSet<Module>>} */\n  const map = new Map();\n\n  for (const module of set) {\n    const sourceTypes = sourceTypesByModule && sourceTypesByModule.get(module) || module.getSourceTypes();\n\n    for (const sourceType of sourceTypes) {\n      let innerSet = map.get(sourceType);\n\n      if (innerSet === undefined) {\n        innerSet = new SortableSet();\n        map.set(sourceType, innerSet);\n      }\n\n      innerSet.add(module);\n    }\n  }\n\n  for (const [key, innerSet] of map) {\n    // When all modules have the source type, we reuse the original SortableSet\n    // to benefit from the shared cache (especially for sorting)\n    if (innerSet.size === set.size) {\n      map.set(key, set);\n    }\n  }\n\n  return map;\n};\n\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n/** @type {WeakMap<Function, any>} */\n\nconst createOrderedArrayFunctionMap = new WeakMap();\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\n\nconst createOrderedArrayFunction = comparator => {\n  /** @type {SetToArrayFunction<T>} */\n  let fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n\n  fn = set => {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\n\n\nconst getModulesSize = modules => {\n  let size = 0;\n\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      size += module.size(type);\n    }\n  }\n\n  return size;\n};\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\n\n\nconst getModulesSizes = modules => {\n  let sizes = Object.create(null);\n\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      sizes[type] = (sizes[type] || 0) + module.size(type);\n    }\n  }\n\n  return sizes;\n};\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\n\n\nconst isAvailableChunk = (a, b) => {\n  const queue = new Set(b.groupsIterable);\n\n  for (const chunkGroup of queue) {\n    if (a.isInGroup(chunkGroup)) continue;\n    if (chunkGroup.isInitial()) return false;\n\n    for (const parent of chunkGroup.parentsIterable) {\n      queue.add(parent);\n    }\n  }\n\n  return true;\n};\n\nclass ChunkGraphModule {\n  constructor() {\n    /** @type {SortableSet<Chunk>} */\n    this.chunks = new SortableSet();\n    /** @type {Set<Chunk> | undefined} */\n\n    this.entryInChunks = undefined;\n    /** @type {Set<Chunk> | undefined} */\n\n    this.runtimeInChunks = undefined;\n    /** @type {RuntimeSpecMap<ModuleHashInfo> | undefined} */\n\n    this.hashes = undefined;\n    /** @type {string | number} */\n\n    this.id = null;\n    /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\n    this.runtimeRequirements = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n\n    this.graphHashes = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n\n    this.graphHashesWithConnections = undefined;\n  }\n\n}\n\nclass ChunkGraphChunk {\n  constructor() {\n    /** @type {SortableSet<Module>} */\n    this.modules = new SortableSet();\n    /** @type {WeakMap<Module, Set<string>> | undefined} */\n\n    this.sourceTypesByModule = undefined;\n    /** @type {Map<Module, Entrypoint>} */\n\n    this.entryModules = new Map();\n    /** @type {SortableSet<RuntimeModule>} */\n\n    this.runtimeModules = new SortableSet();\n    /** @type {Set<RuntimeModule> | undefined} */\n\n    this.fullHashModules = undefined;\n    /** @type {Set<RuntimeModule> | undefined} */\n\n    this.dependentHashModules = undefined;\n    /** @type {Set<string> | undefined} */\n\n    this.runtimeRequirements = undefined;\n    /** @type {Set<string>} */\n\n    this.runtimeRequirementsInTree = new Set();\n    this._modulesBySourceType = defaultModulesBySourceType;\n  }\n\n}\n\nclass ChunkGraph {\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor(moduleGraph) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n  /**\n   * @private\n   * @param {Module} module the module\n   * @returns {ChunkGraphModule} internal module\n   */\n\n\n  _getChunkGraphModule(module) {\n    let cgm = this._modules.get(module);\n\n    if (cgm === undefined) {\n      cgm = new ChunkGraphModule();\n\n      this._modules.set(module, cgm);\n    }\n\n    return cgm;\n  }\n  /**\n   * @private\n   * @param {Chunk} chunk the chunk\n   * @returns {ChunkGraphChunk} internal chunk\n   */\n\n\n  _getChunkGraphChunk(chunk) {\n    let cgc = this._chunks.get(chunk);\n\n    if (cgc === undefined) {\n      cgc = new ChunkGraphChunk();\n\n      this._chunks.set(chunk, cgc);\n    }\n\n    return cgc;\n  }\n  /**\n   * @param {SortableSet<Module>} set the sortable Set to get the roots of\n   * @returns {Module[]} the graph roots\n   */\n\n\n  _getGraphRoots(set) {\n    const {\n      moduleGraph\n    } = this;\n    return Array.from(findGraphRoots(set, module => {\n      /** @type {Set<Module>} */\n      const set = new Set();\n\n      const addDependencies = module => {\n        for (const connection of moduleGraph.getOutgoingConnections(module)) {\n          if (!connection.module) continue;\n          const activeState = connection.getActiveState(undefined);\n          if (activeState === false) continue;\n\n          if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n            addDependencies(connection.module);\n            continue;\n          }\n\n          set.add(connection.module);\n        }\n      };\n\n      addDependencies(module);\n      return set;\n    })).sort(compareModulesByIdentifier);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  connectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.chunks.add(chunk);\n    cgc.modules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgc.modules.delete(module); // No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n\n    if (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n    cgm.chunks.delete(chunk);\n  }\n  /**\n   * @param {Chunk} chunk the chunk which will be disconnected\n   * @returns {void}\n   */\n\n\n  disconnectChunk(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of cgc.modules) {\n      const cgm = this._getChunkGraphModule(module);\n\n      cgm.chunks.delete(chunk);\n    }\n\n    cgc.modules.clear();\n    chunk.disconnectFromGroups();\n    ChunkGraph.clearChunkGraphForChunk(chunk);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<Module>} modules the modules\n   * @returns {void}\n   */\n\n\n  attachModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of modules) {\n      cgc.modules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the runtime modules\n   * @returns {void}\n   */\n\n\n  attachRuntimeModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of modules) {\n      cgc.runtimeModules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n\n\n  attachFullHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\n    for (const module of modules) {\n      cgc.fullHashModules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n\n\n  attachDependentHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n\n    for (const module of modules) {\n      cgc.dependentHashModules.add(module);\n    }\n  }\n  /**\n   * @param {Module} oldModule the replaced module\n   * @param {Module} newModule the replacing module\n   * @returns {void}\n   */\n\n\n  replaceModule(oldModule, newModule) {\n    const oldCgm = this._getChunkGraphModule(oldModule);\n\n    const newCgm = this._getChunkGraphModule(newModule);\n\n    for (const chunk of oldCgm.chunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.modules.delete(oldModule);\n      cgc.modules.add(newModule);\n      newCgm.chunks.add(chunk);\n    }\n\n    oldCgm.chunks.clear();\n\n    if (oldCgm.entryInChunks !== undefined) {\n      if (newCgm.entryInChunks === undefined) {\n        newCgm.entryInChunks = new Set();\n      }\n\n      for (const chunk of oldCgm.entryInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n\n        const old = cgc.entryModules.get(oldModule);\n        /** @type {Map<Module, Entrypoint>} */\n\n        const newEntryModules = new Map();\n\n        for (const [m, cg] of cgc.entryModules) {\n          if (m === oldModule) {\n            newEntryModules.set(newModule, old);\n          } else {\n            newEntryModules.set(m, cg);\n          }\n        }\n\n        cgc.entryModules = newEntryModules;\n        newCgm.entryInChunks.add(chunk);\n      }\n\n      oldCgm.entryInChunks = undefined;\n    }\n\n    if (oldCgm.runtimeInChunks !== undefined) {\n      if (newCgm.runtimeInChunks === undefined) {\n        newCgm.runtimeInChunks = new Set();\n      }\n\n      for (const chunk of oldCgm.runtimeInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n\n        cgc.runtimeModules.delete(\n        /** @type {RuntimeModule} */\n        oldModule);\n        cgc.runtimeModules.add(\n        /** @type {RuntimeModule} */\n        newModule);\n        newCgm.runtimeInChunks.add(chunk);\n\n        if (cgc.fullHashModules !== undefined && cgc.fullHashModules.has(\n        /** @type {RuntimeModule} */\n        oldModule)) {\n          cgc.fullHashModules.delete(\n          /** @type {RuntimeModule} */\n          oldModule);\n          cgc.fullHashModules.add(\n          /** @type {RuntimeModule} */\n          newModule);\n        }\n\n        if (cgc.dependentHashModules !== undefined && cgc.dependentHashModules.has(\n        /** @type {RuntimeModule} */\n        oldModule)) {\n          cgc.dependentHashModules.delete(\n          /** @type {RuntimeModule} */\n          oldModule);\n          cgc.dependentHashModules.add(\n          /** @type {RuntimeModule} */\n          newModule);\n        }\n      }\n\n      oldCgm.runtimeInChunks = undefined;\n    }\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  isModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.has(module);\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {ChunkGroup} chunkGroup the checked chunk group\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  isModuleInChunkGroup(module, chunkGroup) {\n    for (const chunk of chunkGroup.chunks) {\n      if (this.isModuleInChunk(module, chunk)) return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Module} module the checked module\n   * @returns {boolean} true, if the module is entry of any chunk\n   */\n\n\n  isEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.entryInChunks !== undefined;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n\n\n  getModuleChunksIterable(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n\n\n  getOrderedModuleChunksIterable(module, sortFn) {\n    const cgm = this._getChunkGraphModule(module);\n\n    cgm.chunks.sortWith(sortFn);\n    return cgm.chunks;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {Chunk[]} array of chunks (cached, do not modify)\n   */\n\n\n  getModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.getFromCache(getArray);\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {number} the number of chunk which contain the module\n   */\n\n\n  getNumberOfModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.size;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {RuntimeSpecSet} runtimes\n   */\n\n\n  getModuleRuntimes(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of modules which are contained in this chunk\n   */\n\n\n  getNumberOfChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of full hash modules which are contained in this chunk\n   */\n\n\n  getNumberOfChunkFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n\n\n  getChunkModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n\n\n  getChunkModulesIterableBySourceType(chunk, sourceType) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    return modulesWithSourceType;\n  }\n  /**\n   * @param {Chunk} chunk chunk\n   * @param {Module} module chunk module\n   * @param {Set<string>} sourceTypes source types\n   */\n\n\n  setChunkModuleSourceTypes(chunk, module, sourceTypes) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.sourceTypesByModule === undefined) {\n      cgc.sourceTypesByModule = new WeakMap();\n    }\n\n    cgc.sourceTypesByModule.set(module, sourceTypes); // Update cgc._modulesBySourceType to invalidate the cache\n\n    cgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n  }\n  /**\n   * @param {Chunk} chunk chunk\n   * @param {Module} module chunk module\n   * @returns {Set<string>} source types\n   */\n\n\n  getChunkModuleSourceTypes(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.sourceTypesByModule === undefined) {\n      return module.getSourceTypes();\n    }\n\n    return cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n  }\n  /**\n   * @param {Module} module module\n   * @returns {Set<string>} source types\n   */\n\n\n  getModuleSourceTypes(module) {\n    return this._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes();\n  }\n  /**\n   * @param {Module} module module\n   * @returns {Set<string> | undefined} source types\n   */\n\n\n  _getOverwrittenModuleSourceTypes(module) {\n    let newSet = false;\n    let sourceTypes;\n\n    for (const chunk of this.getModuleChunksIterable(module)) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.sourceTypesByModule === undefined) return;\n      const st = cgc.sourceTypesByModule.get(module);\n      if (st === undefined) return;\n\n      if (!sourceTypes) {\n        sourceTypes = st;\n        continue;\n      } else if (!newSet) {\n        for (const type of st) {\n          if (!newSet) {\n            if (!sourceTypes.has(type)) {\n              newSet = true;\n              sourceTypes = new Set(sourceTypes);\n              sourceTypes.add(type);\n            }\n          } else {\n            sourceTypes.add(type);\n          }\n        }\n      } else {\n        for (const type of st) sourceTypes.add(type);\n      }\n    }\n\n    return sourceTypes;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n\n\n  getOrderedChunkModulesIterable(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgc.modules.sortWith(comparator);\n    return cgc.modules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n\n\n  getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    if (modulesWithSourceType === undefined) return undefined;\n    modulesWithSourceType.sortWith(comparator);\n    return modulesWithSourceType;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n\n\n  getChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getArray);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n\n\n  getOrderedChunkModules(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const arrayFunction = createOrderedArrayFunction(comparator);\n    return cgc.modules.getFromUnorderedCache(arrayFunction);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n   */\n\n\n  getChunkModuleIdMap(chunk, filterFn) {\n    let includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n\n          const moduleId = this.getModuleId(module);\n          array.push(moduleId);\n        }\n      }\n    }\n\n    return chunkModuleIdMap;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {number} hashLength length of the hash\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n   */\n\n\n  getChunkModuleRenderedHashMap(chunk, filterFn) {\n    let hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    /** @type {Record<string|number, Record<string|number, string>>} */\n    const chunkModuleHashMap = Object.create(null);\n\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {Record<string|number, string>} */\n      let idToHashMap;\n\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (idToHashMap === undefined) {\n            idToHashMap = Object.create(null);\n            chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n          }\n\n          const moduleId = this.getModuleId(module);\n          const hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n          idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n        }\n      }\n    }\n\n    return chunkModuleHashMap;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n   * @returns {Record<string|number, boolean>} chunk map\n   */\n\n\n  getChunkConditionMap(chunk, filterFn) {\n    const map = Object.create(null);\n\n    for (const c of chunk.getAllReferencedChunks()) {\n      map[c.id] = filterFn(c, this);\n    }\n\n    return map;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n\n\n  hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n    const queue = new Set(chunk.groupsIterable);\n    const chunksProcessed = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const innerChunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(innerChunk)) {\n          chunksProcessed.add(innerChunk);\n\n          if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n            for (const module of this.getChunkModulesIterable(innerChunk)) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Chunk} chunkA first chunk\n   * @param {Chunk} chunkB second chunk\n   * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n   */\n\n\n  compareChunks(chunkA, chunkB) {\n    const cgcA = this._getChunkGraphChunk(chunkA);\n\n    const cgcB = this._getChunkGraphChunk(chunkB);\n\n    if (cgcA.modules.size > cgcB.modules.size) return -1;\n    if (cgcA.modules.size < cgcB.modules.size) return 1;\n    cgcA.modules.sortWith(compareModulesByIdentifier);\n    cgcB.modules.sortWith(compareModulesByIdentifier);\n    return compareModuleIterables(cgcA.modules, cgcB.modules);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} total size of all modules in the chunk\n   */\n\n\n  getChunkModulesSize(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getModulesSize);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n   */\n\n\n  getChunkModulesSizes(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getModulesSizes);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} root modules of the chunks (ordered by identifier)\n   */\n\n\n  getChunkRootModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk\n   */\n\n\n  getChunkSize(chunk) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if chunks can't be integrated\n   */\n\n\n  getIntegratedChunksSize(chunkA, chunkB) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    const cgcA = this._getChunkGraphChunk(chunkA);\n\n    const cgcB = this._getChunkGraphChunk(chunkB);\n\n    const allModules = new Set(cgcA.modules);\n\n    for (const m of cgcB.modules) allModules.add(m);\n\n    let modulesSize = getModulesSize(allModules);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n\n\n  canChunksBeIntegrated(chunkA, chunkB) {\n    if (chunkA.preventIntegration || chunkB.preventIntegration) {\n      return false;\n    }\n\n    const hasRuntimeA = chunkA.hasRuntime();\n    const hasRuntimeB = chunkB.hasRuntime();\n\n    if (hasRuntimeA !== hasRuntimeB) {\n      if (hasRuntimeA) {\n        return isAvailableChunk(chunkA, chunkB);\n      } else if (hasRuntimeB) {\n        return isAvailableChunk(chunkB, chunkA);\n      } else {\n        return false;\n      }\n    }\n\n    if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @param {Chunk} chunkA the target chunk\n   * @param {Chunk} chunkB the chunk to integrate\n   * @returns {void}\n   */\n\n\n  integrateChunks(chunkA, chunkB) {\n    // Decide for one name (deterministic)\n    if (chunkA.name && chunkB.name) {\n      if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (chunkA.name.length !== chunkB.name.length) {\n          chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n        } else {\n          chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n        }\n      } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n        // Pick the name of the chunk with the entry module\n        chunkA.name = chunkB.name;\n      }\n    } else if (chunkB.name) {\n      chunkA.name = chunkB.name;\n    } // Merge id name hints\n\n\n    for (const hint of chunkB.idNameHints) {\n      chunkA.idNameHints.add(hint);\n    } // Merge runtime\n\n\n    chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime); // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\n    for (const module of this.getChunkModules(chunkB)) {\n      this.disconnectChunkAndModule(chunkB, module);\n      this.connectChunkAndModule(chunkA, module);\n    }\n\n    for (const [module, chunkGroup] of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB))) {\n      this.disconnectChunkAndEntryModule(chunkB, module);\n      this.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n    }\n\n    for (const chunkGroup of chunkB.groupsIterable) {\n      chunkGroup.replaceChunk(chunkB, chunkA);\n      chunkA.addGroup(chunkGroup);\n      chunkB.removeGroup(chunkGroup);\n    }\n\n    ChunkGraph.clearChunkGraphForChunk(chunkB);\n  }\n  /**\n   * @param {Chunk} chunk the chunk to upgrade\n   * @returns {void}\n   */\n\n\n  upgradeDependentToFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) return;\n\n    if (cgc.fullHashModules === undefined) {\n      cgc.fullHashModules = cgc.dependentHashModules;\n    } else {\n      for (const m of cgc.dependentHashModules) {\n        cgc.fullHashModules.add(m);\n      }\n\n      cgc.dependentHashModules = undefined;\n    }\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module as entry\n   */\n\n\n  isEntryModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.has(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n   * @returns {void}\n   */\n\n\n  connectChunkAndEntryModule(chunk, module, entrypoint) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgm.entryInChunks === undefined) {\n      cgm.entryInChunks = new Set();\n    }\n\n    cgm.entryInChunks.add(chunk);\n    cgc.entryModules.set(module, entrypoint);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n\n\n  connectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgm.runtimeInChunks === undefined) {\n      cgm.runtimeInChunks = new Set();\n    }\n\n    cgm.runtimeInChunks.add(chunk);\n    cgc.runtimeModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n\n\n  addFullHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    cgc.fullHashModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n\n\n  addDependentHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    cgc.dependentHashModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndEntryModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.entryInChunks.delete(chunk);\n\n    if (cgm.entryInChunks.size === 0) {\n      cgm.entryInChunks = undefined;\n    }\n\n    cgc.entryModules.delete(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.runtimeInChunks.delete(chunk);\n\n    if (cgm.runtimeInChunks.size === 0) {\n      cgm.runtimeInChunks = undefined;\n    }\n\n    cgc.runtimeModules.delete(module);\n  }\n  /**\n   * @param {Module} module the entry module, it will no longer be entry\n   * @returns {void}\n   */\n\n\n  disconnectEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    for (const chunk of cgm.entryInChunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.entryModules.delete(module);\n    }\n\n    cgm.entryInChunks = undefined;\n  }\n  /**\n   * @param {Chunk} chunk the chunk, for which all entries will be removed\n   * @returns {void}\n   */\n\n\n  disconnectEntries(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of cgc.entryModules.keys()) {\n      const cgm = this._getChunkGraphModule(module);\n\n      cgm.entryInChunks.delete(chunk);\n\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n    }\n\n    cgc.entryModules.clear();\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n\n\n  getNumberOfEntryModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n\n\n  getNumberOfRuntimeModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} iterable of modules (do not modify)\n   */\n\n\n  getChunkEntryModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.keys();\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Chunk>} iterable of chunks\n   */\n\n\n  getChunkEntryDependentChunksIterable(chunk) {\n    /** @type {Set<Chunk>} */\n    const set = new Set();\n\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup instanceof Entrypoint) {\n        const entrypointChunk = chunkGroup.getEntrypointChunk();\n\n        const cgc = this._getChunkGraphChunk(entrypointChunk);\n\n        for (const chunkGroup of cgc.entryModules.values()) {\n          for (const c of chunkGroup.chunks) {\n            if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n              set.add(c);\n            }\n          }\n        }\n      }\n    }\n\n    return set;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {boolean} true, when it has dependent chunks\n   */\n\n\n  hasChunkEntryDependentChunks(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const chunkGroup of cgc.entryModules.values()) {\n      for (const c of chunkGroup.chunks) {\n        if (c !== chunk) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n   */\n\n\n  getChunkRuntimeModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {RuntimeModule[]} array of modules in order of execution\n   */\n\n\n  getChunkRuntimeModulesInOrder(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const array = Array.from(cgc.runtimeModules);\n    array.sort(concatComparators(compareSelect(\n    /**\n     * @param {RuntimeModule} r runtime module\n     * @returns {number=} stage\n     */\n    r => r.stage, compareIds), compareModulesByIdentifier));\n    return array;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n\n\n  getChunkFullHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n   */\n\n\n  getChunkFullHashModulesSet(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n\n\n  getChunkDependentHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.dependentHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n   */\n\n\n  getChunkEntryModulesWithChunkGroupIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules;\n  }\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @returns {ChunkGroup} the chunk group\n   */\n\n\n  getBlockChunkGroup(depBlock) {\n    return this._blockChunkGroups.get(depBlock);\n  }\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n\n\n  connectBlockAndChunkGroup(depBlock, chunkGroup) {\n    this._blockChunkGroups.set(depBlock, chunkGroup);\n\n    chunkGroup.addBlock(depBlock);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n\n\n  disconnectChunkGroup(chunkGroup) {\n    for (const block of chunkGroup.blocksIterable) {\n      this._blockChunkGroups.delete(block);\n    } // TODO refactor by moving blocks list into ChunkGraph\n\n\n    chunkGroup._blocks.clear();\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {string | number} the id of the module\n   */\n\n\n  getModuleId(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.id;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {string | number} id the id of the module\n   * @returns {void}\n   */\n\n\n  setModuleId(module, id) {\n    const cgm = this._getChunkGraphModule(module);\n\n    cgm.id = id;\n  }\n  /**\n   * @param {string} runtime runtime\n   * @returns {string | number} the id of the runtime\n   */\n\n\n  getRuntimeId(runtime) {\n    return this._runtimeIds.get(runtime);\n  }\n  /**\n   * @param {string} runtime runtime\n   * @param {string | number} id the id of the runtime\n   * @returns {void}\n   */\n\n\n  setRuntimeId(runtime, id) {\n    this._runtimeIds.set(runtime, id);\n  }\n  /**\n   * @template T\n   * @param {Module} module the module\n   * @param {RuntimeSpecMap<T>} hashes hashes data\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {T} hash\n   */\n\n\n  _getModuleHashInfo(module, hashes, runtime) {\n    if (!hashes) {\n      throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (hashes not set at all)`);\n    } else if (runtime === undefined) {\n      const hashInfoItems = new Set(hashes.values());\n\n      if (hashInfoItems.size !== 1) {\n        throw new Error(`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(hashes.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n      }\n\n      return first(hashInfoItems);\n    } else {\n      const hashInfo = hashes.get(runtime);\n\n      if (!hashInfo) {\n        throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (available runtimes ${Array.from(hashes.keys(), runtimeToString).join(\", \")})`);\n      }\n\n      return hashInfo;\n    }\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, if the module has hashes for this runtime\n   */\n\n\n  hasModuleHashes(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes =\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n    cgm.hashes;\n    return hashes && hashes.has(runtime);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  getModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes =\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n    cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).hash;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  getRenderedModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes =\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n    cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {string} hash the full hash\n   * @param {string} renderedHash the shortened hash for rendering\n   * @returns {void}\n   */\n\n\n  setModuleHashes(module, runtime, hash, renderedHash) {\n    const cgm = this._getChunkGraphModule(module);\n\n    if (cgm.hashes === undefined) {\n      cgm.hashes = new RuntimeSpecMap();\n    }\n\n    cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n   * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n   * @returns {void}\n   */\n\n\n  addModuleRuntimeRequirements(module, runtime, items) {\n    let transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    const runtimeRequirementsMap = cgm.runtimeRequirements;\n\n    if (runtimeRequirementsMap === undefined) {\n      const map = new RuntimeSpecMap(); // TODO avoid cloning item and track ownership instead\n\n      map.set(runtime, transferOwnership ? items : new Set(items));\n      cgm.runtimeRequirements = map;\n      return;\n    }\n\n    runtimeRequirementsMap.update(runtime, runtimeRequirements => {\n      if (runtimeRequirements === undefined) {\n        return transferOwnership ? items : new Set(items);\n      } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n        for (const item of items) runtimeRequirements.add(item);\n\n        return runtimeRequirements;\n      } else {\n        for (const item of runtimeRequirements) items.add(item);\n\n        return items;\n      }\n    });\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n   * @returns {void}\n   */\n\n\n  addChunkRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirements;\n\n    if (runtimeRequirements === undefined) {\n      cgc.runtimeRequirements = items;\n    } else if (runtimeRequirements.size >= items.size) {\n      for (const item of items) runtimeRequirements.add(item);\n    } else {\n      for (const item of runtimeRequirements) items.add(item);\n\n      cgc.runtimeRequirements = items;\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<string>} items runtime requirements to be added\n   * @returns {void}\n   */\n\n\n  addTreeRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirementsInTree;\n\n    for (const item of items) runtimeRequirements.add(item);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getModuleRuntimeRequirements(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getChunkRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirements;\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {string} hash\n   */\n\n\n  getModuleGraphHash(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {bigint} hash\n   */\n\n\n  getModuleGraphHashBigInt(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    return withConnections ? BigInt(`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n  }\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {bigint} hash as big int\n   */\n\n\n  _getModuleGraphHashBigInt(cgm, module, runtime) {\n    if (cgm.graphHashes === undefined) {\n      cgm.graphHashes = new RuntimeSpecMap();\n    }\n\n    const graphHash = cgm.graphHashes.provide(runtime, () => {\n      const hash = createHash(this._hashFunction);\n      hash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\n      const sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n\n      if (sourceTypes !== undefined) {\n        for (const type of sourceTypes) hash.update(type);\n      }\n\n      this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n      return BigInt(`0x${\n      /** @type {string} */\n      hash.digest(\"hex\")}`);\n    });\n    return graphHash;\n  }\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  _getModuleGraphHashWithConnections(cgm, module, runtime) {\n    if (cgm.graphHashesWithConnections === undefined) {\n      cgm.graphHashesWithConnections = new RuntimeSpecMap();\n    }\n\n    const activeStateToString = state => {\n      if (state === false) return \"F\";\n      if (state === true) return \"T\";\n      if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n      throw new Error(\"Not implemented active state\");\n    };\n\n    const strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n    return cgm.graphHashesWithConnections.provide(runtime, () => {\n      const graphHash = this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\n      const connections = this.moduleGraph.getOutgoingConnections(module);\n      /** @type {Set<Module>} */\n\n      const activeNamespaceModules = new Set();\n      /** @type {Map<string, Module | Set<Module>>} */\n\n      const connectedModules = new Map();\n\n      const processConnection = (connection, stateInfo) => {\n        const module = connection.module;\n        stateInfo += module.getExportsType(this.moduleGraph, strict); // cspell:word Tnamespace\n\n        if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n          const oldModule = connectedModules.get(stateInfo);\n\n          if (oldModule === undefined) {\n            connectedModules.set(stateInfo, module);\n          } else if (oldModule instanceof Set) {\n            oldModule.add(module);\n          } else if (oldModule !== module) {\n            connectedModules.set(stateInfo, new Set([oldModule, module]));\n          }\n        }\n      };\n\n      if (runtime === undefined || typeof runtime === \"string\") {\n        for (const connection of connections) {\n          const state = connection.getActiveState(runtime);\n          if (state === false) continue;\n          processConnection(connection, state === true ? \"T\" : \"O\");\n        }\n      } else {\n        // cspell:word Tnamespace\n        for (const connection of connections) {\n          const states = new Set();\n          let stateInfo = \"\";\n          forEachRuntime(runtime, runtime => {\n            const state = connection.getActiveState(runtime);\n            states.add(state);\n            stateInfo += activeStateToString(state) + runtime;\n          }, true);\n\n          if (states.size === 1) {\n            const state = first(states);\n            if (state === false) continue;\n            stateInfo = activeStateToString(state);\n          }\n\n          processConnection(connection, stateInfo);\n        }\n      } // cspell:word Tnamespace\n\n\n      if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n      const connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort((_ref, _ref2) => {\n        let [a] = _ref;\n        let [b] = _ref2;\n        return a < b ? -1 : 1;\n      }) : connectedModules;\n      const hash = createHash(this._hashFunction);\n\n      const addModuleToHash = module => {\n        hash.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(module), module, runtime).toString(16));\n      };\n\n      const addModulesToHash = modules => {\n        let xor = ZERO_BIG_INT;\n\n        for (const m of modules) {\n          xor = xor ^ this._getModuleGraphHashBigInt(this._getChunkGraphModule(m), m, runtime);\n        }\n\n        hash.update(xor.toString(16));\n      };\n\n      if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n\n      for (const [stateInfo, modules] of connectedModulesInOrder) {\n        hash.update(stateInfo);\n\n        if (modules instanceof Set) {\n          addModulesToHash(modules);\n        } else {\n          addModuleToHash(modules);\n        }\n      }\n\n      hash.update(graphHash);\n      return (\n        /** @type {string} */\n        hash.digest(\"hex\")\n      );\n    });\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getTreeRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeRequirementsInTree;\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n\n\n  static getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n    if (fn) return fn(module);\n    const newFn = util.deprecate(\n    /**\n     * @param {Module} module the module\n     * @returns {ChunkGraph} the chunk graph\n     */\n    module => {\n      const chunkGraph = chunkGraphForModuleMap.get(module);\n      if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n    return newFn(module);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  static setChunkGraphForModule(module, chunkGraph) {\n    chunkGraphForModuleMap.set(module, chunkGraph);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  static clearChunkGraphForModule(module) {\n    chunkGraphForModuleMap.delete(module);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n\n\n  static getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n    if (fn) return fn(chunk);\n    const newFn = util.deprecate(\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ChunkGraph} the chunk graph\n     */\n    chunk => {\n      const chunkGraph = chunkGraphForChunkMap.get(chunk);\n      if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n    return newFn(chunk);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  static setChunkGraphForChunk(chunk, chunkGraph) {\n    chunkGraphForChunkMap.set(chunk, chunkGraph);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {void}\n   */\n\n\n  static clearChunkGraphForChunk(chunk) {\n    chunkGraphForChunkMap.delete(chunk);\n  }\n\n} // TODO remove in webpack 6\n\n/** @type {WeakMap<Module, ChunkGraph>} */\n\n\nconst chunkGraphForModuleMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {WeakMap<Chunk, ChunkGraph>} */\n\nconst chunkGraphForChunkMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\n\nconst deprecateGetChunkGraphForModuleMap = new Map(); // TODO remove in webpack 6\n\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\n\nconst deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/ChunkGraph.js"],"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","constructor","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","sourceTypesByModule","map","Map","module","sourceTypes","get","getSourceTypes","sourceType","innerSet","undefined","key","size","defaultModulesBySourceType","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parent","parentsIterable","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","_modulesBySourceType","ChunkGraph","moduleGraph","hashFunction","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","_getChunkGraphModule","cgm","_getChunkGraphChunk","cgc","addDependencies","connection","getOutgoingConnections","activeState","getActiveState","TRANSITIVE_ONLY","sort","connectChunkAndModule","disconnectChunkAndModule","delete","disconnectChunk","clear","disconnectFromGroups","clearChunkGraphForChunk","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","replaceModule","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","isModuleInChunkGroup","isEntryModule","getModuleChunksIterable","getOrderedModuleChunksIterable","sortFn","getModuleChunks","getFromCache","getNumberOfModuleChunks","getFromUnorderedCache","getNumberOfChunkModules","getNumberOfChunkFullHashModules","getChunkModulesIterable","getChunkModulesIterableBySourceType","modulesWithSourceType","setChunkModuleSourceTypes","getChunkModuleSourceTypes","getModuleSourceTypes","_getOverwrittenModuleSourceTypes","newSet","st","getOrderedChunkModulesIterable","getOrderedChunkModulesIterableBySourceType","getChunkModules","getOrderedChunkModules","arrayFunction","getChunkModuleIdMap","filterFn","includeAllChunks","chunkModuleIdMap","asyncChunk","getAllReferencedChunks","getAllAsyncChunks","array","moduleId","getModuleId","push","getChunkModuleRenderedHashMap","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","getChunkConditionMap","c","hasModuleInGraph","filterChunkFn","chunksProcessed","innerChunk","child","childrenIterable","compareChunks","chunkA","chunkB","cgcA","cgcB","getChunkModulesSize","getChunkModulesSizes","getChunkRootModules","getChunkSize","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","getIntegratedChunksSize","allModules","canChunksBeIntegrated","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","integrateChunks","name","length","hint","idNameHints","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","upgradeDependentToFullHashModules","isEntryModuleInChunk","entrypoint","connectChunkAndRuntimeModule","addFullHashModuleToChunk","addDependentHashModuleToChunk","disconnectChunkAndRuntimeModule","disconnectEntryModule","disconnectEntries","keys","getNumberOfRuntimeModules","getChunkEntryModulesIterable","getChunkEntryDependentChunksIterable","entrypointChunk","getEntrypointChunk","values","hasChunkEntryDependentChunks","getChunkRuntimeModulesIterable","getChunkRuntimeModulesInOrder","r","stage","getChunkFullHashModulesIterable","getChunkFullHashModulesSet","getChunkDependentHashModulesIterable","getBlockChunkGroup","depBlock","connectBlockAndChunkGroup","addBlock","disconnectChunkGroup","block","blocksIterable","_blocks","setModuleId","getRuntimeId","setRuntimeId","_getModuleHashInfo","Error","identifier","hashInfoItems","join","hashInfo","hasModuleHashes","getModuleHash","setModuleHashes","addModuleRuntimeRequirements","items","transferOwnership","runtimeRequirementsMap","update","item","addChunkRuntimeRequirements","addTreeRuntimeRequirements","getModuleRuntimeRequirements","getChunkRuntimeRequirements","getModuleGraphHash","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","getModuleGraphHashBigInt","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","addModuleToHash","addModulesToHash","xor","next","value","getTreeRuntimeRequirements","getChunkGraphForModule","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","setChunkGraphForModule","clearChunkGraphForModule","getChunkGraphForChunk","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","setChunkGraphForChunk","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { first } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareModulesById,\n\tcompareIterables,\n\tcompareModulesByIdentifier,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n\tRuntimeSpecMap,\n\tRuntimeSpecSet,\n\truntimeToString,\n\tmergeRuntime,\n\tforEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\n\nconst ZERO_BIG_INT = BigInt(0);\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n\tconstructor(hash, renderedHash) {\n\t\tthis.hash = hash;\n\t\tthis.renderedHash = renderedHash;\n\t}\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n\treturn Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n\tconst runtimes = new RuntimeSpecSet();\n\tfor (const chunk of chunks) {\n\t\truntimes.add(chunk.runtime);\n\t}\n\treturn runtimes;\n};\n\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = sourceTypesByModule => set => {\n\t/** @type {Map<string, SortableSet<Module>>} */\n\tconst map = new Map();\n\tfor (const module of set) {\n\t\tconst sourceTypes =\n\t\t\t(sourceTypesByModule && sourceTypesByModule.get(module)) ||\n\t\t\tmodule.getSourceTypes();\n\t\tfor (const sourceType of sourceTypes) {\n\t\t\tlet innerSet = map.get(sourceType);\n\t\t\tif (innerSet === undefined) {\n\t\t\t\tinnerSet = new SortableSet();\n\t\t\t\tmap.set(sourceType, innerSet);\n\t\t\t}\n\t\t\tinnerSet.add(module);\n\t\t}\n\t}\n\tfor (const [key, innerSet] of map) {\n\t\t// When all modules have the source type, we reuse the original SortableSet\n\t\t// to benefit from the shared cache (especially for sorting)\n\t\tif (innerSet.size === set.size) {\n\t\t\tmap.set(key, set);\n\t\t}\n\t}\n\treturn map;\n};\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n\t/** @type {SetToArrayFunction<T>} */\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\n\tif (fn !== undefined) return fn;\n\tfn = set => {\n\t\tset.sortWith(comparator);\n\t\treturn Array.from(set);\n\t};\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\n\treturn fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n\tlet size = 0;\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t}\n\treturn size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n\tlet sizes = Object.create(null);\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\n\t\t}\n\t}\n\treturn sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n\tconst queue = new Set(b.groupsIterable);\n\tfor (const chunkGroup of queue) {\n\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\tif (chunkGroup.isInitial()) return false;\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tqueue.add(parent);\n\t\t}\n\t}\n\treturn true;\n};\n\nclass ChunkGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<Chunk>} */\n\t\tthis.chunks = new SortableSet();\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.entryInChunks = undefined;\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.runtimeInChunks = undefined;\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo> | undefined} */\n\t\tthis.hashes = undefined;\n\t\t/** @type {string | number} */\n\t\tthis.id = null;\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashes = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashesWithConnections = undefined;\n\t}\n}\n\nclass ChunkGraphChunk {\n\tconstructor() {\n\t\t/** @type {SortableSet<Module>} */\n\t\tthis.modules = new SortableSet();\n\t\t/** @type {WeakMap<Module, Set<string>> | undefined} */\n\t\tthis.sourceTypesByModule = undefined;\n\t\t/** @type {Map<Module, Entrypoint>} */\n\t\tthis.entryModules = new Map();\n\t\t/** @type {SortableSet<RuntimeModule>} */\n\t\tthis.runtimeModules = new SortableSet();\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.fullHashModules = undefined;\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.dependentHashModules = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.runtimeRequirementsInTree = new Set();\n\n\t\tthis._modulesBySourceType = defaultModulesBySourceType;\n\t}\n}\n\nclass ChunkGraph {\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\n\t\tthis._modules = new WeakMap();\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\t\tthis._chunks = new WeakMap();\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\t\tthis._blockChunkGroups = new WeakMap();\n\t\t/** @private @type {Map<string, string | number>} */\n\t\tthis._runtimeIds = new Map();\n\t\t/** @type {ModuleGraph} */\n\t\tthis.moduleGraph = moduleGraph;\n\n\t\tthis._hashFunction = hashFunction;\n\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} module the module\n\t * @returns {ChunkGraphModule} internal module\n\t */\n\t_getChunkGraphModule(module) {\n\t\tlet cgm = this._modules.get(module);\n\t\tif (cgm === undefined) {\n\t\t\tcgm = new ChunkGraphModule();\n\t\t\tthis._modules.set(module, cgm);\n\t\t}\n\t\treturn cgm;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ChunkGraphChunk} internal chunk\n\t */\n\t_getChunkGraphChunk(chunk) {\n\t\tlet cgc = this._chunks.get(chunk);\n\t\tif (cgc === undefined) {\n\t\t\tcgc = new ChunkGraphChunk();\n\t\t\tthis._chunks.set(chunk, cgc);\n\t\t}\n\t\treturn cgc;\n\t}\n\n\t/**\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\n\t * @returns {Module[]} the graph roots\n\t */\n\t_getGraphRoots(set) {\n\t\tconst { moduleGraph } = this;\n\t\treturn Array.from(\n\t\t\tfindGraphRoots(set, module => {\n\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\tconst set = new Set();\n\t\t\t\tconst addDependencies = module => {\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\t\t\t\t\tif (!connection.module) continue;\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\n\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\taddDependencies(connection.module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(connection.module);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddDependencies(module);\n\t\t\t\treturn set;\n\t\t\t})\n\t\t).sort(compareModulesByIdentifier);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.chunks.add(chunk);\n\t\tcgc.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.delete(module);\n\t\t// No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n\t\tif (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n\t\tcgm.chunks.delete(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk which will be disconnected\n\t * @returns {void}\n\t */\n\tdisconnectChunk(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.modules) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.chunks.delete(chunk);\n\t\t}\n\t\tcgc.modules.clear();\n\t\tchunk.disconnectFromGroups();\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<Module>} modules the modules\n\t * @returns {void}\n\t */\n\tattachModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.modules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\n\t * @returns {void}\n\t */\n\tattachRuntimeModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.runtimeModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachFullHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.fullHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachDependentHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.dependentHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the replaced module\n\t * @param {Module} newModule the replacing module\n\t * @returns {void}\n\t */\n\treplaceModule(oldModule, newModule) {\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\n\n\t\tfor (const chunk of oldCgm.chunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.modules.delete(oldModule);\n\t\t\tcgc.modules.add(newModule);\n\t\t\tnewCgm.chunks.add(chunk);\n\t\t}\n\t\toldCgm.chunks.clear();\n\n\t\tif (oldCgm.entryInChunks !== undefined) {\n\t\t\tif (newCgm.entryInChunks === undefined) {\n\t\t\t\tnewCgm.entryInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\n\t\t\t\tconst newEntryModules = new Map();\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\n\t\t\t\t\tif (m === oldModule) {\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcgc.entryModules = newEntryModules;\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\n\t\t\t}\n\t\t\toldCgm.entryInChunks = undefined;\n\t\t}\n\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\n\t\t\t\tif (\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.dependentHashModules.delete(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\n\t\t\t\t\t);\n\t\t\t\t\tcgc.dependentHashModules.add(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldCgm.runtimeInChunks = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.has(module);\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunkGroup(module, chunkGroup) {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @returns {boolean} true, if the module is entry of any chunk\n\t */\n\tisEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.entryInChunks !== undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetModuleChunksIterable(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetOrderedModuleChunksIterable(module, sortFn) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.chunks.sortWith(sortFn);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\n\t */\n\tgetModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromCache(getArray);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the number of chunk which contain the module\n\t */\n\tgetNumberOfModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.size;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {RuntimeSpecSet} runtimes\n\t */\n\tgetModuleRuntimes(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of full hash modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetChunkModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @param {Set<string>} sourceTypes source types\n\t */\n\tsetChunkModuleSourceTypes(chunk, module, sourceTypes) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\tcgc.sourceTypesByModule = new WeakMap();\n\t\t}\n\t\tcgc.sourceTypesByModule.set(module, sourceTypes);\n\t\t// Update cgc._modulesBySourceType to invalidate the cache\n\t\tcgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @returns {Set<string>} source types\n\t */\n\tgetChunkModuleSourceTypes(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\treturn module.getSourceTypes();\n\t\t}\n\t\treturn cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string>} source types\n\t */\n\tgetModuleSourceTypes(module) {\n\t\treturn (\n\t\t\tthis._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes()\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string> | undefined} source types\n\t */\n\t_getOverwrittenModuleSourceTypes(module) {\n\t\tlet newSet = false;\n\t\tlet sourceTypes;\n\t\tfor (const chunk of this.getModuleChunksIterable(module)) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tif (cgc.sourceTypesByModule === undefined) return;\n\t\t\tconst st = cgc.sourceTypesByModule.get(module);\n\t\t\tif (st === undefined) return;\n\t\t\tif (!sourceTypes) {\n\t\t\t\tsourceTypes = st;\n\t\t\t\tcontinue;\n\t\t\t} else if (!newSet) {\n\t\t\t\tfor (const type of st) {\n\t\t\t\t\tif (!newSet) {\n\t\t\t\t\t\tif (!sourceTypes.has(type)) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tsourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const type of st) sourceTypes.add(type);\n\t\t\t}\n\t\t}\n\n\t\treturn sourceTypes;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.sortWith(comparator);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\tif (modulesWithSourceType === undefined) return undefined;\n\t\tmodulesWithSourceType.sortWith(comparator);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetOrderedChunkModules(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n\t */\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleIdMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {number} hashLength length of the hash\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n\t */\n\tgetChunkModuleRenderedHashMap(\n\t\tchunk,\n\t\tfilterFn,\n\t\thashLength = 0,\n\t\tincludeAllChunks = false\n\t) {\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {Record<string|number, string>} */\n\t\t\tlet idToHashMap;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (idToHashMap === undefined) {\n\t\t\t\t\t\tidToHashMap = Object.create(null);\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleHashMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n\t * @returns {Record<string|number, boolean>} chunk map\n\t */\n\tgetChunkConditionMap(chunk, filterFn) {\n\t\tconst map = Object.create(null);\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\tmap[c.id] = filterFn(c, this);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\n\t\tconst queue = new Set(chunk.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\n\t\t\t\t\tchunksProcessed.add(innerChunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA first chunk\n\t * @param {Chunk} chunkB second chunk\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareChunks(chunkA, chunkB) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} total size of all modules in the chunk\n\t */\n\tgetChunkModulesSize(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n\t */\n\tgetChunkModulesSizes(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\n\t */\n\tgetChunkRootModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk\n\t */\n\tgetChunkSize(chunk, options = {}) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\n\t */\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tconst allModules = new Set(cgcA.modules);\n\t\tfor (const m of cgcB.modules) allModules.add(m);\n\t\tlet modulesSize = getModulesSize(allModules);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize *\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\n\t\t\t\t\t? entryChunkMultiplicator\n\t\t\t\t\t: 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanChunksBeIntegrated(chunkA, chunkB) {\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\n\n\t\tif (hasRuntimeA !== hasRuntimeB) {\n\t\t\tif (hasRuntimeA) {\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\n\t\t\t} else if (hasRuntimeB) {\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA the target chunk\n\t * @param {Chunk} chunkB the chunk to integrate\n\t * @returns {void}\n\t */\n\tintegrateChunks(chunkA, chunkB) {\n\t\t// Decide for one name (deterministic)\n\t\tif (chunkA.name && chunkB.name) {\n\t\t\tif (\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t\t) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\n\t\t\t\t\tchunkA.name =\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n\t\t\t\t} else {\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n\t\t\t\t}\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tchunkA.name = chunkB.name;\n\t\t\t}\n\t\t} else if (chunkB.name) {\n\t\t\tchunkA.name = chunkB.name;\n\t\t}\n\n\t\t// Merge id name hints\n\t\tfor (const hint of chunkB.idNameHints) {\n\t\t\tchunkA.idNameHints.add(hint);\n\t\t}\n\n\t\t// Merge runtime\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\t\tfor (const module of this.getChunkModules(chunkB)) {\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\n\t\t\tthis.connectChunkAndModule(chunkA, module);\n\t\t}\n\n\t\tfor (const [module, chunkGroup] of Array.from(\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\n\t\t)) {\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n\t\t}\n\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\n\t\t\tchunkA.addGroup(chunkGroup);\n\t\t\tchunkB.removeGroup(chunkGroup);\n\t\t}\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to upgrade\n\t * @returns {void}\n\t */\n\tupgradeDependentToFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined) return;\n\t\tif (cgc.fullHashModules === undefined) {\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\n\t\t} else {\n\t\t\tfor (const m of cgc.dependentHashModules) {\n\t\t\t\tcgc.fullHashModules.add(m);\n\t\t\t}\n\t\t\tcgc.dependentHashModules = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module as entry\n\t */\n\tisEntryModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.has(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n\t * @returns {void}\n\t */\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.entryInChunks === undefined) {\n\t\t\tcgm.entryInChunks = new Set();\n\t\t}\n\t\tcgm.entryInChunks.add(chunk);\n\t\tcgc.entryModules.set(module, entrypoint);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.runtimeInChunks === undefined) {\n\t\t\tcgm.runtimeInChunks = new Set();\n\t\t}\n\t\tcgm.runtimeInChunks.add(chunk);\n\t\tcgc.runtimeModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddFullHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tcgc.fullHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddDependentHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tcgc.dependentHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndEntryModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.entryInChunks.delete(chunk);\n\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\tcgm.entryInChunks = undefined;\n\t\t}\n\t\tcgc.entryModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.runtimeInChunks.delete(chunk);\n\t\tif (cgm.runtimeInChunks.size === 0) {\n\t\t\tcgm.runtimeInChunks = undefined;\n\t\t}\n\t\tcgc.runtimeModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Module} module the entry module, it will no longer be entry\n\t * @returns {void}\n\t */\n\tdisconnectEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tfor (const chunk of cgm.entryInChunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.entryModules.delete(module);\n\t\t}\n\t\tcgm.entryInChunks = undefined;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\n\t * @returns {void}\n\t */\n\tdisconnectEntries(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.entryModules.keys()) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.entryInChunks.delete(chunk);\n\t\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\t\tcgm.entryInChunks = undefined;\n\t\t\t}\n\t\t}\n\t\tcgc.entryModules.clear();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfEntryModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfRuntimeModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.keys();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Chunk>} iterable of chunks\n\t */\n\tgetChunkEntryDependentChunksIterable(chunk) {\n\t\t/** @type {Set<Chunk>} */\n\t\tconst set = new Set();\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n\t\t\t\t\t\t\tset.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {boolean} true, when it has dependent chunks\n\t */\n\thasChunkEntryDependentChunks(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\tif (c !== chunk) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n\t */\n\tgetChunkRuntimeModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {RuntimeModule[]} array of modules in order of execution\n\t */\n\tgetChunkRuntimeModulesInOrder(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst array = Array.from(cgc.runtimeModules);\n\t\tarray.sort(\n\t\t\tconcatComparators(\n\t\t\t\tcompareSelect(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\n\t\t\t\t\t * @returns {number=} stage\n\t\t\t\t\t */\n\t\t\t\t\tr => r.stage,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareModulesByIdentifier\n\t\t\t)\n\t\t);\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesSet(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkDependentHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.dependentHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @returns {ChunkGroup} the chunk group\n\t */\n\tgetBlockChunkGroup(depBlock) {\n\t\treturn this._blockChunkGroups.get(depBlock);\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\n\t\tchunkGroup.addBlock(depBlock);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tdisconnectChunkGroup(chunkGroup) {\n\t\tfor (const block of chunkGroup.blocksIterable) {\n\t\t\tthis._blockChunkGroups.delete(block);\n\t\t}\n\t\t// TODO refactor by moving blocks list into ChunkGraph\n\t\tchunkGroup._blocks.clear();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {string | number} the id of the module\n\t */\n\tgetModuleId(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.id;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | number} id the id of the module\n\t * @returns {void}\n\t */\n\tsetModuleId(module, id) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.id = id;\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @returns {string | number} the id of the runtime\n\t */\n\tgetRuntimeId(runtime) {\n\t\treturn this._runtimeIds.get(runtime);\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @param {string | number} id the id of the runtime\n\t * @returns {void}\n\t */\n\tsetRuntimeId(runtime, id) {\n\t\tthis._runtimeIds.set(runtime, id);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {Module} module the module\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {T} hash\n\t */\n\t_getModuleHashInfo(module, hashes, runtime) {\n\t\tif (!hashes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} (hashes not set at all)`\n\t\t\t);\n\t\t} else if (runtime === undefined) {\n\t\t\tconst hashInfoItems = new Set(hashes.values());\n\t\t\tif (hashInfoItems.size !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn first(hashInfoItems);\n\t\t} else {\n\t\t\tconst hashInfo = hashes.get(runtime);\n\t\t\tif (!hashInfo) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\t\truntime\n\t\t\t\t\t)} (available runtimes ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\truntimeToString\n\t\t\t\t\t).join(\", \")})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn hashInfo;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the module has hashes for this runtime\n\t */\n\thasModuleHashes(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = /** @type {RuntimeSpecMap<ModuleHashInfo>} */ (cgm.hashes);\n\t\treturn hashes && hashes.has(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = /** @type {RuntimeSpecMap<ModuleHashInfo>} */ (cgm.hashes);\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetRenderedModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = /** @type {RuntimeSpecMap<ModuleHashInfo>} */ (cgm.hashes);\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {string} hash the full hash\n\t * @param {string} renderedHash the shortened hash for rendering\n\t * @returns {void}\n\t */\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tif (cgm.hashes === undefined) {\n\t\t\tcgm.hashes = new RuntimeSpecMap();\n\t\t}\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n\t * @returns {void}\n\t */\n\taddModuleRuntimeRequirements(\n\t\tmodule,\n\t\truntime,\n\t\titems,\n\t\ttransferOwnership = true\n\t) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\n\t\tif (runtimeRequirementsMap === undefined) {\n\t\t\tconst map = new RuntimeSpecMap();\n\t\t\t// TODO avoid cloning item and track ownership instead\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\n\t\t\tcgm.runtimeRequirements = map;\n\t\t\treturn;\n\t\t}\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\n\t\t\tif (runtimeRequirements === undefined) {\n\t\t\t\treturn transferOwnership ? items : new Set(items);\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t\t\treturn runtimeRequirements;\n\t\t\t} else {\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n\t * @returns {void}\n\t */\n\taddChunkRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\tif (runtimeRequirements === undefined) {\n\t\t\tcgc.runtimeRequirements = items;\n\t\t} else if (runtimeRequirements.size >= items.size) {\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t} else {\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\tcgc.runtimeRequirements = items;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<string>} items runtime requirements to be added\n\t * @returns {void}\n\t */\n\taddTreeRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\n\t\tfor (const item of items) runtimeRequirements.add(item);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetModuleRuntimeRequirements(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirements =\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetChunkRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {string} hash\n\t */\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {bigint} hash\n\t */\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? BigInt(\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\n\t\t\t  )\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {bigint} hash as big int\n\t */\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\n\t\tif (cgm.graphHashes === undefined) {\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\n\t\t}\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\t\t\tconst sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n\t\t\tif (sourceTypes !== undefined) {\n\t\t\t\tfor (const type of sourceTypes) hash.update(type);\n\t\t\t}\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\n\t\t});\n\t\treturn graphHash;\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\n\t\tif (cgm.graphHashesWithConnections === undefined) {\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\n\t\t}\n\t\tconst activeStateToString = state => {\n\t\t\tif (state === false) return \"F\";\n\t\t\tif (state === true) return \"T\";\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n\t\t\tthrow new Error(\"Not implemented active state\");\n\t\t};\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\n\t\t\t\tcgm,\n\t\t\t\tmodule,\n\t\t\t\truntime\n\t\t\t).toString(16);\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst activeNamespaceModules = new Set();\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\n\t\t\tconst connectedModules = new Map();\n\t\t\tconst processConnection = (connection, stateInfo) => {\n\t\t\t\tconst module = connection.module;\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\n\t\t\t\telse {\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\n\t\t\t\t\tif (oldModule === undefined) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\n\t\t\t\t\t} else if (oldModule instanceof Set) {\n\t\t\t\t\t\toldModule.add(module);\n\t\t\t\t\t} else if (oldModule !== module) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst states = new Set();\n\t\t\t\t\tlet stateInfo = \"\";\n\t\t\t\t\tforEachRuntime(\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntime => {\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\t\t\tstates.add(state);\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tif (states.size === 1) {\n\t\t\t\t\t\tconst state = first(states);\n\t\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\n\t\t\t\t\t}\n\t\t\t\t\tprocessConnection(connection, stateInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cspell:word Tnamespace\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\n\t\t\t\treturn graphHash;\n\t\t\tconst connectedModulesInOrder =\n\t\t\t\tconnectedModules.size > 1\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\n\t\t\t\t\t: connectedModules;\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tconst addModuleToHash = module => {\n\t\t\t\thash.update(\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntime\n\t\t\t\t\t).toString(16)\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst addModulesToHash = modules => {\n\t\t\t\tlet xor = ZERO_BIG_INT;\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\txor =\n\t\t\t\t\t\txor ^\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\n\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\thash.update(xor.toString(16));\n\t\t\t};\n\t\t\tif (activeNamespaceModules.size === 1)\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\n\t\t\telse if (activeNamespaceModules.size > 1)\n\t\t\t\taddModulesToHash(activeNamespaceModules);\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\n\t\t\t\thash.update(stateInfo);\n\t\t\t\tif (modules instanceof Set) {\n\t\t\t\t\taddModulesToHash(modules);\n\t\t\t\t} else {\n\t\t\t\t\taddModuleToHash(modules);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.update(graphHash);\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetTreeRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeRequirementsInTree;\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForModule(module, chunkGraph) {\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForModule(module) {\n\t\tchunkGraphForModuleMap.delete(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n\t\tif (fn) return fn(chunk);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tchunk => {\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n\t\treturn newFn(chunk);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForChunk(chunk) {\n\t\tchunkGraphForChunkMap.delete(chunk);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\n\nmodule.exports = ChunkGraph;\n"]},"metadata":{},"sourceType":"script"}