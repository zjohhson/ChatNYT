{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * The maximum safe integer value for 32-bit integers.\n * @type {number}\n */\n\nconst SAFE_LIMIT = 0x80000000;\n/**\n * The maximum safe integer value for 32-bit integers minus one. This is used\n * in the algorithm to ensure that intermediate hash values do not exceed the\n * 32-bit integer limit.\n * @type {number}\n */\n\nconst SAFE_PART = SAFE_LIMIT - 1;\n/**\n * The number of 32-bit integers used to store intermediate hash values.\n * @type {number}\n */\n\nconst COUNT = 4;\n/**\n * An array used to store intermediate hash values during the calculation.\n * @type {number[]}\n */\n\nconst arr = [0, 0, 0, 0, 0];\n/**\n * An array of prime numbers used in the hash calculation.\n * @type {number[]}\n */\n\nconst primes = [3, 7, 17, 19];\n/**\n * Computes a hash value for the given string and range. This hashing algorithm is a modified\n * version of the [FNV-1a algorithm](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function).\n * It is optimized for speed and does **not** generate a cryptographic hash value.\n *\n * We use `numberHash` in `lib/ids/IdHelpers.js` to generate hash values for the module identifier. The generated\n * hash is used as a prefix for the module id's to avoid collisions with other modules.\n *\n * @param {string} str The input string to hash.\n * @param {number} range The range of the hash value (0 to range-1).\n * @returns {number} - The computed hash value.\n *\n * @example\n *\n * ```js\n * const numberHash = require(\"webpack/lib/util/numberHash\");\n * numberHash(\"hello\", 1000); // 57\n * numberHash(\"hello world\"); // 990\n * ```\n *\n */\n\nmodule.exports = (str, range) => {\n  /**\n   * Initialize the array with zeros before it is used\n   * to store intermediate hash values.\n   */\n  arr.fill(0); // For each character in the string\n\n  for (let i = 0; i < str.length; i++) {\n    // Get the character code.\n    const c = str.charCodeAt(i); // For each 32-bit integer used to store the hash value\n    // add the character code to the current hash value and multiply by the prime number and\n    // add the previous 32-bit integer.\n\n    arr[0] = arr[0] + c * primes[0] + arr[3] & SAFE_PART;\n    arr[1] = arr[1] + c * primes[1] + arr[0] & SAFE_PART;\n    arr[2] = arr[2] + c * primes[2] + arr[1] & SAFE_PART;\n    arr[3] = arr[3] + c * primes[3] + arr[2] & SAFE_PART; // For each 32-bit integer used to store the hash value\n    // XOR the current hash value with the value of the next 32-bit integer.\n\n    arr[0] = arr[0] ^ arr[arr[0] % COUNT] >> 1;\n    arr[1] = arr[1] ^ arr[arr[1] % COUNT] >> 1;\n    arr[2] = arr[2] ^ arr[arr[2] % COUNT] >> 1;\n    arr[3] = arr[3] ^ arr[arr[3] % COUNT] >> 1;\n  }\n\n  if (range <= SAFE_PART) {\n    return (arr[0] + arr[1] + arr[2] + arr[3]) % range;\n  } else {\n    // Calculate the range extension.\n    const rangeExt = Math.floor(range / SAFE_LIMIT);\n    const sum1 = arr[0] + arr[2] & SAFE_PART;\n    const sum2 = (arr[0] + arr[2]) % rangeExt;\n    return (sum2 * SAFE_LIMIT + sum1) % range;\n  }\n};","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/util/numberHash.js"],"names":["SAFE_LIMIT","SAFE_PART","COUNT","arr","primes","module","exports","str","range","fill","i","length","c","charCodeAt","rangeExt","Math","floor","sum1","sum2"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * The maximum safe integer value for 32-bit integers.\n * @type {number}\n */\nconst SAFE_LIMIT = 0x80000000;\n\n/**\n * The maximum safe integer value for 32-bit integers minus one. This is used\n * in the algorithm to ensure that intermediate hash values do not exceed the\n * 32-bit integer limit.\n * @type {number}\n */\nconst SAFE_PART = SAFE_LIMIT - 1;\n\n/**\n * The number of 32-bit integers used to store intermediate hash values.\n * @type {number}\n */\nconst COUNT = 4;\n\n/**\n * An array used to store intermediate hash values during the calculation.\n * @type {number[]}\n */\nconst arr = [0, 0, 0, 0, 0];\n\n/**\n * An array of prime numbers used in the hash calculation.\n * @type {number[]}\n */\nconst primes = [3, 7, 17, 19];\n\n/**\n * Computes a hash value for the given string and range. This hashing algorithm is a modified\n * version of the [FNV-1a algorithm](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function).\n * It is optimized for speed and does **not** generate a cryptographic hash value.\n *\n * We use `numberHash` in `lib/ids/IdHelpers.js` to generate hash values for the module identifier. The generated\n * hash is used as a prefix for the module id's to avoid collisions with other modules.\n *\n * @param {string} str The input string to hash.\n * @param {number} range The range of the hash value (0 to range-1).\n * @returns {number} - The computed hash value.\n *\n * @example\n *\n * ```js\n * const numberHash = require(\"webpack/lib/util/numberHash\");\n * numberHash(\"hello\", 1000); // 57\n * numberHash(\"hello world\"); // 990\n * ```\n *\n */\nmodule.exports = (str, range) => {\n\t/**\n\t * Initialize the array with zeros before it is used\n\t * to store intermediate hash values.\n\t */\n\tarr.fill(0);\n\t// For each character in the string\n\tfor (let i = 0; i < str.length; i++) {\n\t\t// Get the character code.\n\t\tconst c = str.charCodeAt(i);\n\n\t\t// For each 32-bit integer used to store the hash value\n\t\t// add the character code to the current hash value and multiply by the prime number and\n\t\t// add the previous 32-bit integer.\n\t\tarr[0] = (arr[0] + c * primes[0] + arr[3]) & SAFE_PART;\n\t\tarr[1] = (arr[1] + c * primes[1] + arr[0]) & SAFE_PART;\n\t\tarr[2] = (arr[2] + c * primes[2] + arr[1]) & SAFE_PART;\n\t\tarr[3] = (arr[3] + c * primes[3] + arr[2]) & SAFE_PART;\n\n\t\t// For each 32-bit integer used to store the hash value\n\t\t// XOR the current hash value with the value of the next 32-bit integer.\n\t\tarr[0] = arr[0] ^ (arr[arr[0] % COUNT] >> 1);\n\t\tarr[1] = arr[1] ^ (arr[arr[1] % COUNT] >> 1);\n\t\tarr[2] = arr[2] ^ (arr[arr[2] % COUNT] >> 1);\n\t\tarr[3] = arr[3] ^ (arr[arr[3] % COUNT] >> 1);\n\t}\n\n\tif (range <= SAFE_PART) {\n\t\treturn (arr[0] + arr[1] + arr[2] + arr[3]) % range;\n\t} else {\n\t\t// Calculate the range extension.\n\t\tconst rangeExt = Math.floor(range / SAFE_LIMIT);\n\n\t\tconst sum1 = (arr[0] + arr[2]) & SAFE_PART;\n\t\tconst sum2 = (arr[0] + arr[2]) % rangeExt;\n\n\t\treturn (sum2 * SAFE_LIMIT + sum1) % range;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}