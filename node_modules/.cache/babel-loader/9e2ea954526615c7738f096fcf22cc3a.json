{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\n\nmodule.exports.processExportsField = function processExportsField(exportsField) {\n  return createFieldProcessor(buildExportsField(exportsField), request => request.length === 0 ? \".\" : \"./\" + request, assertExportsFieldRequest, assertExportTarget);\n};\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\n\n\nmodule.exports.processImportsField = function processImportsField(importsField) {\n  return createFieldProcessor(buildImportsField(importsField), request => \"#\" + request, assertImportsFieldRequest, assertImportTarget);\n};\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\n\n\nfunction createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {\n  return function fieldProcessor(request, conditionNames) {\n    request = assertRequest(request);\n    const match = findMatch(normalizeRequest(request), field);\n    if (match === null) return [];\n    const [mapping, remainingRequest, isSubpathMapping, isPattern] = match;\n    /** @type {DirectMapping|null} */\n\n    let direct = null;\n\n    if (isConditionalMapping(mapping)) {\n      direct = conditionalMapping(\n      /** @type {ConditionalMapping} */\n      mapping, conditionNames); // matching not found\n\n      if (direct === null) return [];\n    } else {\n      direct =\n      /** @type {DirectMapping} */\n      mapping;\n    }\n\n    return directMapping(remainingRequest, isPattern, isSubpathMapping, direct, conditionNames, assertTarget);\n  };\n}\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\n\n\nfunction assertExportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== dotCode) {\n    throw new Error('Request should be relative path and start with \".\"');\n  }\n\n  if (request.length === 1) return \"\";\n\n  if (request.charCodeAt(1) !== slashCode) {\n    throw new Error('Request should be relative path and start with \"./\"');\n  }\n\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n\n  return request.slice(2);\n}\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\n\n\nfunction assertImportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== hashCode) {\n    throw new Error('Request should start with \"#\"');\n  }\n\n  if (request.length === 1) {\n    throw new Error(\"Request should have at least 2 characters\");\n  }\n\n  if (request.charCodeAt(1) === slashCode) {\n    throw new Error('Request should not start with \"#/\"');\n  }\n\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n\n  return request.slice(1);\n}\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\n\n\nfunction assertExportTarget(exp, expectFolder) {\n  if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {\n    throw new Error(`Export should be relative path and start with \"./\", got ${JSON.stringify(exp)}.`);\n  }\n\n  const isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with \"/\"`);\n  }\n}\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\n\n\nfunction assertImportTarget(imp, expectFolder) {\n  const isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with \"/\"`);\n  }\n}\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\n\n\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = a.indexOf(\"*\");\n  const bPatternIndex = b.indexOf(\"*\");\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\n\n\nfunction findMatch(request, field) {\n  if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes(\"*\") && !request.endsWith(\"/\")) {\n    const target =\n    /** @type {{[k: string]: MappingValue}} */\n    field[request];\n    return [target, \"\", false, false];\n  }\n  /** @type {string} */\n\n\n  let bestMatch = \"\";\n  /** @type {string|undefined} */\n\n  let bestMatchSubpath;\n  const keys = Object.getOwnPropertyNames(field);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = key.indexOf(\"*\");\n\n    if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n      const patternTrailer = key.slice(patternIndex + 1);\n\n      if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf(\"*\") === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = request.slice(patternIndex, request.length - patternTrailer.length);\n      }\n    } // For legacy `./foo/`\n    else if (key[key.length - 1] === \"/\" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {\n      bestMatch = key;\n      bestMatchSubpath = request.slice(key.length);\n    }\n  }\n\n  if (bestMatch === \"\") return null;\n  const target =\n  /** @type {{[k: string]: MappingValue}} */\n  field[bestMatch];\n  const isSubpathMapping = bestMatch.endsWith(\"/\");\n  const isPattern = bestMatch.includes(\"*\");\n  return [target,\n  /** @type {string} */\n  bestMatchSubpath, isSubpathMapping, isPattern];\n}\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\n\n\nfunction isConditionalMapping(mapping) {\n  return mapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping);\n}\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\n\n\nfunction directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {\n  if (mappingTarget === null) return [];\n\n  if (typeof mappingTarget === \"string\") {\n    return [targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert)];\n  }\n  /** @type {string[]} */\n\n\n  const targets = [];\n\n  for (const exp of mappingTarget) {\n    if (typeof exp === \"string\") {\n      targets.push(targetMapping(remainingRequest, isPattern, isSubpathMapping, exp, assert));\n      continue;\n    }\n\n    const mapping = conditionalMapping(exp, conditionNames);\n    if (!mapping) continue;\n    const innerExports = directMapping(remainingRequest, isPattern, isSubpathMapping, mapping, conditionNames, assert);\n\n    for (const innerExport of innerExports) {\n      targets.push(innerExport);\n    }\n  }\n\n  return targets;\n}\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\n\n\nfunction targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {\n  if (remainingRequest === undefined) {\n    assert(mappingTarget, false);\n    return mappingTarget;\n  }\n\n  if (isSubpathMapping) {\n    assert(mappingTarget, true);\n    return mappingTarget + remainingRequest;\n  }\n\n  assert(mappingTarget, false);\n  let result = mappingTarget;\n\n  if (isPattern) {\n    result = result.replace(patternRegEx, remainingRequest.replace(/\\$/g, \"$$\"));\n  }\n\n  return result;\n}\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\n\n\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n  /** @type {[ConditionalMapping, string[], number][]} */\n  let lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n  loop: while (lookup.length > 0) {\n    const [mapping, conditions, j] = lookup[lookup.length - 1];\n    const last = conditions.length - 1;\n\n    for (let i = j; i < conditions.length; i++) {\n      const condition = conditions[i]; // assert default. Could be last only\n\n      if (i !== last) {\n        if (condition === \"default\") {\n          throw new Error(\"Default condition should be last one\");\n        }\n      } else if (condition === \"default\") {\n        const innerMapping = mapping[condition]; // is nested\n\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping =\n          /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n\n        return (\n          /** @type {DirectMapping} */\n          innerMapping\n        );\n      }\n\n      if (conditionNames.has(condition)) {\n        const innerMapping = mapping[condition]; // is nested\n\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping =\n          /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n\n        return (\n          /** @type {DirectMapping} */\n          innerMapping\n        );\n      }\n    }\n\n    lookup.pop();\n  }\n\n  return null;\n}\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\n\n\nfunction buildExportsField(field) {\n  // handle syntax sugar, if exports field is direct mapping for \".\"\n  if (typeof field === \"string\" || Array.isArray(field)) {\n    return {\n      \".\": field\n    };\n  }\n\n  const keys = Object.keys(field);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n\n    if (key.charCodeAt(0) !== dotCode) {\n      // handle syntax sugar, if exports field is conditional mapping for \".\"\n      if (i === 0) {\n        while (i < keys.length) {\n          const charCode = keys[i].charCodeAt(0);\n\n          if (charCode === dotCode || charCode === slashCode) {\n            throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n          }\n\n          i++;\n        }\n\n        return {\n          \".\": field\n        };\n      }\n\n      throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n    }\n\n    if (key.length === 1) {\n      continue;\n    }\n\n    if (key.charCodeAt(1) !== slashCode) {\n      throw new Error(`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(key)})`);\n    }\n  }\n\n  return field;\n}\n/**\n * @param {ImportsField} field imports field\n * @returns {ImportsField} normalized imports field\n */\n\n\nfunction buildImportsField(field) {\n  const keys = Object.keys(field);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n\n    if (key.charCodeAt(0) !== hashCode) {\n      throw new Error(`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`);\n    }\n\n    if (key.length === 1) {\n      throw new Error(`Imports field key should have at least 2 characters (key: ${JSON.stringify(key)})`);\n    }\n\n    if (key.charCodeAt(1) === slashCode) {\n      throw new Error(`Imports field key should not start with \"#/\" (key: ${JSON.stringify(key)})`);\n    }\n  }\n\n  return field;\n}","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/enhanced-resolve/lib/util/entrypoints.js"],"names":["slashCode","charCodeAt","dotCode","hashCode","patternRegEx","module","exports","processExportsField","exportsField","createFieldProcessor","buildExportsField","request","length","assertExportsFieldRequest","assertExportTarget","processImportsField","importsField","buildImportsField","assertImportsFieldRequest","assertImportTarget","field","normalizeRequest","assertRequest","assertTarget","fieldProcessor","conditionNames","match","findMatch","mapping","remainingRequest","isSubpathMapping","isPattern","direct","isConditionalMapping","conditionalMapping","directMapping","Error","slice","exp","expectFolder","JSON","stringify","isFolder","imp","patternKeyCompare","a","b","aPatternIndex","indexOf","bPatternIndex","baseLenA","baseLenB","Object","prototype","hasOwnProperty","call","includes","endsWith","target","bestMatch","bestMatchSubpath","keys","getOwnPropertyNames","i","key","patternIndex","startsWith","patternTrailer","lastIndexOf","Array","isArray","mappingTarget","assert","targetMapping","targets","push","innerExports","innerExport","undefined","result","replace","conditionalMapping_","lookup","loop","conditions","j","last","condition","innerMapping","has","pop","charCode"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsField(exportsField),\n\t\trequest => (request.length === 0 ? \".\" : \"./\" + request),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget\n\t);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildImportsField(importsField),\n\t\trequest => \"#\" + request,\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget\n\t);\n};\n\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(\n\tfield,\n\tnormalizeRequest,\n\tassertRequest,\n\tassertTarget\n) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\trequest = assertRequest(request);\n\n\t\tconst match = findMatch(normalizeRequest(request), field);\n\n\t\tif (match === null) return [];\n\n\t\tconst [mapping, remainingRequest, isSubpathMapping, isPattern] = match;\n\n\t\t/** @type {DirectMapping|null} */\n\t\tlet direct = null;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\treturn directMapping(\n\t\t\tremainingRequest,\n\t\t\tisPattern,\n\t\t\tisSubpathMapping,\n\t\t\tdirect,\n\t\t\tconditionNames,\n\t\t\tassertTarget\n\t\t);\n\t};\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return \"\";\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tif (\n\t\texp.charCodeAt(0) === slashCode ||\n\t\t(exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode)\n\t) {\n\t\tthrow new Error(\n\t\t\t`Export should be relative path and start with \"./\", got ${JSON.stringify(\n\t\t\t\texp\n\t\t\t)}.`\n\t\t);\n\t}\n\n\tconst isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\nfunction patternKeyCompare(a, b) {\n\tconst aPatternIndex = a.indexOf(\"*\");\n\tconst bPatternIndex = b.indexOf(\"*\");\n\tconst baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n\tconst baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n\n\tif (baseLenA > baseLenB) return -1;\n\tif (baseLenB > baseLenA) return 1;\n\tif (aPatternIndex === -1) return 1;\n\tif (bPatternIndex === -1) return -1;\n\tif (a.length > b.length) return -1;\n\tif (b.length > a.length) return 1;\n\n\treturn 0;\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, field) {\n\tif (\n\t\tObject.prototype.hasOwnProperty.call(field, request) &&\n\t\t!request.includes(\"*\") &&\n\t\t!request.endsWith(\"/\")\n\t) {\n\t\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[request];\n\n\t\treturn [target, \"\", false, false];\n\t}\n\n\t/** @type {string} */\n\tlet bestMatch = \"\";\n\t/** @type {string|undefined} */\n\tlet bestMatchSubpath;\n\n\tconst keys = Object.getOwnPropertyNames(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst patternIndex = key.indexOf(\"*\");\n\n\t\tif (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n\t\t\tconst patternTrailer = key.slice(patternIndex + 1);\n\n\t\t\tif (\n\t\t\t\trequest.length >= key.length &&\n\t\t\t\trequest.endsWith(patternTrailer) &&\n\t\t\t\tpatternKeyCompare(bestMatch, key) === 1 &&\n\t\t\t\tkey.lastIndexOf(\"*\") === patternIndex\n\t\t\t) {\n\t\t\t\tbestMatch = key;\n\t\t\t\tbestMatchSubpath = request.slice(\n\t\t\t\t\tpatternIndex,\n\t\t\t\t\trequest.length - patternTrailer.length\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// For legacy `./foo/`\n\t\telse if (\n\t\t\tkey[key.length - 1] === \"/\" &&\n\t\t\trequest.startsWith(key) &&\n\t\t\tpatternKeyCompare(bestMatch, key) === 1\n\t\t) {\n\t\t\tbestMatch = key;\n\t\t\tbestMatchSubpath = request.slice(key.length);\n\t\t}\n\t}\n\n\tif (bestMatch === \"\") return null;\n\n\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[bestMatch];\n\tconst isSubpathMapping = bestMatch.endsWith(\"/\");\n\tconst isPattern = bestMatch.includes(\"*\");\n\n\treturn [\n\t\ttarget,\n\t\t/** @type {string} */ (bestMatchSubpath),\n\t\tisSubpathMapping,\n\t\tisPattern\n\t];\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tconditionNames,\n\tassert\n) {\n\tif (mappingTarget === null) return [];\n\n\tif (typeof mappingTarget === \"string\") {\n\t\treturn [\n\t\t\ttargetMapping(\n\t\t\t\tremainingRequest,\n\t\t\t\tisPattern,\n\t\t\t\tisSubpathMapping,\n\t\t\t\tmappingTarget,\n\t\t\t\tassert\n\t\t\t)\n\t\t];\n\t}\n\n\t/** @type {string[]} */\n\tconst targets = [];\n\n\tfor (const exp of mappingTarget) {\n\t\tif (typeof exp === \"string\") {\n\t\t\ttargets.push(\n\t\t\t\ttargetMapping(\n\t\t\t\t\tremainingRequest,\n\t\t\t\t\tisPattern,\n\t\t\t\t\tisSubpathMapping,\n\t\t\t\t\texp,\n\t\t\t\t\tassert\n\t\t\t\t)\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tisPattern,\n\t\t\tisSubpathMapping,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tassert\n) {\n\tif (remainingRequest === undefined) {\n\t\tassert(mappingTarget, false);\n\n\t\treturn mappingTarget;\n\t}\n\n\tif (isSubpathMapping) {\n\t\tassert(mappingTarget, true);\n\n\t\treturn mappingTarget + remainingRequest;\n\t}\n\n\tassert(mappingTarget, false);\n\n\tlet result = mappingTarget;\n\n\tif (isPattern) {\n\t\tresult = result.replace(\n\t\t\tpatternRegEx,\n\t\t\tremainingRequest.replace(/\\$/g, \"$$\")\n\t\t);\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tlet lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\t\tconst last = conditions.length - 1;\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\t// assert default. Could be last only\n\t\t\tif (i !== last) {\n\t\t\t\tif (condition === \"default\") {\n\t\t\t\t\tthrow new Error(\"Default condition should be last one\");\n\t\t\t\t}\n\t\t\t} else if (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\nfunction buildExportsField(field) {\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\" || Array.isArray(field)) {\n\t\treturn { \".\": field };\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn { \".\": field };\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn field;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {ImportsField} normalized imports field\n */\nfunction buildImportsField(field) {\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== hashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should have at least 2 characters (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.charCodeAt(1) === slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should not start with \"#/\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn field;\n}\n"]},"metadata":{},"sourceType":"script"}