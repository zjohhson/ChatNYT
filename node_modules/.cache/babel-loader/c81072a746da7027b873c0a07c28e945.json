{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst memoize = require(\"../util/memoize\");\n\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/*\nFormat:\n\nFile -> Section*\n\nSection -> NullsSection |\n\t\t\t\t\t BooleansSection |\n\t\t\t\t\t F64NumbersSection |\n\t\t\t\t\t I32NumbersSection |\n\t\t\t\t\t I8NumbersSection |\n\t\t\t\t\t ShortStringSection |\n\t\t\t\t\t BigIntSection |\n\t\t\t\t\t I32BigIntSection |\n\t\t\t\t\t I8BigIntSection\n\t\t\t\t\t StringSection |\n\t\t\t\t\t BufferSection |\n\t\t\t\t\t NopSection\n\n\n\nNullsSection ->\n\tNullHeaderByte | Null2HeaderByte | Null3HeaderByte |\n\tNulls8HeaderByte 0xnn (n:count - 4) |\n\tNulls32HeaderByte n:ui32 (n:count - 260) |\nBooleansSection -> TrueHeaderByte | FalseHeaderByte | BooleansSectionHeaderByte BooleansCountAndBitsByte\nF64NumbersSection -> F64NumbersSectionHeaderByte f64*\nI32NumbersSection -> I32NumbersSectionHeaderByte i32*\nI8NumbersSection -> I8NumbersSectionHeaderByte i8*\nShortStringSection -> ShortStringSectionHeaderByte ascii-byte*\nStringSection -> StringSectionHeaderByte i32:length utf8-byte*\nBufferSection -> BufferSectionHeaderByte i32:length byte*\nNopSection --> NopSectionHeaderByte\nBigIntSection -> BigIntSectionHeaderByte i32:length ascii-byte*\nI32BigIntSection -> I32BigIntSectionHeaderByte i32\nI8BigIntSection -> I8BigIntSectionHeaderByte i8\n\nShortStringSectionHeaderByte -> 0b1nnn_nnnn (n:length)\n\nF64NumbersSectionHeaderByte -> 0b001n_nnnn (n:count - 1)\nI32NumbersSectionHeaderByte -> 0b010n_nnnn (n:count - 1)\nI8NumbersSectionHeaderByte -> 0b011n_nnnn (n:count - 1)\n\nNullsSectionHeaderByte -> 0b0001_nnnn (n:count - 1)\nBooleansCountAndBitsByte ->\n\t0b0000_1xxx (count = 3) |\n\t0b0001_xxxx (count = 4) |\n\t0b001x_xxxx (count = 5) |\n\t0b01xx_xxxx (count = 6) |\n\t0b1nnn_nnnn (n:count - 7, 7 <= count <= 133)\n\t0xff n:ui32 (n:count, 134 <= count < 2^32)\n\nStringSectionHeaderByte -> 0b0000_1110\nBufferSectionHeaderByte -> 0b0000_1111\nNopSectionHeaderByte -> 0b0000_1011\nBigIntSectionHeaderByte -> 0b0001_1010\nI32BigIntSectionHeaderByte -> 0b0001_1100\nI8BigIntSectionHeaderByte -> 0b0001_1011\nFalseHeaderByte -> 0b0000_1100\nTrueHeaderByte -> 0b0000_1101\n\nRawNumber -> n (n <= 10)\n\n*/\n\n\nconst LAZY_HEADER = 0x0b;\nconst TRUE_HEADER = 0x0c;\nconst FALSE_HEADER = 0x0d;\nconst BOOLEANS_HEADER = 0x0e;\nconst NULL_HEADER = 0x10;\nconst NULL2_HEADER = 0x11;\nconst NULL3_HEADER = 0x12;\nconst NULLS8_HEADER = 0x13;\nconst NULLS32_HEADER = 0x14;\nconst NULL_AND_I8_HEADER = 0x15;\nconst NULL_AND_I32_HEADER = 0x16;\nconst NULL_AND_TRUE_HEADER = 0x17;\nconst NULL_AND_FALSE_HEADER = 0x18;\nconst BIGINT_HEADER = 0x1a;\nconst BIGINT_I8_HEADER = 0x1b;\nconst BIGINT_I32_HEADER = 0x1c;\nconst STRING_HEADER = 0x1e;\nconst BUFFER_HEADER = 0x1f;\nconst I8_HEADER = 0x60;\nconst I32_HEADER = 0x40;\nconst F64_HEADER = 0x20;\nconst SHORT_STRING_HEADER = 0x80;\n/** Uplift high-order bits */\n\nconst NUMBERS_HEADER_MASK = 0xe0; // 0b1010_0000\n\nconst NUMBERS_COUNT_MASK = 0x1f; // 0b0001_1111\n\nconst SHORT_STRING_LENGTH_MASK = 0x7f; // 0b0111_1111\n\nconst HEADER_SIZE = 1;\nconst I8_SIZE = 1;\nconst I32_SIZE = 4;\nconst F64_SIZE = 8;\nconst MEASURE_START_OPERATION = Symbol(\"MEASURE_START_OPERATION\");\nconst MEASURE_END_OPERATION = Symbol(\"MEASURE_END_OPERATION\");\n/** @typedef {typeof MEASURE_START_OPERATION} MEASURE_START_OPERATION_TYPE */\n\n/** @typedef {typeof MEASURE_END_OPERATION} MEASURE_END_OPERATION_TYPE */\n\n/**\n * @param {number} n number\n * @returns {0 | 1 | 2} type of number for serialization\n */\n\nconst identifyNumber = n => {\n  if (n === (n | 0)) {\n    if (n <= 127 && n >= -128) return 0;\n    if (n <= 2147483647 && n >= -2147483648) return 1;\n  }\n\n  return 2;\n};\n/**\n * @param {bigint} n bigint\n * @returns {0 | 1 | 2} type of bigint for serialization\n */\n\n\nconst identifyBigInt = n => {\n  if (n <= BigInt(127) && n >= BigInt(-128)) return 0;\n  if (n <= BigInt(2147483647) && n >= BigInt(-2147483648)) return 1;\n  return 2;\n};\n/**\n * @typedef {PrimitiveSerializableType[]} DeserializedType\n * @typedef {BufferSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\n\n\nclass BinaryMiddleware extends SerializerMiddleware {\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n  serialize(data, context) {\n    return this._serialize(data, context);\n  }\n\n  _serializeLazy(fn, context) {\n    return SerializerMiddleware.serializeLazy(fn, data => this._serialize(data, context));\n  }\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope\n   * @returns {SerializedType} serialized data\n   */\n\n\n  _serialize(data, context) {\n    let allocationScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      allocationSize: 1024,\n      increaseCounter: 0,\n      leftOverBuffer: null\n    };\n\n    /** @type {Buffer} */\n    let leftOverBuffer = null;\n    /** @type {BufferSerializableType[]} */\n\n    let buffers = [];\n    /** @type {Buffer} */\n\n    let currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;\n    allocationScope.leftOverBuffer = null;\n    let currentPosition = 0;\n\n    if (currentBuffer === null) {\n      currentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize);\n    }\n\n    const allocate = bytesNeeded => {\n      if (currentBuffer !== null) {\n        if (currentBuffer.length - currentPosition >= bytesNeeded) return;\n        flush();\n      }\n\n      if (leftOverBuffer && leftOverBuffer.length >= bytesNeeded) {\n        currentBuffer = leftOverBuffer;\n        leftOverBuffer = null;\n      } else {\n        currentBuffer = Buffer.allocUnsafe(Math.max(bytesNeeded, allocationScope.allocationSize));\n\n        if (!(allocationScope.increaseCounter = (allocationScope.increaseCounter + 1) % 4) && allocationScope.allocationSize < 16777216) {\n          allocationScope.allocationSize = allocationScope.allocationSize << 1;\n        }\n      }\n    };\n\n    const flush = () => {\n      if (currentBuffer !== null) {\n        if (currentPosition > 0) {\n          buffers.push(Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset, currentPosition));\n        }\n\n        if (!leftOverBuffer || leftOverBuffer.length < currentBuffer.length - currentPosition) {\n          leftOverBuffer = Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset + currentPosition, currentBuffer.byteLength - currentPosition);\n        }\n\n        currentBuffer = null;\n        currentPosition = 0;\n      }\n    };\n    /**\n     * @param {number} byte byte\n     */\n\n\n    const writeU8 = byte => {\n      currentBuffer.writeUInt8(byte, currentPosition++);\n    };\n    /**\n     * @param {number} ui32 ui32\n     */\n\n\n    const writeU32 = ui32 => {\n      currentBuffer.writeUInt32LE(ui32, currentPosition);\n      currentPosition += 4;\n    };\n    /** @type {number[]} */\n\n\n    const measureStack = [];\n\n    const measureStart = () => {\n      measureStack.push(buffers.length, currentPosition);\n    };\n    /**\n     * @returns {number} size\n     */\n\n\n    const measureEnd = () => {\n      const oldPos = measureStack.pop();\n      const buffersIndex = measureStack.pop();\n      let size = currentPosition - oldPos;\n\n      for (let i = buffersIndex; i < buffers.length; i++) {\n        size += buffers[i].length;\n      }\n\n      return size;\n    };\n\n    for (let i = 0; i < data.length; i++) {\n      const thing = data[i];\n\n      switch (typeof thing) {\n        case \"function\":\n          {\n            if (!SerializerMiddleware.isLazy(thing)) throw new Error(\"Unexpected function \" + thing);\n            /** @type {SerializedType | (() => SerializedType)} */\n\n            let serializedData = SerializerMiddleware.getLazySerializedValue(thing);\n\n            if (serializedData === undefined) {\n              if (SerializerMiddleware.isLazy(thing, this)) {\n                flush();\n                allocationScope.leftOverBuffer = leftOverBuffer;\n                const result =\n                /** @type {(Exclude<PrimitiveSerializableType, Promise<PrimitiveSerializableType>>)[]} */\n                thing();\n\n                const data = this._serialize(result, context, allocationScope);\n\n                leftOverBuffer = allocationScope.leftOverBuffer;\n                allocationScope.leftOverBuffer = null;\n                SerializerMiddleware.setLazySerializedValue(thing, data);\n                serializedData = data;\n              } else {\n                serializedData = this._serializeLazy(thing, context);\n                flush();\n                buffers.push(serializedData);\n                break;\n              }\n            } else {\n              if (typeof serializedData === \"function\") {\n                flush();\n                buffers.push(serializedData);\n                break;\n              }\n            }\n            /** @type {number[]} */\n\n\n            const lengths = [];\n\n            for (const item of serializedData) {\n              let last;\n\n              if (typeof item === \"function\") {\n                lengths.push(0);\n              } else if (item.length === 0) {// ignore\n              } else if (lengths.length > 0 && (last = lengths[lengths.length - 1]) !== 0) {\n                const remaining = 0xffffffff - last;\n\n                if (remaining >= item.length) {\n                  lengths[lengths.length - 1] += item.length;\n                } else {\n                  lengths.push(item.length - remaining);\n                  lengths[lengths.length - 2] = 0xffffffff;\n                }\n              } else {\n                lengths.push(item.length);\n              }\n            }\n\n            allocate(5 + lengths.length * 4);\n            writeU8(LAZY_HEADER);\n            writeU32(lengths.length);\n\n            for (const l of lengths) {\n              writeU32(l);\n            }\n\n            flush();\n\n            for (const item of serializedData) {\n              buffers.push(item);\n            }\n\n            break;\n          }\n\n        case \"string\":\n          {\n            const len = Buffer.byteLength(thing);\n\n            if (len >= 128 || len !== thing.length) {\n              allocate(len + HEADER_SIZE + I32_SIZE);\n              writeU8(STRING_HEADER);\n              writeU32(len);\n              currentBuffer.write(thing, currentPosition);\n              currentPosition += len;\n            } else if (len >= 70) {\n              allocate(len + HEADER_SIZE);\n              writeU8(SHORT_STRING_HEADER | len);\n              currentBuffer.write(thing, currentPosition, \"latin1\");\n              currentPosition += len;\n            } else {\n              allocate(len + HEADER_SIZE);\n              writeU8(SHORT_STRING_HEADER | len);\n\n              for (let i = 0; i < len; i++) {\n                currentBuffer[currentPosition++] = thing.charCodeAt(i);\n              }\n            }\n\n            break;\n          }\n\n        case \"bigint\":\n          {\n            const type = identifyBigInt(thing);\n\n            if (type === 0 && thing >= 0 && thing <= BigInt(10)) {\n              // shortcut for very small bigints\n              allocate(HEADER_SIZE + I8_SIZE);\n              writeU8(BIGINT_I8_HEADER);\n              writeU8(Number(thing));\n              break;\n            }\n\n            switch (type) {\n              case 0:\n                {\n                  let n = 1;\n                  allocate(HEADER_SIZE + I8_SIZE * n);\n                  writeU8(BIGINT_I8_HEADER | n - 1);\n\n                  while (n > 0) {\n                    currentBuffer.writeInt8(Number(\n                    /** @type {bigint} */\n                    data[i]), currentPosition);\n                    currentPosition += I8_SIZE;\n                    n--;\n                    i++;\n                  }\n\n                  i--;\n                  break;\n                }\n\n              case 1:\n                {\n                  let n = 1;\n                  allocate(HEADER_SIZE + I32_SIZE * n);\n                  writeU8(BIGINT_I32_HEADER | n - 1);\n\n                  while (n > 0) {\n                    currentBuffer.writeInt32LE(Number(\n                    /** @type {bigint} */\n                    data[i]), currentPosition);\n                    currentPosition += I32_SIZE;\n                    n--;\n                    i++;\n                  }\n\n                  i--;\n                  break;\n                }\n\n              default:\n                {\n                  const value = thing.toString();\n                  const len = Buffer.byteLength(value);\n                  allocate(len + HEADER_SIZE + I32_SIZE);\n                  writeU8(BIGINT_HEADER);\n                  writeU32(len);\n                  currentBuffer.write(value, currentPosition);\n                  currentPosition += len;\n                  break;\n                }\n            }\n\n            break;\n          }\n\n        case \"number\":\n          {\n            const type = identifyNumber(thing);\n\n            if (type === 0 && thing >= 0 && thing <= 10) {\n              // shortcut for very small numbers\n              allocate(I8_SIZE);\n              writeU8(thing);\n              break;\n            }\n            /**\n             * amount of numbers to write\n             * @type {number}\n             */\n\n\n            let n = 1;\n\n            for (; n < 32 && i + n < data.length; n++) {\n              const item = data[i + n];\n              if (typeof item !== \"number\") break;\n              if (identifyNumber(item) !== type) break;\n            }\n\n            switch (type) {\n              case 0:\n                allocate(HEADER_SIZE + I8_SIZE * n);\n                writeU8(I8_HEADER | n - 1);\n\n                while (n > 0) {\n                  currentBuffer.writeInt8(\n                  /** @type {number} */\n                  data[i], currentPosition);\n                  currentPosition += I8_SIZE;\n                  n--;\n                  i++;\n                }\n\n                break;\n\n              case 1:\n                allocate(HEADER_SIZE + I32_SIZE * n);\n                writeU8(I32_HEADER | n - 1);\n\n                while (n > 0) {\n                  currentBuffer.writeInt32LE(\n                  /** @type {number} */\n                  data[i], currentPosition);\n                  currentPosition += I32_SIZE;\n                  n--;\n                  i++;\n                }\n\n                break;\n\n              case 2:\n                allocate(HEADER_SIZE + F64_SIZE * n);\n                writeU8(F64_HEADER | n - 1);\n\n                while (n > 0) {\n                  currentBuffer.writeDoubleLE(\n                  /** @type {number} */\n                  data[i], currentPosition);\n                  currentPosition += F64_SIZE;\n                  n--;\n                  i++;\n                }\n\n                break;\n            }\n\n            i--;\n            break;\n          }\n\n        case \"boolean\":\n          {\n            let lastByte = thing === true ? 1 : 0;\n            const bytes = [];\n            let count = 1;\n            let n;\n\n            for (n = 1; n < 0xffffffff && i + n < data.length; n++) {\n              const item = data[i + n];\n              if (typeof item !== \"boolean\") break;\n              const pos = count & 0x7;\n\n              if (pos === 0) {\n                bytes.push(lastByte);\n                lastByte = item === true ? 1 : 0;\n              } else if (item === true) {\n                lastByte |= 1 << pos;\n              }\n\n              count++;\n            }\n\n            i += count - 1;\n\n            if (count === 1) {\n              allocate(HEADER_SIZE);\n              writeU8(lastByte === 1 ? TRUE_HEADER : FALSE_HEADER);\n            } else if (count === 2) {\n              allocate(HEADER_SIZE * 2);\n              writeU8(lastByte & 1 ? TRUE_HEADER : FALSE_HEADER);\n              writeU8(lastByte & 2 ? TRUE_HEADER : FALSE_HEADER);\n            } else if (count <= 6) {\n              allocate(HEADER_SIZE + I8_SIZE);\n              writeU8(BOOLEANS_HEADER);\n              writeU8(1 << count | lastByte);\n            } else if (count <= 133) {\n              allocate(HEADER_SIZE + I8_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n              writeU8(BOOLEANS_HEADER);\n              writeU8(0x80 | count - 7);\n\n              for (const byte of bytes) writeU8(byte);\n\n              writeU8(lastByte);\n            } else {\n              allocate(HEADER_SIZE + I8_SIZE + I32_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n              writeU8(BOOLEANS_HEADER);\n              writeU8(0xff);\n              writeU32(count);\n\n              for (const byte of bytes) writeU8(byte);\n\n              writeU8(lastByte);\n            }\n\n            break;\n          }\n\n        case \"object\":\n          {\n            if (thing === null) {\n              let n;\n\n              for (n = 1; n < 0x100000104 && i + n < data.length; n++) {\n                const item = data[i + n];\n                if (item !== null) break;\n              }\n\n              i += n - 1;\n\n              if (n === 1) {\n                if (i + 1 < data.length) {\n                  const next = data[i + 1];\n\n                  if (next === true) {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_AND_TRUE_HEADER);\n                    i++;\n                  } else if (next === false) {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_AND_FALSE_HEADER);\n                    i++;\n                  } else if (typeof next === \"number\") {\n                    const type = identifyNumber(next);\n\n                    if (type === 0) {\n                      allocate(HEADER_SIZE + I8_SIZE);\n                      writeU8(NULL_AND_I8_HEADER);\n                      currentBuffer.writeInt8(next, currentPosition);\n                      currentPosition += I8_SIZE;\n                      i++;\n                    } else if (type === 1) {\n                      allocate(HEADER_SIZE + I32_SIZE);\n                      writeU8(NULL_AND_I32_HEADER);\n                      currentBuffer.writeInt32LE(next, currentPosition);\n                      currentPosition += I32_SIZE;\n                      i++;\n                    } else {\n                      allocate(HEADER_SIZE);\n                      writeU8(NULL_HEADER);\n                    }\n                  } else {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_HEADER);\n                  }\n                } else {\n                  allocate(HEADER_SIZE);\n                  writeU8(NULL_HEADER);\n                }\n              } else if (n === 2) {\n                allocate(HEADER_SIZE);\n                writeU8(NULL2_HEADER);\n              } else if (n === 3) {\n                allocate(HEADER_SIZE);\n                writeU8(NULL3_HEADER);\n              } else if (n < 260) {\n                allocate(HEADER_SIZE + I8_SIZE);\n                writeU8(NULLS8_HEADER);\n                writeU8(n - 4);\n              } else {\n                allocate(HEADER_SIZE + I32_SIZE);\n                writeU8(NULLS32_HEADER);\n                writeU32(n - 260);\n              }\n            } else if (Buffer.isBuffer(thing)) {\n              if (thing.length < 8192) {\n                allocate(HEADER_SIZE + I32_SIZE + thing.length);\n                writeU8(BUFFER_HEADER);\n                writeU32(thing.length);\n                thing.copy(currentBuffer, currentPosition);\n                currentPosition += thing.length;\n              } else {\n                allocate(HEADER_SIZE + I32_SIZE);\n                writeU8(BUFFER_HEADER);\n                writeU32(thing.length);\n                flush();\n                buffers.push(thing);\n              }\n            }\n\n            break;\n          }\n\n        case \"symbol\":\n          {\n            if (thing === MEASURE_START_OPERATION) {\n              measureStart();\n            } else if (thing === MEASURE_END_OPERATION) {\n              const size = measureEnd();\n              allocate(HEADER_SIZE + I32_SIZE);\n              writeU8(I32_HEADER);\n              currentBuffer.writeInt32LE(size, currentPosition);\n              currentPosition += I32_SIZE;\n            }\n\n            break;\n          }\n      }\n    }\n\n    flush();\n    allocationScope.leftOverBuffer = leftOverBuffer; // avoid leaking memory\n\n    currentBuffer = null;\n    leftOverBuffer = null;\n    allocationScope = undefined;\n    const _buffers = buffers;\n    buffers = undefined;\n    return _buffers;\n  }\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n\n\n  deserialize(data, context) {\n    return this._deserialize(data, context);\n  }\n\n  _createLazyDeserialized(content, context) {\n    return SerializerMiddleware.createLazy(memoize(() => this._deserialize(content, context)), this, undefined, content);\n  }\n\n  _deserializeLazy(fn, context) {\n    return SerializerMiddleware.deserializeLazy(fn, data => this._deserialize(data, context));\n  }\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType} deserialized data\n   */\n\n\n  _deserialize(data, context) {\n    let currentDataItem = 0;\n    let currentBuffer = data[0];\n    let currentIsBuffer = Buffer.isBuffer(currentBuffer);\n    let currentPosition = 0;\n\n    const retainedBuffer = context.retainedBuffer || (x => x);\n\n    const checkOverflow = () => {\n      if (currentPosition >= currentBuffer.length) {\n        currentPosition = 0;\n        currentDataItem++;\n        currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n        currentIsBuffer = Buffer.isBuffer(currentBuffer);\n      }\n    };\n\n    const isInCurrentBuffer = n => {\n      return currentIsBuffer && n + currentPosition <= currentBuffer.length;\n    };\n\n    const ensureBuffer = () => {\n      if (!currentIsBuffer) {\n        throw new Error(currentBuffer === null ? \"Unexpected end of stream\" : \"Unexpected lazy element in stream\");\n      }\n    };\n    /**\n     * Reads n bytes\n     * @param {number} n amount of bytes to read\n     * @returns {Buffer} buffer with bytes\n     */\n\n\n    const read = n => {\n      ensureBuffer();\n      const rem = currentBuffer.length - currentPosition;\n\n      if (rem < n) {\n        const buffers = [read(rem)];\n        n -= rem;\n        ensureBuffer();\n\n        while (currentBuffer.length < n) {\n          const b =\n          /** @type {Buffer} */\n          currentBuffer;\n          buffers.push(b);\n          n -= b.length;\n          currentDataItem++;\n          currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n          currentIsBuffer = Buffer.isBuffer(currentBuffer);\n          ensureBuffer();\n        }\n\n        buffers.push(read(n));\n        return Buffer.concat(buffers);\n      }\n\n      const b =\n      /** @type {Buffer} */\n      currentBuffer;\n      const res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n      currentPosition += n;\n      checkOverflow();\n      return res;\n    };\n    /**\n     * Reads up to n bytes\n     * @param {number} n amount of bytes to read\n     * @returns {Buffer} buffer with bytes\n     */\n\n\n    const readUpTo = n => {\n      ensureBuffer();\n      const rem = currentBuffer.length - currentPosition;\n\n      if (rem < n) {\n        n = rem;\n      }\n\n      const b =\n      /** @type {Buffer} */\n      currentBuffer;\n      const res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n      currentPosition += n;\n      checkOverflow();\n      return res;\n    };\n    /**\n     * @returns {number} U8\n     */\n\n\n    const readU8 = () => {\n      ensureBuffer();\n      /**\n       * There is no need to check remaining buffer size here\n       * since {@link checkOverflow} guarantees at least one byte remaining\n       */\n\n      const byte =\n      /** @type {Buffer} */\n      currentBuffer.readUInt8(currentPosition);\n      currentPosition += I8_SIZE;\n      checkOverflow();\n      return byte;\n    };\n    /**\n     * @returns {number} U32\n     */\n\n\n    const readU32 = () => {\n      return read(I32_SIZE).readUInt32LE(0);\n    };\n\n    const readBits = (data, n) => {\n      let mask = 1;\n\n      while (n !== 0) {\n        result.push((data & mask) !== 0);\n        mask = mask << 1;\n        n--;\n      }\n    };\n\n    const dispatchTable = Array.from({\n      length: 256\n    }).map((_, header) => {\n      switch (header) {\n        case LAZY_HEADER:\n          return () => {\n            const count = readU32();\n            const lengths = Array.from({\n              length: count\n            }).map(() => readU32());\n            const content = [];\n\n            for (let l of lengths) {\n              if (l === 0) {\n                if (typeof currentBuffer !== \"function\") {\n                  throw new Error(\"Unexpected non-lazy element in stream\");\n                }\n\n                content.push(currentBuffer);\n                currentDataItem++;\n                currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n                currentIsBuffer = Buffer.isBuffer(currentBuffer);\n              } else {\n                do {\n                  const buf = readUpTo(l);\n                  l -= buf.length;\n                  content.push(retainedBuffer(buf));\n                } while (l > 0);\n              }\n            }\n\n            result.push(this._createLazyDeserialized(content, context));\n          };\n\n        case BUFFER_HEADER:\n          return () => {\n            const len = readU32();\n            result.push(retainedBuffer(read(len)));\n          };\n\n        case TRUE_HEADER:\n          return () => result.push(true);\n\n        case FALSE_HEADER:\n          return () => result.push(false);\n\n        case NULL3_HEADER:\n          return () => result.push(null, null, null);\n\n        case NULL2_HEADER:\n          return () => result.push(null, null);\n\n        case NULL_HEADER:\n          return () => result.push(null);\n\n        case NULL_AND_TRUE_HEADER:\n          return () => result.push(null, true);\n\n        case NULL_AND_FALSE_HEADER:\n          return () => result.push(null, false);\n\n        case NULL_AND_I8_HEADER:\n          return () => {\n            if (currentIsBuffer) {\n              result.push(null,\n              /** @type {Buffer} */\n              currentBuffer.readInt8(currentPosition));\n              currentPosition += I8_SIZE;\n              checkOverflow();\n            } else {\n              result.push(null, read(I8_SIZE).readInt8(0));\n            }\n          };\n\n        case NULL_AND_I32_HEADER:\n          return () => {\n            result.push(null);\n\n            if (isInCurrentBuffer(I32_SIZE)) {\n              result.push(\n              /** @type {Buffer} */\n              currentBuffer.readInt32LE(currentPosition));\n              currentPosition += I32_SIZE;\n              checkOverflow();\n            } else {\n              result.push(read(I32_SIZE).readInt32LE(0));\n            }\n          };\n\n        case NULLS8_HEADER:\n          return () => {\n            const len = readU8() + 4;\n\n            for (let i = 0; i < len; i++) {\n              result.push(null);\n            }\n          };\n\n        case NULLS32_HEADER:\n          return () => {\n            const len = readU32() + 260;\n\n            for (let i = 0; i < len; i++) {\n              result.push(null);\n            }\n          };\n\n        case BOOLEANS_HEADER:\n          return () => {\n            const innerHeader = readU8();\n\n            if ((innerHeader & 0xf0) === 0) {\n              readBits(innerHeader, 3);\n            } else if ((innerHeader & 0xe0) === 0) {\n              readBits(innerHeader, 4);\n            } else if ((innerHeader & 0xc0) === 0) {\n              readBits(innerHeader, 5);\n            } else if ((innerHeader & 0x80) === 0) {\n              readBits(innerHeader, 6);\n            } else if (innerHeader !== 0xff) {\n              let count = (innerHeader & 0x7f) + 7;\n\n              while (count > 8) {\n                readBits(readU8(), 8);\n                count -= 8;\n              }\n\n              readBits(readU8(), count);\n            } else {\n              let count = readU32();\n\n              while (count > 8) {\n                readBits(readU8(), 8);\n                count -= 8;\n              }\n\n              readBits(readU8(), count);\n            }\n          };\n\n        case STRING_HEADER:\n          return () => {\n            const len = readU32();\n\n            if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n              result.push(currentBuffer.toString(undefined, currentPosition, currentPosition + len));\n              currentPosition += len;\n              checkOverflow();\n            } else {\n              result.push(read(len).toString());\n            }\n          };\n\n        case SHORT_STRING_HEADER:\n          return () => result.push(\"\");\n\n        case SHORT_STRING_HEADER | 1:\n          return () => {\n            if (currentIsBuffer && currentPosition < 0x7ffffffe) {\n              result.push(currentBuffer.toString(\"latin1\", currentPosition, currentPosition + 1));\n              currentPosition++;\n              checkOverflow();\n            } else {\n              result.push(read(1).toString(\"latin1\"));\n            }\n          };\n\n        case I8_HEADER:\n          return () => {\n            if (currentIsBuffer) {\n              result.push(\n              /** @type {Buffer} */\n              currentBuffer.readInt8(currentPosition));\n              currentPosition++;\n              checkOverflow();\n            } else {\n              result.push(read(1).readInt8(0));\n            }\n          };\n\n        case BIGINT_I8_HEADER:\n          {\n            const len = 1;\n            return () => {\n              const need = I8_SIZE * len;\n\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  const value =\n                  /** @type {Buffer} */\n                  currentBuffer.readInt8(currentPosition);\n                  result.push(BigInt(value));\n                  currentPosition += I8_SIZE;\n                }\n\n                checkOverflow();\n              } else {\n                const buf = read(need);\n\n                for (let i = 0; i < len; i++) {\n                  const value = buf.readInt8(i * I8_SIZE);\n                  result.push(BigInt(value));\n                }\n              }\n            };\n          }\n\n        case BIGINT_I32_HEADER:\n          {\n            const len = 1;\n            return () => {\n              const need = I32_SIZE * len;\n\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  const value =\n                  /** @type {Buffer} */\n                  currentBuffer.readInt32LE(currentPosition);\n                  result.push(BigInt(value));\n                  currentPosition += I32_SIZE;\n                }\n\n                checkOverflow();\n              } else {\n                const buf = read(need);\n\n                for (let i = 0; i < len; i++) {\n                  const value = buf.readInt32LE(i * I32_SIZE);\n                  result.push(BigInt(value));\n                }\n              }\n            };\n          }\n\n        case BIGINT_HEADER:\n          {\n            return () => {\n              const len = readU32();\n\n              if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n                const value = currentBuffer.toString(undefined, currentPosition, currentPosition + len);\n                result.push(BigInt(value));\n                currentPosition += len;\n                checkOverflow();\n              } else {\n                const value = read(len).toString();\n                result.push(BigInt(value));\n              }\n            };\n          }\n\n        default:\n          if (header <= 10) {\n            return () => result.push(header);\n          } else if ((header & SHORT_STRING_HEADER) === SHORT_STRING_HEADER) {\n            const len = header & SHORT_STRING_LENGTH_MASK;\n            return () => {\n              if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n                result.push(currentBuffer.toString(\"latin1\", currentPosition, currentPosition + len));\n                currentPosition += len;\n                checkOverflow();\n              } else {\n                result.push(read(len).toString(\"latin1\"));\n              }\n            };\n          } else if ((header & NUMBERS_HEADER_MASK) === F64_HEADER) {\n            const len = (header & NUMBERS_COUNT_MASK) + 1;\n            return () => {\n              const need = F64_SIZE * len;\n\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  result.push(\n                  /** @type {Buffer} */\n                  currentBuffer.readDoubleLE(currentPosition));\n                  currentPosition += F64_SIZE;\n                }\n\n                checkOverflow();\n              } else {\n                const buf = read(need);\n\n                for (let i = 0; i < len; i++) {\n                  result.push(buf.readDoubleLE(i * F64_SIZE));\n                }\n              }\n            };\n          } else if ((header & NUMBERS_HEADER_MASK) === I32_HEADER) {\n            const len = (header & NUMBERS_COUNT_MASK) + 1;\n            return () => {\n              const need = I32_SIZE * len;\n\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  result.push(\n                  /** @type {Buffer} */\n                  currentBuffer.readInt32LE(currentPosition));\n                  currentPosition += I32_SIZE;\n                }\n\n                checkOverflow();\n              } else {\n                const buf = read(need);\n\n                for (let i = 0; i < len; i++) {\n                  result.push(buf.readInt32LE(i * I32_SIZE));\n                }\n              }\n            };\n          } else if ((header & NUMBERS_HEADER_MASK) === I8_HEADER) {\n            const len = (header & NUMBERS_COUNT_MASK) + 1;\n            return () => {\n              const need = I8_SIZE * len;\n\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  result.push(\n                  /** @type {Buffer} */\n                  currentBuffer.readInt8(currentPosition));\n                  currentPosition += I8_SIZE;\n                }\n\n                checkOverflow();\n              } else {\n                const buf = read(need);\n\n                for (let i = 0; i < len; i++) {\n                  result.push(buf.readInt8(i * I8_SIZE));\n                }\n              }\n            };\n          } else {\n            return () => {\n              throw new Error(`Unexpected header byte 0x${header.toString(16)}`);\n            };\n          }\n\n      }\n    });\n    /** @type {DeserializedType} */\n\n    let result = [];\n\n    while (currentBuffer !== null) {\n      if (typeof currentBuffer === \"function\") {\n        result.push(this._deserializeLazy(currentBuffer, context));\n        currentDataItem++;\n        currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n        currentIsBuffer = Buffer.isBuffer(currentBuffer);\n      } else {\n        const header = readU8();\n        dispatchTable[header]();\n      }\n    } // avoid leaking memory in context\n\n\n    let _result = result;\n    result = undefined;\n    return _result;\n  }\n\n}\n\nmodule.exports = BinaryMiddleware;\nmodule.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION;\nmodule.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/serialization/BinaryMiddleware.js"],"names":["memoize","require","SerializerMiddleware","LAZY_HEADER","TRUE_HEADER","FALSE_HEADER","BOOLEANS_HEADER","NULL_HEADER","NULL2_HEADER","NULL3_HEADER","NULLS8_HEADER","NULLS32_HEADER","NULL_AND_I8_HEADER","NULL_AND_I32_HEADER","NULL_AND_TRUE_HEADER","NULL_AND_FALSE_HEADER","BIGINT_HEADER","BIGINT_I8_HEADER","BIGINT_I32_HEADER","STRING_HEADER","BUFFER_HEADER","I8_HEADER","I32_HEADER","F64_HEADER","SHORT_STRING_HEADER","NUMBERS_HEADER_MASK","NUMBERS_COUNT_MASK","SHORT_STRING_LENGTH_MASK","HEADER_SIZE","I8_SIZE","I32_SIZE","F64_SIZE","MEASURE_START_OPERATION","Symbol","MEASURE_END_OPERATION","identifyNumber","n","identifyBigInt","BigInt","BinaryMiddleware","serialize","data","context","_serialize","_serializeLazy","fn","serializeLazy","allocationScope","allocationSize","increaseCounter","leftOverBuffer","buffers","currentBuffer","currentPosition","Buffer","allocUnsafe","allocate","bytesNeeded","length","flush","Math","max","push","from","buffer","byteOffset","byteLength","writeU8","byte","writeUInt8","writeU32","ui32","writeUInt32LE","measureStack","measureStart","measureEnd","oldPos","pop","buffersIndex","size","i","thing","isLazy","Error","serializedData","getLazySerializedValue","undefined","result","setLazySerializedValue","lengths","item","last","remaining","l","len","write","charCodeAt","type","Number","writeInt8","writeInt32LE","value","toString","writeDoubleLE","lastByte","bytes","count","pos","next","isBuffer","copy","_buffers","deserialize","_deserialize","_createLazyDeserialized","content","createLazy","_deserializeLazy","deserializeLazy","currentDataItem","currentIsBuffer","retainedBuffer","x","checkOverflow","isInCurrentBuffer","ensureBuffer","read","rem","b","concat","res","readUpTo","readU8","readUInt8","readU32","readUInt32LE","readBits","mask","dispatchTable","Array","map","_","header","buf","readInt8","readInt32LE","innerHeader","need","readDoubleLE","_result","module","exports"],"mappings":"AAAA;AACA;AACA;AAEA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,wBAAD,CAApC;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAME,WAAW,GAAG,IAApB;AACA,MAAMC,WAAW,GAAG,IAApB;AACA,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,eAAe,GAAG,IAAxB;AACA,MAAMC,WAAW,GAAG,IAApB;AACA,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,aAAa,GAAG,IAAtB;AACA,MAAMC,cAAc,GAAG,IAAvB;AACA,MAAMC,kBAAkB,GAAG,IAA3B;AACA,MAAMC,mBAAmB,GAAG,IAA5B;AACA,MAAMC,oBAAoB,GAAG,IAA7B;AACA,MAAMC,qBAAqB,GAAG,IAA9B;AACA,MAAMC,aAAa,GAAG,IAAtB;AACA,MAAMC,gBAAgB,GAAG,IAAzB;AACA,MAAMC,iBAAiB,GAAG,IAA1B;AACA,MAAMC,aAAa,GAAG,IAAtB;AACA,MAAMC,aAAa,GAAG,IAAtB;AACA,MAAMC,SAAS,GAAG,IAAlB;AACA,MAAMC,UAAU,GAAG,IAAnB;AACA,MAAMC,UAAU,GAAG,IAAnB;AACA,MAAMC,mBAAmB,GAAG,IAA5B;AAEA;;AACA,MAAMC,mBAAmB,GAAG,IAA5B,C,CAAkC;;AAClC,MAAMC,kBAAkB,GAAG,IAA3B,C,CAAiC;;AACjC,MAAMC,wBAAwB,GAAG,IAAjC,C,CAAuC;;AAEvC,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,OAAO,GAAG,CAAhB;AACA,MAAMC,QAAQ,GAAG,CAAjB;AACA,MAAMC,QAAQ,GAAG,CAAjB;AAEA,MAAMC,uBAAuB,GAAGC,MAAM,CAAC,yBAAD,CAAtC;AACA,MAAMC,qBAAqB,GAAGD,MAAM,CAAC,uBAAD,CAApC;AAEA;;AACA;;AAEA;AACA;AACA;AACA;;AACA,MAAME,cAAc,GAAGC,CAAC,IAAI;AAC3B,MAAIA,CAAC,MAAMA,CAAC,GAAG,CAAV,CAAL,EAAmB;AAClB,QAAIA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,CAAC,GAAtB,EAA2B,OAAO,CAAP;AAC3B,QAAIA,CAAC,IAAI,UAAL,IAAmBA,CAAC,IAAI,CAAC,UAA7B,EAAyC,OAAO,CAAP;AACzC;;AACD,SAAO,CAAP;AACA,CAND;AAQA;AACA;AACA;AACA;;;AACA,MAAMC,cAAc,GAAGD,CAAC,IAAI;AAC3B,MAAIA,CAAC,IAAIE,MAAM,CAAC,GAAD,CAAX,IAAoBF,CAAC,IAAIE,MAAM,CAAC,CAAC,GAAF,CAAnC,EAA2C,OAAO,CAAP;AAC3C,MAAIF,CAAC,IAAIE,MAAM,CAAC,UAAD,CAAX,IAA2BF,CAAC,IAAIE,MAAM,CAAC,CAAC,UAAF,CAA1C,EAAyD,OAAO,CAAP;AACzD,SAAO,CAAP;AACA,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,gBAAN,SAA+BrC,oBAA/B,CAAoD;AACnD;AACD;AACA;AACA;AACA;AACCsC,EAAAA,SAAS,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACxB,WAAO,KAAKC,UAAL,CAAgBF,IAAhB,EAAsBC,OAAtB,CAAP;AACA;;AAEDE,EAAAA,cAAc,CAACC,EAAD,EAAKH,OAAL,EAAc;AAC3B,WAAOxC,oBAAoB,CAAC4C,aAArB,CAAmCD,EAAnC,EAAuCJ,IAAI,IACjD,KAAKE,UAAL,CAAgBF,IAAhB,EAAsBC,OAAtB,CADM,CAAP;AAGA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,UAAU,CACTF,IADS,EAETC,OAFS,EAQR;AAAA,QALDK,eAKC,uEALiB;AACjBC,MAAAA,cAAc,EAAE,IADC;AAEjBC,MAAAA,eAAe,EAAE,CAFA;AAGjBC,MAAAA,cAAc,EAAE;AAHC,KAKjB;;AACD;AACA,QAAIA,cAAc,GAAG,IAArB;AACA;;AACA,QAAIC,OAAO,GAAG,EAAd;AACA;;AACA,QAAIC,aAAa,GAAGL,eAAe,GAAGA,eAAe,CAACG,cAAnB,GAAoC,IAAvE;AACAH,IAAAA,eAAe,CAACG,cAAhB,GAAiC,IAAjC;AACA,QAAIG,eAAe,GAAG,CAAtB;;AACA,QAAID,aAAa,KAAK,IAAtB,EAA4B;AAC3BA,MAAAA,aAAa,GAAGE,MAAM,CAACC,WAAP,CAAmBR,eAAe,CAACC,cAAnC,CAAhB;AACA;;AACD,UAAMQ,QAAQ,GAAGC,WAAW,IAAI;AAC/B,UAAIL,aAAa,KAAK,IAAtB,EAA4B;AAC3B,YAAIA,aAAa,CAACM,MAAd,GAAuBL,eAAvB,IAA0CI,WAA9C,EAA2D;AAC3DE,QAAAA,KAAK;AACL;;AACD,UAAIT,cAAc,IAAIA,cAAc,CAACQ,MAAf,IAAyBD,WAA/C,EAA4D;AAC3DL,QAAAA,aAAa,GAAGF,cAAhB;AACAA,QAAAA,cAAc,GAAG,IAAjB;AACA,OAHD,MAGO;AACNE,QAAAA,aAAa,GAAGE,MAAM,CAACC,WAAP,CACfK,IAAI,CAACC,GAAL,CAASJ,WAAT,EAAsBV,eAAe,CAACC,cAAtC,CADe,CAAhB;;AAGA,YACC,EAAED,eAAe,CAACE,eAAhB,GACD,CAACF,eAAe,CAACE,eAAhB,GAAkC,CAAnC,IAAwC,CADzC,KAEAF,eAAe,CAACC,cAAhB,GAAiC,QAHlC,EAIE;AACDD,UAAAA,eAAe,CAACC,cAAhB,GAAiCD,eAAe,CAACC,cAAhB,IAAkC,CAAnE;AACA;AACD;AACD,KApBD;;AAqBA,UAAMW,KAAK,GAAG,MAAM;AACnB,UAAIP,aAAa,KAAK,IAAtB,EAA4B;AAC3B,YAAIC,eAAe,GAAG,CAAtB,EAAyB;AACxBF,UAAAA,OAAO,CAACW,IAAR,CACCR,MAAM,CAACS,IAAP,CACCX,aAAa,CAACY,MADf,EAECZ,aAAa,CAACa,UAFf,EAGCZ,eAHD,CADD;AAOA;;AACD,YACC,CAACH,cAAD,IACAA,cAAc,CAACQ,MAAf,GAAwBN,aAAa,CAACM,MAAd,GAAuBL,eAFhD,EAGE;AACDH,UAAAA,cAAc,GAAGI,MAAM,CAACS,IAAP,CAChBX,aAAa,CAACY,MADE,EAEhBZ,aAAa,CAACa,UAAd,GAA2BZ,eAFX,EAGhBD,aAAa,CAACc,UAAd,GAA2Bb,eAHX,CAAjB;AAKA;;AAEDD,QAAAA,aAAa,GAAG,IAAhB;AACAC,QAAAA,eAAe,GAAG,CAAlB;AACA;AACD,KAzBD;AA0BA;AACF;AACA;;;AACE,UAAMc,OAAO,GAAGC,IAAI,IAAI;AACvBhB,MAAAA,aAAa,CAACiB,UAAd,CAAyBD,IAAzB,EAA+Bf,eAAe,EAA9C;AACA,KAFD;AAGA;AACF;AACA;;;AACE,UAAMiB,QAAQ,GAAGC,IAAI,IAAI;AACxBnB,MAAAA,aAAa,CAACoB,aAAd,CAA4BD,IAA5B,EAAkClB,eAAlC;AACAA,MAAAA,eAAe,IAAI,CAAnB;AACA,KAHD;AAIA;;;AACA,UAAMoB,YAAY,GAAG,EAArB;;AACA,UAAMC,YAAY,GAAG,MAAM;AAC1BD,MAAAA,YAAY,CAACX,IAAb,CAAkBX,OAAO,CAACO,MAA1B,EAAkCL,eAAlC;AACA,KAFD;AAGA;AACF;AACA;;;AACE,UAAMsB,UAAU,GAAG,MAAM;AACxB,YAAMC,MAAM,GAAGH,YAAY,CAACI,GAAb,EAAf;AACA,YAAMC,YAAY,GAAGL,YAAY,CAACI,GAAb,EAArB;AACA,UAAIE,IAAI,GAAG1B,eAAe,GAAGuB,MAA7B;;AACA,WAAK,IAAII,CAAC,GAAGF,YAAb,EAA2BE,CAAC,GAAG7B,OAAO,CAACO,MAAvC,EAA+CsB,CAAC,EAAhD,EAAoD;AACnDD,QAAAA,IAAI,IAAI5B,OAAO,CAAC6B,CAAD,CAAP,CAAWtB,MAAnB;AACA;;AACD,aAAOqB,IAAP;AACA,KARD;;AASA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvC,IAAI,CAACiB,MAAzB,EAAiCsB,CAAC,EAAlC,EAAsC;AACrC,YAAMC,KAAK,GAAGxC,IAAI,CAACuC,CAAD,CAAlB;;AACA,cAAQ,OAAOC,KAAf;AACC,aAAK,UAAL;AAAiB;AAChB,gBAAI,CAAC/E,oBAAoB,CAACgF,MAArB,CAA4BD,KAA5B,CAAL,EACC,MAAM,IAAIE,KAAJ,CAAU,yBAAyBF,KAAnC,CAAN;AACD;;AACA,gBAAIG,cAAc,GACjBlF,oBAAoB,CAACmF,sBAArB,CAA4CJ,KAA5C,CADD;;AAEA,gBAAIG,cAAc,KAAKE,SAAvB,EAAkC;AACjC,kBAAIpF,oBAAoB,CAACgF,MAArB,CAA4BD,KAA5B,EAAmC,IAAnC,CAAJ,EAA8C;AAC7CtB,gBAAAA,KAAK;AACLZ,gBAAAA,eAAe,CAACG,cAAhB,GAAiCA,cAAjC;AACA,sBAAMqC,MAAM;AACX;AACCN,gBAAAA,KAAK,EAFP;;AAIA,sBAAMxC,IAAI,GAAG,KAAKE,UAAL,CAAgB4C,MAAhB,EAAwB7C,OAAxB,EAAiCK,eAAjC,CAAb;;AACAG,gBAAAA,cAAc,GAAGH,eAAe,CAACG,cAAjC;AACAH,gBAAAA,eAAe,CAACG,cAAhB,GAAiC,IAAjC;AACAhD,gBAAAA,oBAAoB,CAACsF,sBAArB,CAA4CP,KAA5C,EAAmDxC,IAAnD;AACA2C,gBAAAA,cAAc,GAAG3C,IAAjB;AACA,eAZD,MAYO;AACN2C,gBAAAA,cAAc,GAAG,KAAKxC,cAAL,CAAoBqC,KAApB,EAA2BvC,OAA3B,CAAjB;AACAiB,gBAAAA,KAAK;AACLR,gBAAAA,OAAO,CAACW,IAAR,CAAasB,cAAb;AACA;AACA;AACD,aAnBD,MAmBO;AACN,kBAAI,OAAOA,cAAP,KAA0B,UAA9B,EAA0C;AACzCzB,gBAAAA,KAAK;AACLR,gBAAAA,OAAO,CAACW,IAAR,CAAasB,cAAb;AACA;AACA;AACD;AACD;;;AACA,kBAAMK,OAAO,GAAG,EAAhB;;AACA,iBAAK,MAAMC,IAAX,IAAmBN,cAAnB,EAAmC;AAClC,kBAAIO,IAAJ;;AACA,kBAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC;AAC/BD,gBAAAA,OAAO,CAAC3B,IAAR,CAAa,CAAb;AACA,eAFD,MAEO,IAAI4B,IAAI,CAAChC,MAAL,KAAgB,CAApB,EAAuB,CAC7B;AACA,eAFM,MAEA,IACN+B,OAAO,CAAC/B,MAAR,GAAiB,CAAjB,IACA,CAACiC,IAAI,GAAGF,OAAO,CAACA,OAAO,CAAC/B,MAAR,GAAiB,CAAlB,CAAf,MAAyC,CAFnC,EAGL;AACD,sBAAMkC,SAAS,GAAG,aAAaD,IAA/B;;AACA,oBAAIC,SAAS,IAAIF,IAAI,CAAChC,MAAtB,EAA8B;AAC7B+B,kBAAAA,OAAO,CAACA,OAAO,CAAC/B,MAAR,GAAiB,CAAlB,CAAP,IAA+BgC,IAAI,CAAChC,MAApC;AACA,iBAFD,MAEO;AACN+B,kBAAAA,OAAO,CAAC3B,IAAR,CAAa4B,IAAI,CAAChC,MAAL,GAAckC,SAA3B;AACAH,kBAAAA,OAAO,CAACA,OAAO,CAAC/B,MAAR,GAAiB,CAAlB,CAAP,GAA8B,UAA9B;AACA;AACD,eAXM,MAWA;AACN+B,gBAAAA,OAAO,CAAC3B,IAAR,CAAa4B,IAAI,CAAChC,MAAlB;AACA;AACD;;AACDF,YAAAA,QAAQ,CAAC,IAAIiC,OAAO,CAAC/B,MAAR,GAAiB,CAAtB,CAAR;AACAS,YAAAA,OAAO,CAAChE,WAAD,CAAP;AACAmE,YAAAA,QAAQ,CAACmB,OAAO,CAAC/B,MAAT,CAAR;;AACA,iBAAK,MAAMmC,CAAX,IAAgBJ,OAAhB,EAAyB;AACxBnB,cAAAA,QAAQ,CAACuB,CAAD,CAAR;AACA;;AACDlC,YAAAA,KAAK;;AACL,iBAAK,MAAM+B,IAAX,IAAmBN,cAAnB,EAAmC;AAClCjC,cAAAA,OAAO,CAACW,IAAR,CAAa4B,IAAb;AACA;;AACD;AACA;;AACD,aAAK,QAAL;AAAe;AACd,kBAAMI,GAAG,GAAGxC,MAAM,CAACY,UAAP,CAAkBe,KAAlB,CAAZ;;AACA,gBAAIa,GAAG,IAAI,GAAP,IAAcA,GAAG,KAAKb,KAAK,CAACvB,MAAhC,EAAwC;AACvCF,cAAAA,QAAQ,CAACsC,GAAG,GAAGlE,WAAN,GAAoBE,QAArB,CAAR;AACAqC,cAAAA,OAAO,CAAChD,aAAD,CAAP;AACAmD,cAAAA,QAAQ,CAACwB,GAAD,CAAR;AACA1C,cAAAA,aAAa,CAAC2C,KAAd,CAAoBd,KAApB,EAA2B5B,eAA3B;AACAA,cAAAA,eAAe,IAAIyC,GAAnB;AACA,aAND,MAMO,IAAIA,GAAG,IAAI,EAAX,EAAe;AACrBtC,cAAAA,QAAQ,CAACsC,GAAG,GAAGlE,WAAP,CAAR;AACAuC,cAAAA,OAAO,CAAC3C,mBAAmB,GAAGsE,GAAvB,CAAP;AAEA1C,cAAAA,aAAa,CAAC2C,KAAd,CAAoBd,KAApB,EAA2B5B,eAA3B,EAA4C,QAA5C;AACAA,cAAAA,eAAe,IAAIyC,GAAnB;AACA,aANM,MAMA;AACNtC,cAAAA,QAAQ,CAACsC,GAAG,GAAGlE,WAAP,CAAR;AACAuC,cAAAA,OAAO,CAAC3C,mBAAmB,GAAGsE,GAAvB,CAAP;;AAEA,mBAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7B5B,gBAAAA,aAAa,CAACC,eAAe,EAAhB,CAAb,GAAmC4B,KAAK,CAACe,UAAN,CAAiBhB,CAAjB,CAAnC;AACA;AACD;;AACD;AACA;;AACD,aAAK,QAAL;AAAe;AACd,kBAAMiB,IAAI,GAAG5D,cAAc,CAAC4C,KAAD,CAA3B;;AACA,gBAAIgB,IAAI,KAAK,CAAT,IAAchB,KAAK,IAAI,CAAvB,IAA4BA,KAAK,IAAI3C,MAAM,CAAC,EAAD,CAA/C,EAAqD;AACpD;AACAkB,cAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAf,CAAR;AACAsC,cAAAA,OAAO,CAAClD,gBAAD,CAAP;AACAkD,cAAAA,OAAO,CAAC+B,MAAM,CAACjB,KAAD,CAAP,CAAP;AACA;AACA;;AAED,oBAAQgB,IAAR;AACC,mBAAK,CAAL;AAAQ;AACP,sBAAI7D,CAAC,GAAG,CAAR;AACAoB,kBAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAO,GAAGO,CAAzB,CAAR;AACA+B,kBAAAA,OAAO,CAAClD,gBAAgB,GAAImB,CAAC,GAAG,CAAzB,CAAP;;AACA,yBAAOA,CAAC,GAAG,CAAX,EAAc;AACbgB,oBAAAA,aAAa,CAAC+C,SAAd,CACCD,MAAM;AAAC;AAAuBzD,oBAAAA,IAAI,CAACuC,CAAD,CAA5B,CADP,EAEC3B,eAFD;AAIAA,oBAAAA,eAAe,IAAIxB,OAAnB;AACAO,oBAAAA,CAAC;AACD4C,oBAAAA,CAAC;AACD;;AACDA,kBAAAA,CAAC;AACD;AACA;;AACD,mBAAK,CAAL;AAAQ;AACP,sBAAI5C,CAAC,GAAG,CAAR;AACAoB,kBAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAQ,GAAGM,CAA1B,CAAR;AACA+B,kBAAAA,OAAO,CAACjD,iBAAiB,GAAIkB,CAAC,GAAG,CAA1B,CAAP;;AACA,yBAAOA,CAAC,GAAG,CAAX,EAAc;AACbgB,oBAAAA,aAAa,CAACgD,YAAd,CACCF,MAAM;AAAC;AAAuBzD,oBAAAA,IAAI,CAACuC,CAAD,CAA5B,CADP,EAEC3B,eAFD;AAIAA,oBAAAA,eAAe,IAAIvB,QAAnB;AACAM,oBAAAA,CAAC;AACD4C,oBAAAA,CAAC;AACD;;AACDA,kBAAAA,CAAC;AACD;AACA;;AACD;AAAS;AACR,wBAAMqB,KAAK,GAAGpB,KAAK,CAACqB,QAAN,EAAd;AACA,wBAAMR,GAAG,GAAGxC,MAAM,CAACY,UAAP,CAAkBmC,KAAlB,CAAZ;AACA7C,kBAAAA,QAAQ,CAACsC,GAAG,GAAGlE,WAAN,GAAoBE,QAArB,CAAR;AACAqC,kBAAAA,OAAO,CAACnD,aAAD,CAAP;AACAsD,kBAAAA,QAAQ,CAACwB,GAAD,CAAR;AACA1C,kBAAAA,aAAa,CAAC2C,KAAd,CAAoBM,KAApB,EAA2BhD,eAA3B;AACAA,kBAAAA,eAAe,IAAIyC,GAAnB;AACA;AACA;AA1CF;;AA4CA;AACA;;AACD,aAAK,QAAL;AAAe;AACd,kBAAMG,IAAI,GAAG9D,cAAc,CAAC8C,KAAD,CAA3B;;AACA,gBAAIgB,IAAI,KAAK,CAAT,IAAchB,KAAK,IAAI,CAAvB,IAA4BA,KAAK,IAAI,EAAzC,EAA6C;AAC5C;AACAzB,cAAAA,QAAQ,CAAC3B,OAAD,CAAR;AACAsC,cAAAA,OAAO,CAACc,KAAD,CAAP;AACA;AACA;AACD;AACL;AACA;AACA;;;AACK,gBAAI7C,CAAC,GAAG,CAAR;;AACA,mBAAOA,CAAC,GAAG,EAAJ,IAAU4C,CAAC,GAAG5C,CAAJ,GAAQK,IAAI,CAACiB,MAA9B,EAAsCtB,CAAC,EAAvC,EAA2C;AAC1C,oBAAMsD,IAAI,GAAGjD,IAAI,CAACuC,CAAC,GAAG5C,CAAL,CAAjB;AACA,kBAAI,OAAOsD,IAAP,KAAgB,QAApB,EAA8B;AAC9B,kBAAIvD,cAAc,CAACuD,IAAD,CAAd,KAAyBO,IAA7B,EAAmC;AACnC;;AACD,oBAAQA,IAAR;AACC,mBAAK,CAAL;AACCzC,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAO,GAAGO,CAAzB,CAAR;AACA+B,gBAAAA,OAAO,CAAC9C,SAAS,GAAIe,CAAC,GAAG,CAAlB,CAAP;;AACA,uBAAOA,CAAC,GAAG,CAAX,EAAc;AACbgB,kBAAAA,aAAa,CAAC+C,SAAd;AACC;AAAuB1D,kBAAAA,IAAI,CAACuC,CAAD,CAD5B,EAEC3B,eAFD;AAIAA,kBAAAA,eAAe,IAAIxB,OAAnB;AACAO,kBAAAA,CAAC;AACD4C,kBAAAA,CAAC;AACD;;AACD;;AACD,mBAAK,CAAL;AACCxB,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAQ,GAAGM,CAA1B,CAAR;AACA+B,gBAAAA,OAAO,CAAC7C,UAAU,GAAIc,CAAC,GAAG,CAAnB,CAAP;;AACA,uBAAOA,CAAC,GAAG,CAAX,EAAc;AACbgB,kBAAAA,aAAa,CAACgD,YAAd;AACC;AAAuB3D,kBAAAA,IAAI,CAACuC,CAAD,CAD5B,EAEC3B,eAFD;AAIAA,kBAAAA,eAAe,IAAIvB,QAAnB;AACAM,kBAAAA,CAAC;AACD4C,kBAAAA,CAAC;AACD;;AACD;;AACD,mBAAK,CAAL;AACCxB,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGG,QAAQ,GAAGK,CAA1B,CAAR;AACA+B,gBAAAA,OAAO,CAAC5C,UAAU,GAAIa,CAAC,GAAG,CAAnB,CAAP;;AACA,uBAAOA,CAAC,GAAG,CAAX,EAAc;AACbgB,kBAAAA,aAAa,CAACmD,aAAd;AACC;AAAuB9D,kBAAAA,IAAI,CAACuC,CAAD,CAD5B,EAEC3B,eAFD;AAIAA,kBAAAA,eAAe,IAAItB,QAAnB;AACAK,kBAAAA,CAAC;AACD4C,kBAAAA,CAAC;AACD;;AACD;AAvCF;;AA0CAA,YAAAA,CAAC;AACD;AACA;;AACD,aAAK,SAAL;AAAgB;AACf,gBAAIwB,QAAQ,GAAGvB,KAAK,KAAK,IAAV,GAAiB,CAAjB,GAAqB,CAApC;AACA,kBAAMwB,KAAK,GAAG,EAAd;AACA,gBAAIC,KAAK,GAAG,CAAZ;AACA,gBAAItE,CAAJ;;AACA,iBAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,UAAJ,IAAkB4C,CAAC,GAAG5C,CAAJ,GAAQK,IAAI,CAACiB,MAA3C,EAAmDtB,CAAC,EAApD,EAAwD;AACvD,oBAAMsD,IAAI,GAAGjD,IAAI,CAACuC,CAAC,GAAG5C,CAAL,CAAjB;AACA,kBAAI,OAAOsD,IAAP,KAAgB,SAApB,EAA+B;AAC/B,oBAAMiB,GAAG,GAAGD,KAAK,GAAG,GAApB;;AACA,kBAAIC,GAAG,KAAK,CAAZ,EAAe;AACdF,gBAAAA,KAAK,CAAC3C,IAAN,CAAW0C,QAAX;AACAA,gBAAAA,QAAQ,GAAGd,IAAI,KAAK,IAAT,GAAgB,CAAhB,GAAoB,CAA/B;AACA,eAHD,MAGO,IAAIA,IAAI,KAAK,IAAb,EAAmB;AACzBc,gBAAAA,QAAQ,IAAI,KAAKG,GAAjB;AACA;;AACDD,cAAAA,KAAK;AACL;;AACD1B,YAAAA,CAAC,IAAI0B,KAAK,GAAG,CAAb;;AACA,gBAAIA,KAAK,KAAK,CAAd,EAAiB;AAChBlD,cAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,cAAAA,OAAO,CAACqC,QAAQ,KAAK,CAAb,GAAiBpG,WAAjB,GAA+BC,YAAhC,CAAP;AACA,aAHD,MAGO,IAAIqG,KAAK,KAAK,CAAd,EAAiB;AACvBlD,cAAAA,QAAQ,CAAC5B,WAAW,GAAG,CAAf,CAAR;AACAuC,cAAAA,OAAO,CAACqC,QAAQ,GAAG,CAAX,GAAepG,WAAf,GAA6BC,YAA9B,CAAP;AACA8D,cAAAA,OAAO,CAACqC,QAAQ,GAAG,CAAX,GAAepG,WAAf,GAA6BC,YAA9B,CAAP;AACA,aAJM,MAIA,IAAIqG,KAAK,IAAI,CAAb,EAAgB;AACtBlD,cAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAf,CAAR;AACAsC,cAAAA,OAAO,CAAC7D,eAAD,CAAP;AACA6D,cAAAA,OAAO,CAAE,KAAKuC,KAAN,GAAeF,QAAhB,CAAP;AACA,aAJM,MAIA,IAAIE,KAAK,IAAI,GAAb,EAAkB;AACxBlD,cAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAd,GAAwBA,OAAO,GAAG4E,KAAK,CAAC/C,MAAxC,GAAiD7B,OAAlD,CAAR;AACAsC,cAAAA,OAAO,CAAC7D,eAAD,CAAP;AACA6D,cAAAA,OAAO,CAAC,OAAQuC,KAAK,GAAG,CAAjB,CAAP;;AACA,mBAAK,MAAMtC,IAAX,IAAmBqC,KAAnB,EAA0BtC,OAAO,CAACC,IAAD,CAAP;;AAC1BD,cAAAA,OAAO,CAACqC,QAAD,CAAP;AACA,aANM,MAMA;AACNhD,cAAAA,QAAQ,CACP5B,WAAW,GACVC,OADD,GAECC,QAFD,GAGCD,OAAO,GAAG4E,KAAK,CAAC/C,MAHjB,GAIC7B,OALM,CAAR;AAOAsC,cAAAA,OAAO,CAAC7D,eAAD,CAAP;AACA6D,cAAAA,OAAO,CAAC,IAAD,CAAP;AACAG,cAAAA,QAAQ,CAACoC,KAAD,CAAR;;AACA,mBAAK,MAAMtC,IAAX,IAAmBqC,KAAnB,EAA0BtC,OAAO,CAACC,IAAD,CAAP;;AAC1BD,cAAAA,OAAO,CAACqC,QAAD,CAAP;AACA;;AACD;AACA;;AACD,aAAK,QAAL;AAAe;AACd,gBAAIvB,KAAK,KAAK,IAAd,EAAoB;AACnB,kBAAI7C,CAAJ;;AACA,mBAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,WAAJ,IAAmB4C,CAAC,GAAG5C,CAAJ,GAAQK,IAAI,CAACiB,MAA5C,EAAoDtB,CAAC,EAArD,EAAyD;AACxD,sBAAMsD,IAAI,GAAGjD,IAAI,CAACuC,CAAC,GAAG5C,CAAL,CAAjB;AACA,oBAAIsD,IAAI,KAAK,IAAb,EAAmB;AACnB;;AACDV,cAAAA,CAAC,IAAI5C,CAAC,GAAG,CAAT;;AACA,kBAAIA,CAAC,KAAK,CAAV,EAAa;AACZ,oBAAI4C,CAAC,GAAG,CAAJ,GAAQvC,IAAI,CAACiB,MAAjB,EAAyB;AACxB,wBAAMkD,IAAI,GAAGnE,IAAI,CAACuC,CAAC,GAAG,CAAL,CAAjB;;AACA,sBAAI4B,IAAI,KAAK,IAAb,EAAmB;AAClBpD,oBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,oBAAAA,OAAO,CAACrD,oBAAD,CAAP;AACAkE,oBAAAA,CAAC;AACD,mBAJD,MAIO,IAAI4B,IAAI,KAAK,KAAb,EAAoB;AAC1BpD,oBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,oBAAAA,OAAO,CAACpD,qBAAD,CAAP;AACAiE,oBAAAA,CAAC;AACD,mBAJM,MAIA,IAAI,OAAO4B,IAAP,KAAgB,QAApB,EAA8B;AACpC,0BAAMX,IAAI,GAAG9D,cAAc,CAACyE,IAAD,CAA3B;;AACA,wBAAIX,IAAI,KAAK,CAAb,EAAgB;AACfzC,sBAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAf,CAAR;AACAsC,sBAAAA,OAAO,CAACvD,kBAAD,CAAP;AACAwC,sBAAAA,aAAa,CAAC+C,SAAd,CAAwBS,IAAxB,EAA8BvD,eAA9B;AACAA,sBAAAA,eAAe,IAAIxB,OAAnB;AACAmD,sBAAAA,CAAC;AACD,qBAND,MAMO,IAAIiB,IAAI,KAAK,CAAb,EAAgB;AACtBzC,sBAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAf,CAAR;AACAqC,sBAAAA,OAAO,CAACtD,mBAAD,CAAP;AACAuC,sBAAAA,aAAa,CAACgD,YAAd,CAA2BQ,IAA3B,EAAiCvD,eAAjC;AACAA,sBAAAA,eAAe,IAAIvB,QAAnB;AACAkD,sBAAAA,CAAC;AACD,qBANM,MAMA;AACNxB,sBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,sBAAAA,OAAO,CAAC5D,WAAD,CAAP;AACA;AACD,mBAlBM,MAkBA;AACNiD,oBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,oBAAAA,OAAO,CAAC5D,WAAD,CAAP;AACA;AACD,iBAhCD,MAgCO;AACNiD,kBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,kBAAAA,OAAO,CAAC5D,WAAD,CAAP;AACA;AACD,eArCD,MAqCO,IAAI6B,CAAC,KAAK,CAAV,EAAa;AACnBoB,gBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,gBAAAA,OAAO,CAAC3D,YAAD,CAAP;AACA,eAHM,MAGA,IAAI4B,CAAC,KAAK,CAAV,EAAa;AACnBoB,gBAAAA,QAAQ,CAAC5B,WAAD,CAAR;AACAuC,gBAAAA,OAAO,CAAC1D,YAAD,CAAP;AACA,eAHM,MAGA,IAAI2B,CAAC,GAAG,GAAR,EAAa;AACnBoB,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGC,OAAf,CAAR;AACAsC,gBAAAA,OAAO,CAACzD,aAAD,CAAP;AACAyD,gBAAAA,OAAO,CAAC/B,CAAC,GAAG,CAAL,CAAP;AACA,eAJM,MAIA;AACNoB,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAf,CAAR;AACAqC,gBAAAA,OAAO,CAACxD,cAAD,CAAP;AACA2D,gBAAAA,QAAQ,CAAClC,CAAC,GAAG,GAAL,CAAR;AACA;AACD,aA3DD,MA2DO,IAAIkB,MAAM,CAACuD,QAAP,CAAgB5B,KAAhB,CAAJ,EAA4B;AAClC,kBAAIA,KAAK,CAACvB,MAAN,GAAe,IAAnB,EAAyB;AACxBF,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAd,GAAyBmD,KAAK,CAACvB,MAAhC,CAAR;AACAS,gBAAAA,OAAO,CAAC/C,aAAD,CAAP;AACAkD,gBAAAA,QAAQ,CAACW,KAAK,CAACvB,MAAP,CAAR;AACAuB,gBAAAA,KAAK,CAAC6B,IAAN,CAAW1D,aAAX,EAA0BC,eAA1B;AACAA,gBAAAA,eAAe,IAAI4B,KAAK,CAACvB,MAAzB;AACA,eAND,MAMO;AACNF,gBAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAf,CAAR;AACAqC,gBAAAA,OAAO,CAAC/C,aAAD,CAAP;AACAkD,gBAAAA,QAAQ,CAACW,KAAK,CAACvB,MAAP,CAAR;AACAC,gBAAAA,KAAK;AACLR,gBAAAA,OAAO,CAACW,IAAR,CAAamB,KAAb;AACA;AACD;;AACD;AACA;;AACD,aAAK,QAAL;AAAe;AACd,gBAAIA,KAAK,KAAKjD,uBAAd,EAAuC;AACtC0C,cAAAA,YAAY;AACZ,aAFD,MAEO,IAAIO,KAAK,KAAK/C,qBAAd,EAAqC;AAC3C,oBAAM6C,IAAI,GAAGJ,UAAU,EAAvB;AACAnB,cAAAA,QAAQ,CAAC5B,WAAW,GAAGE,QAAf,CAAR;AACAqC,cAAAA,OAAO,CAAC7C,UAAD,CAAP;AACA8B,cAAAA,aAAa,CAACgD,YAAd,CAA2BrB,IAA3B,EAAiC1B,eAAjC;AACAA,cAAAA,eAAe,IAAIvB,QAAnB;AACA;;AACD;AACA;AA9VF;AAgWA;;AACD6B,IAAAA,KAAK;AAELZ,IAAAA,eAAe,CAACG,cAAhB,GAAiCA,cAAjC,CA9bC,CAgcD;;AACAE,IAAAA,aAAa,GAAG,IAAhB;AACAF,IAAAA,cAAc,GAAG,IAAjB;AACAH,IAAAA,eAAe,GAAGuC,SAAlB;AACA,UAAMyB,QAAQ,GAAG5D,OAAjB;AACAA,IAAAA,OAAO,GAAGmC,SAAV;AACA,WAAOyB,QAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,WAAW,CAACvE,IAAD,EAAOC,OAAP,EAAgB;AAC1B,WAAO,KAAKuE,YAAL,CAAkBxE,IAAlB,EAAwBC,OAAxB,CAAP;AACA;;AAEDwE,EAAAA,uBAAuB,CAACC,OAAD,EAAUzE,OAAV,EAAmB;AACzC,WAAOxC,oBAAoB,CAACkH,UAArB,CACNpH,OAAO,CAAC,MAAM,KAAKiH,YAAL,CAAkBE,OAAlB,EAA2BzE,OAA3B,CAAP,CADD,EAEN,IAFM,EAGN4C,SAHM,EAIN6B,OAJM,CAAP;AAMA;;AAEDE,EAAAA,gBAAgB,CAACxE,EAAD,EAAKH,OAAL,EAAc;AAC7B,WAAOxC,oBAAoB,CAACoH,eAArB,CAAqCzE,EAArC,EAAyCJ,IAAI,IACnD,KAAKwE,YAAL,CAAkBxE,IAAlB,EAAwBC,OAAxB,CADM,CAAP;AAGA;AAED;AACD;AACA;AACA;AACA;;;AACCuE,EAAAA,YAAY,CAACxE,IAAD,EAAOC,OAAP,EAAgB;AAC3B,QAAI6E,eAAe,GAAG,CAAtB;AACA,QAAInE,aAAa,GAAGX,IAAI,CAAC,CAAD,CAAxB;AACA,QAAI+E,eAAe,GAAGlE,MAAM,CAACuD,QAAP,CAAgBzD,aAAhB,CAAtB;AACA,QAAIC,eAAe,GAAG,CAAtB;;AAEA,UAAMoE,cAAc,GAAG/E,OAAO,CAAC+E,cAAR,KAA2BC,CAAC,IAAIA,CAAhC,CAAvB;;AAEA,UAAMC,aAAa,GAAG,MAAM;AAC3B,UAAItE,eAAe,IAAID,aAAa,CAACM,MAArC,EAA6C;AAC5CL,QAAAA,eAAe,GAAG,CAAlB;AACAkE,QAAAA,eAAe;AACfnE,QAAAA,aAAa,GACZmE,eAAe,GAAG9E,IAAI,CAACiB,MAAvB,GAAgCjB,IAAI,CAAC8E,eAAD,CAApC,GAAwD,IADzD;AAEAC,QAAAA,eAAe,GAAGlE,MAAM,CAACuD,QAAP,CAAgBzD,aAAhB,CAAlB;AACA;AACD,KARD;;AASA,UAAMwE,iBAAiB,GAAGxF,CAAC,IAAI;AAC9B,aAAOoF,eAAe,IAAIpF,CAAC,GAAGiB,eAAJ,IAAuBD,aAAa,CAACM,MAA/D;AACA,KAFD;;AAGA,UAAMmE,YAAY,GAAG,MAAM;AAC1B,UAAI,CAACL,eAAL,EAAsB;AACrB,cAAM,IAAIrC,KAAJ,CACL/B,aAAa,KAAK,IAAlB,GACG,0BADH,GAEG,mCAHE,CAAN;AAKA;AACD,KARD;AASA;AACF;AACA;AACA;AACA;;;AACE,UAAM0E,IAAI,GAAG1F,CAAC,IAAI;AACjByF,MAAAA,YAAY;AACZ,YAAME,GAAG,GAAG3E,aAAa,CAACM,MAAd,GAAuBL,eAAnC;;AACA,UAAI0E,GAAG,GAAG3F,CAAV,EAAa;AACZ,cAAMe,OAAO,GAAG,CAAC2E,IAAI,CAACC,GAAD,CAAL,CAAhB;AACA3F,QAAAA,CAAC,IAAI2F,GAAL;AACAF,QAAAA,YAAY;;AACZ,eAAOzE,aAAa,CAACM,MAAd,GAAuBtB,CAA9B,EAAiC;AAChC,gBAAM4F,CAAC;AAAG;AAAuB5E,UAAAA,aAAjC;AACAD,UAAAA,OAAO,CAACW,IAAR,CAAakE,CAAb;AACA5F,UAAAA,CAAC,IAAI4F,CAAC,CAACtE,MAAP;AACA6D,UAAAA,eAAe;AACfnE,UAAAA,aAAa,GACZmE,eAAe,GAAG9E,IAAI,CAACiB,MAAvB,GAAgCjB,IAAI,CAAC8E,eAAD,CAApC,GAAwD,IADzD;AAEAC,UAAAA,eAAe,GAAGlE,MAAM,CAACuD,QAAP,CAAgBzD,aAAhB,CAAlB;AACAyE,UAAAA,YAAY;AACZ;;AACD1E,QAAAA,OAAO,CAACW,IAAR,CAAagE,IAAI,CAAC1F,CAAD,CAAjB;AACA,eAAOkB,MAAM,CAAC2E,MAAP,CAAc9E,OAAd,CAAP;AACA;;AACD,YAAM6E,CAAC;AAAG;AAAuB5E,MAAAA,aAAjC;AACA,YAAM8E,GAAG,GAAG5E,MAAM,CAACS,IAAP,CAAYiE,CAAC,CAAChE,MAAd,EAAsBgE,CAAC,CAAC/D,UAAF,GAAeZ,eAArC,EAAsDjB,CAAtD,CAAZ;AACAiB,MAAAA,eAAe,IAAIjB,CAAnB;AACAuF,MAAAA,aAAa;AACb,aAAOO,GAAP;AACA,KAzBD;AA0BA;AACF;AACA;AACA;AACA;;;AACE,UAAMC,QAAQ,GAAG/F,CAAC,IAAI;AACrByF,MAAAA,YAAY;AACZ,YAAME,GAAG,GAAG3E,aAAa,CAACM,MAAd,GAAuBL,eAAnC;;AACA,UAAI0E,GAAG,GAAG3F,CAAV,EAAa;AACZA,QAAAA,CAAC,GAAG2F,GAAJ;AACA;;AACD,YAAMC,CAAC;AAAG;AAAuB5E,MAAAA,aAAjC;AACA,YAAM8E,GAAG,GAAG5E,MAAM,CAACS,IAAP,CAAYiE,CAAC,CAAChE,MAAd,EAAsBgE,CAAC,CAAC/D,UAAF,GAAeZ,eAArC,EAAsDjB,CAAtD,CAAZ;AACAiB,MAAAA,eAAe,IAAIjB,CAAnB;AACAuF,MAAAA,aAAa;AACb,aAAOO,GAAP;AACA,KAXD;AAYA;AACF;AACA;;;AACE,UAAME,MAAM,GAAG,MAAM;AACpBP,MAAAA,YAAY;AACZ;AACH;AACA;AACA;;AACG,YAAMzD,IAAI;AAAG;AAAuBhB,MAAAA,aAAD,CAAgBiF,SAAhB,CAClChF,eADkC,CAAnC;AAGAA,MAAAA,eAAe,IAAIxB,OAAnB;AACA8F,MAAAA,aAAa;AACb,aAAOvD,IAAP;AACA,KAZD;AAaA;AACF;AACA;;;AACE,UAAMkE,OAAO,GAAG,MAAM;AACrB,aAAOR,IAAI,CAAChG,QAAD,CAAJ,CAAeyG,YAAf,CAA4B,CAA5B,CAAP;AACA,KAFD;;AAGA,UAAMC,QAAQ,GAAG,CAAC/F,IAAD,EAAOL,CAAP,KAAa;AAC7B,UAAIqG,IAAI,GAAG,CAAX;;AACA,aAAOrG,CAAC,KAAK,CAAb,EAAgB;AACfmD,QAAAA,MAAM,CAACzB,IAAP,CAAY,CAACrB,IAAI,GAAGgG,IAAR,MAAkB,CAA9B;AACAA,QAAAA,IAAI,GAAGA,IAAI,IAAI,CAAf;AACArG,QAAAA,CAAC;AACD;AACD,KAPD;;AAQA,UAAMsG,aAAa,GAAGC,KAAK,CAAC5E,IAAN,CAAW;AAAEL,MAAAA,MAAM,EAAE;AAAV,KAAX,EAA4BkF,GAA5B,CAAgC,CAACC,CAAD,EAAIC,MAAJ,KAAe;AACpE,cAAQA,MAAR;AACC,aAAK3I,WAAL;AACC,iBAAO,MAAM;AACZ,kBAAMuG,KAAK,GAAG4B,OAAO,EAArB;AACA,kBAAM7C,OAAO,GAAGkD,KAAK,CAAC5E,IAAN,CAAW;AAAEL,cAAAA,MAAM,EAAEgD;AAAV,aAAX,EAA8BkC,GAA9B,CAAkC,MAAMN,OAAO,EAA/C,CAAhB;AACA,kBAAMnB,OAAO,GAAG,EAAhB;;AACA,iBAAK,IAAItB,CAAT,IAAcJ,OAAd,EAAuB;AACtB,kBAAII,CAAC,KAAK,CAAV,EAAa;AACZ,oBAAI,OAAOzC,aAAP,KAAyB,UAA7B,EAAyC;AACxC,wBAAM,IAAI+B,KAAJ,CAAU,uCAAV,CAAN;AACA;;AACDgC,gBAAAA,OAAO,CAACrD,IAAR,CAAaV,aAAb;AACAmE,gBAAAA,eAAe;AACfnE,gBAAAA,aAAa,GACZmE,eAAe,GAAG9E,IAAI,CAACiB,MAAvB,GAAgCjB,IAAI,CAAC8E,eAAD,CAApC,GAAwD,IADzD;AAEAC,gBAAAA,eAAe,GAAGlE,MAAM,CAACuD,QAAP,CAAgBzD,aAAhB,CAAlB;AACA,eATD,MASO;AACN,mBAAG;AACF,wBAAM2F,GAAG,GAAGZ,QAAQ,CAACtC,CAAD,CAApB;AACAA,kBAAAA,CAAC,IAAIkD,GAAG,CAACrF,MAAT;AACAyD,kBAAAA,OAAO,CAACrD,IAAR,CAAa2D,cAAc,CAACsB,GAAD,CAA3B;AACA,iBAJD,QAISlD,CAAC,GAAG,CAJb;AAKA;AACD;;AACDN,YAAAA,MAAM,CAACzB,IAAP,CAAY,KAAKoD,uBAAL,CAA6BC,OAA7B,EAAsCzE,OAAtC,CAAZ;AACA,WAvBD;;AAwBD,aAAKtB,aAAL;AACC,iBAAO,MAAM;AACZ,kBAAM0E,GAAG,GAAGwC,OAAO,EAAnB;AACA/C,YAAAA,MAAM,CAACzB,IAAP,CAAY2D,cAAc,CAACK,IAAI,CAAChC,GAAD,CAAL,CAA1B;AACA,WAHD;;AAID,aAAK1F,WAAL;AACC,iBAAO,MAAMmF,MAAM,CAACzB,IAAP,CAAY,IAAZ,CAAb;;AACD,aAAKzD,YAAL;AACC,iBAAO,MAAMkF,MAAM,CAACzB,IAAP,CAAY,KAAZ,CAAb;;AACD,aAAKrD,YAAL;AACC,iBAAO,MAAM8E,MAAM,CAACzB,IAAP,CAAY,IAAZ,EAAkB,IAAlB,EAAwB,IAAxB,CAAb;;AACD,aAAKtD,YAAL;AACC,iBAAO,MAAM+E,MAAM,CAACzB,IAAP,CAAY,IAAZ,EAAkB,IAAlB,CAAb;;AACD,aAAKvD,WAAL;AACC,iBAAO,MAAMgF,MAAM,CAACzB,IAAP,CAAY,IAAZ,CAAb;;AACD,aAAKhD,oBAAL;AACC,iBAAO,MAAMyE,MAAM,CAACzB,IAAP,CAAY,IAAZ,EAAkB,IAAlB,CAAb;;AACD,aAAK/C,qBAAL;AACC,iBAAO,MAAMwE,MAAM,CAACzB,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAb;;AACD,aAAKlD,kBAAL;AACC,iBAAO,MAAM;AACZ,gBAAI4G,eAAJ,EAAqB;AACpBjC,cAAAA,MAAM,CAACzB,IAAP,CACC,IADD;AAEC;AAAuBV,cAAAA,aAAD,CAAgB4F,QAAhB,CAAyB3F,eAAzB,CAFvB;AAIAA,cAAAA,eAAe,IAAIxB,OAAnB;AACA8F,cAAAA,aAAa;AACb,aAPD,MAOO;AACNpC,cAAAA,MAAM,CAACzB,IAAP,CAAY,IAAZ,EAAkBgE,IAAI,CAACjG,OAAD,CAAJ,CAAcmH,QAAd,CAAuB,CAAvB,CAAlB;AACA;AACD,WAXD;;AAYD,aAAKnI,mBAAL;AACC,iBAAO,MAAM;AACZ0E,YAAAA,MAAM,CAACzB,IAAP,CAAY,IAAZ;;AACA,gBAAI8D,iBAAiB,CAAC9F,QAAD,CAArB,EAAiC;AAChCyD,cAAAA,MAAM,CAACzB,IAAP;AACC;AAAuBV,cAAAA,aAAD,CAAgB6F,WAAhB,CACrB5F,eADqB,CADvB;AAKAA,cAAAA,eAAe,IAAIvB,QAAnB;AACA6F,cAAAA,aAAa;AACb,aARD,MAQO;AACNpC,cAAAA,MAAM,CAACzB,IAAP,CAAYgE,IAAI,CAAChG,QAAD,CAAJ,CAAemH,WAAf,CAA2B,CAA3B,CAAZ;AACA;AACD,WAbD;;AAcD,aAAKvI,aAAL;AACC,iBAAO,MAAM;AACZ,kBAAMoF,GAAG,GAAGsC,MAAM,KAAK,CAAvB;;AACA,iBAAK,IAAIpD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,cAAAA,MAAM,CAACzB,IAAP,CAAY,IAAZ;AACA;AACD,WALD;;AAMD,aAAKnD,cAAL;AACC,iBAAO,MAAM;AACZ,kBAAMmF,GAAG,GAAGwC,OAAO,KAAK,GAAxB;;AACA,iBAAK,IAAItD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,cAAAA,MAAM,CAACzB,IAAP,CAAY,IAAZ;AACA;AACD,WALD;;AAMD,aAAKxD,eAAL;AACC,iBAAO,MAAM;AACZ,kBAAM4I,WAAW,GAAGd,MAAM,EAA1B;;AACA,gBAAI,CAACc,WAAW,GAAG,IAAf,MAAyB,CAA7B,EAAgC;AAC/BV,cAAAA,QAAQ,CAACU,WAAD,EAAc,CAAd,CAAR;AACA,aAFD,MAEO,IAAI,CAACA,WAAW,GAAG,IAAf,MAAyB,CAA7B,EAAgC;AACtCV,cAAAA,QAAQ,CAACU,WAAD,EAAc,CAAd,CAAR;AACA,aAFM,MAEA,IAAI,CAACA,WAAW,GAAG,IAAf,MAAyB,CAA7B,EAAgC;AACtCV,cAAAA,QAAQ,CAACU,WAAD,EAAc,CAAd,CAAR;AACA,aAFM,MAEA,IAAI,CAACA,WAAW,GAAG,IAAf,MAAyB,CAA7B,EAAgC;AACtCV,cAAAA,QAAQ,CAACU,WAAD,EAAc,CAAd,CAAR;AACA,aAFM,MAEA,IAAIA,WAAW,KAAK,IAApB,EAA0B;AAChC,kBAAIxC,KAAK,GAAG,CAACwC,WAAW,GAAG,IAAf,IAAuB,CAAnC;;AACA,qBAAOxC,KAAK,GAAG,CAAf,EAAkB;AACjB8B,gBAAAA,QAAQ,CAACJ,MAAM,EAAP,EAAW,CAAX,CAAR;AACA1B,gBAAAA,KAAK,IAAI,CAAT;AACA;;AACD8B,cAAAA,QAAQ,CAACJ,MAAM,EAAP,EAAW1B,KAAX,CAAR;AACA,aAPM,MAOA;AACN,kBAAIA,KAAK,GAAG4B,OAAO,EAAnB;;AACA,qBAAO5B,KAAK,GAAG,CAAf,EAAkB;AACjB8B,gBAAAA,QAAQ,CAACJ,MAAM,EAAP,EAAW,CAAX,CAAR;AACA1B,gBAAAA,KAAK,IAAI,CAAT;AACA;;AACD8B,cAAAA,QAAQ,CAACJ,MAAM,EAAP,EAAW1B,KAAX,CAAR;AACA;AACD,WAzBD;;AA0BD,aAAKvF,aAAL;AACC,iBAAO,MAAM;AACZ,kBAAM2E,GAAG,GAAGwC,OAAO,EAAnB;;AACA,gBAAIV,iBAAiB,CAAC9B,GAAD,CAAjB,IAA0BzC,eAAe,GAAGyC,GAAlB,GAAwB,UAAtD,EAAkE;AACjEP,cAAAA,MAAM,CAACzB,IAAP,CACCV,aAAa,CAACkD,QAAd,CACChB,SADD,EAECjC,eAFD,EAGCA,eAAe,GAAGyC,GAHnB,CADD;AAOAzC,cAAAA,eAAe,IAAIyC,GAAnB;AACA6B,cAAAA,aAAa;AACb,aAVD,MAUO;AACNpC,cAAAA,MAAM,CAACzB,IAAP,CAAYgE,IAAI,CAAChC,GAAD,CAAJ,CAAUQ,QAAV,EAAZ;AACA;AACD,WAfD;;AAgBD,aAAK9E,mBAAL;AACC,iBAAO,MAAM+D,MAAM,CAACzB,IAAP,CAAY,EAAZ,CAAb;;AACD,aAAKtC,mBAAmB,GAAG,CAA3B;AACC,iBAAO,MAAM;AACZ,gBAAIgG,eAAe,IAAInE,eAAe,GAAG,UAAzC,EAAqD;AACpDkC,cAAAA,MAAM,CAACzB,IAAP,CACCV,aAAa,CAACkD,QAAd,CACC,QADD,EAECjD,eAFD,EAGCA,eAAe,GAAG,CAHnB,CADD;AAOAA,cAAAA,eAAe;AACfsE,cAAAA,aAAa;AACb,aAVD,MAUO;AACNpC,cAAAA,MAAM,CAACzB,IAAP,CAAYgE,IAAI,CAAC,CAAD,CAAJ,CAAQxB,QAAR,CAAiB,QAAjB,CAAZ;AACA;AACD,WAdD;;AAeD,aAAKjF,SAAL;AACC,iBAAO,MAAM;AACZ,gBAAImG,eAAJ,EAAqB;AACpBjC,cAAAA,MAAM,CAACzB,IAAP;AACC;AAAuBV,cAAAA,aAAD,CAAgB4F,QAAhB,CAAyB3F,eAAzB,CADvB;AAGAA,cAAAA,eAAe;AACfsE,cAAAA,aAAa;AACb,aAND,MAMO;AACNpC,cAAAA,MAAM,CAACzB,IAAP,CAAYgE,IAAI,CAAC,CAAD,CAAJ,CAAQkB,QAAR,CAAiB,CAAjB,CAAZ;AACA;AACD,WAVD;;AAWD,aAAK/H,gBAAL;AAAuB;AACtB,kBAAM6E,GAAG,GAAG,CAAZ;AACA,mBAAO,MAAM;AACZ,oBAAMqD,IAAI,GAAGtH,OAAO,GAAGiE,GAAvB;;AAEA,kBAAI8B,iBAAiB,CAACuB,IAAD,CAArB,EAA6B;AAC5B,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7B,wBAAMqB,KAAK;AACV;AACCjD,kBAAAA,aAAD,CAAgB4F,QAAhB,CAAyB3F,eAAzB,CAFD;AAGAkC,kBAAAA,MAAM,CAACzB,IAAP,CAAYxB,MAAM,CAAC+D,KAAD,CAAlB;AACAhD,kBAAAA,eAAe,IAAIxB,OAAnB;AACA;;AACD8F,gBAAAA,aAAa;AACb,eATD,MASO;AACN,sBAAMoB,GAAG,GAAGjB,IAAI,CAACqB,IAAD,CAAhB;;AACA,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7B,wBAAMqB,KAAK,GAAG0C,GAAG,CAACC,QAAJ,CAAahE,CAAC,GAAGnD,OAAjB,CAAd;AACA0D,kBAAAA,MAAM,CAACzB,IAAP,CAAYxB,MAAM,CAAC+D,KAAD,CAAlB;AACA;AACD;AACD,aAnBD;AAoBA;;AACD,aAAKnF,iBAAL;AAAwB;AACvB,kBAAM4E,GAAG,GAAG,CAAZ;AACA,mBAAO,MAAM;AACZ,oBAAMqD,IAAI,GAAGrH,QAAQ,GAAGgE,GAAxB;;AACA,kBAAI8B,iBAAiB,CAACuB,IAAD,CAArB,EAA6B;AAC5B,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7B,wBAAMqB,KAAK;AAAG;AAAuBjD,kBAAAA,aAAD,CAAgB6F,WAAhB,CACnC5F,eADmC,CAApC;AAGAkC,kBAAAA,MAAM,CAACzB,IAAP,CAAYxB,MAAM,CAAC+D,KAAD,CAAlB;AACAhD,kBAAAA,eAAe,IAAIvB,QAAnB;AACA;;AACD6F,gBAAAA,aAAa;AACb,eATD,MASO;AACN,sBAAMoB,GAAG,GAAGjB,IAAI,CAACqB,IAAD,CAAhB;;AACA,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7B,wBAAMqB,KAAK,GAAG0C,GAAG,CAACE,WAAJ,CAAgBjE,CAAC,GAAGlD,QAApB,CAAd;AACAyD,kBAAAA,MAAM,CAACzB,IAAP,CAAYxB,MAAM,CAAC+D,KAAD,CAAlB;AACA;AACD;AACD,aAlBD;AAmBA;;AACD,aAAKrF,aAAL;AAAoB;AACnB,mBAAO,MAAM;AACZ,oBAAM8E,GAAG,GAAGwC,OAAO,EAAnB;;AACA,kBAAIV,iBAAiB,CAAC9B,GAAD,CAAjB,IAA0BzC,eAAe,GAAGyC,GAAlB,GAAwB,UAAtD,EAAkE;AACjE,sBAAMO,KAAK,GAAGjD,aAAa,CAACkD,QAAd,CACbhB,SADa,EAEbjC,eAFa,EAGbA,eAAe,GAAGyC,GAHL,CAAd;AAMAP,gBAAAA,MAAM,CAACzB,IAAP,CAAYxB,MAAM,CAAC+D,KAAD,CAAlB;AACAhD,gBAAAA,eAAe,IAAIyC,GAAnB;AACA6B,gBAAAA,aAAa;AACb,eAVD,MAUO;AACN,sBAAMtB,KAAK,GAAGyB,IAAI,CAAChC,GAAD,CAAJ,CAAUQ,QAAV,EAAd;AACAf,gBAAAA,MAAM,CAACzB,IAAP,CAAYxB,MAAM,CAAC+D,KAAD,CAAlB;AACA;AACD,aAhBD;AAiBA;;AACD;AACC,cAAIyC,MAAM,IAAI,EAAd,EAAkB;AACjB,mBAAO,MAAMvD,MAAM,CAACzB,IAAP,CAAYgF,MAAZ,CAAb;AACA,WAFD,MAEO,IAAI,CAACA,MAAM,GAAGtH,mBAAV,MAAmCA,mBAAvC,EAA4D;AAClE,kBAAMsE,GAAG,GAAGgD,MAAM,GAAGnH,wBAArB;AACA,mBAAO,MAAM;AACZ,kBACCiG,iBAAiB,CAAC9B,GAAD,CAAjB,IACAzC,eAAe,GAAGyC,GAAlB,GAAwB,UAFzB,EAGE;AACDP,gBAAAA,MAAM,CAACzB,IAAP,CACCV,aAAa,CAACkD,QAAd,CACC,QADD,EAECjD,eAFD,EAGCA,eAAe,GAAGyC,GAHnB,CADD;AAOAzC,gBAAAA,eAAe,IAAIyC,GAAnB;AACA6B,gBAAAA,aAAa;AACb,eAbD,MAaO;AACNpC,gBAAAA,MAAM,CAACzB,IAAP,CAAYgE,IAAI,CAAChC,GAAD,CAAJ,CAAUQ,QAAV,CAAmB,QAAnB,CAAZ;AACA;AACD,aAjBD;AAkBA,WApBM,MAoBA,IAAI,CAACwC,MAAM,GAAGrH,mBAAV,MAAmCF,UAAvC,EAAmD;AACzD,kBAAMuE,GAAG,GAAG,CAACgD,MAAM,GAAGpH,kBAAV,IAAgC,CAA5C;AACA,mBAAO,MAAM;AACZ,oBAAMyH,IAAI,GAAGpH,QAAQ,GAAG+D,GAAxB;;AACA,kBAAI8B,iBAAiB,CAACuB,IAAD,CAArB,EAA6B;AAC5B,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,kBAAAA,MAAM,CAACzB,IAAP;AACC;AAAuBV,kBAAAA,aAAD,CAAgBgG,YAAhB,CACrB/F,eADqB,CADvB;AAKAA,kBAAAA,eAAe,IAAItB,QAAnB;AACA;;AACD4F,gBAAAA,aAAa;AACb,eAVD,MAUO;AACN,sBAAMoB,GAAG,GAAGjB,IAAI,CAACqB,IAAD,CAAhB;;AACA,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,kBAAAA,MAAM,CAACzB,IAAP,CAAYiF,GAAG,CAACK,YAAJ,CAAiBpE,CAAC,GAAGjD,QAArB,CAAZ;AACA;AACD;AACD,aAlBD;AAmBA,WArBM,MAqBA,IAAI,CAAC+G,MAAM,GAAGrH,mBAAV,MAAmCH,UAAvC,EAAmD;AACzD,kBAAMwE,GAAG,GAAG,CAACgD,MAAM,GAAGpH,kBAAV,IAAgC,CAA5C;AACA,mBAAO,MAAM;AACZ,oBAAMyH,IAAI,GAAGrH,QAAQ,GAAGgE,GAAxB;;AACA,kBAAI8B,iBAAiB,CAACuB,IAAD,CAArB,EAA6B;AAC5B,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,kBAAAA,MAAM,CAACzB,IAAP;AACC;AAAuBV,kBAAAA,aAAD,CAAgB6F,WAAhB,CACrB5F,eADqB,CADvB;AAKAA,kBAAAA,eAAe,IAAIvB,QAAnB;AACA;;AACD6F,gBAAAA,aAAa;AACb,eAVD,MAUO;AACN,sBAAMoB,GAAG,GAAGjB,IAAI,CAACqB,IAAD,CAAhB;;AACA,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,kBAAAA,MAAM,CAACzB,IAAP,CAAYiF,GAAG,CAACE,WAAJ,CAAgBjE,CAAC,GAAGlD,QAApB,CAAZ;AACA;AACD;AACD,aAlBD;AAmBA,WArBM,MAqBA,IAAI,CAACgH,MAAM,GAAGrH,mBAAV,MAAmCJ,SAAvC,EAAkD;AACxD,kBAAMyE,GAAG,GAAG,CAACgD,MAAM,GAAGpH,kBAAV,IAAgC,CAA5C;AACA,mBAAO,MAAM;AACZ,oBAAMyH,IAAI,GAAGtH,OAAO,GAAGiE,GAAvB;;AACA,kBAAI8B,iBAAiB,CAACuB,IAAD,CAArB,EAA6B;AAC5B,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,kBAAAA,MAAM,CAACzB,IAAP;AACC;AAAuBV,kBAAAA,aAAD,CAAgB4F,QAAhB,CACrB3F,eADqB,CADvB;AAKAA,kBAAAA,eAAe,IAAIxB,OAAnB;AACA;;AACD8F,gBAAAA,aAAa;AACb,eAVD,MAUO;AACN,sBAAMoB,GAAG,GAAGjB,IAAI,CAACqB,IAAD,CAAhB;;AACA,qBAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC7BO,kBAAAA,MAAM,CAACzB,IAAP,CAAYiF,GAAG,CAACC,QAAJ,CAAahE,CAAC,GAAGnD,OAAjB,CAAZ;AACA;AACD;AACD,aAlBD;AAmBA,WArBM,MAqBA;AACN,mBAAO,MAAM;AACZ,oBAAM,IAAIsD,KAAJ,CACJ,4BAA2B2D,MAAM,CAACxC,QAAP,CAAgB,EAAhB,CAAoB,EAD3C,CAAN;AAGA,aAJD;AAKA;;AA7TH;AA+TA,KAhUqB,CAAtB;AAkUA;;AACA,QAAIf,MAAM,GAAG,EAAb;;AACA,WAAOnC,aAAa,KAAK,IAAzB,EAA+B;AAC9B,UAAI,OAAOA,aAAP,KAAyB,UAA7B,EAAyC;AACxCmC,QAAAA,MAAM,CAACzB,IAAP,CAAY,KAAKuD,gBAAL,CAAsBjE,aAAtB,EAAqCV,OAArC,CAAZ;AACA6E,QAAAA,eAAe;AACfnE,QAAAA,aAAa,GACZmE,eAAe,GAAG9E,IAAI,CAACiB,MAAvB,GAAgCjB,IAAI,CAAC8E,eAAD,CAApC,GAAwD,IADzD;AAEAC,QAAAA,eAAe,GAAGlE,MAAM,CAACuD,QAAP,CAAgBzD,aAAhB,CAAlB;AACA,OAND,MAMO;AACN,cAAM0F,MAAM,GAAGV,MAAM,EAArB;AACAM,QAAAA,aAAa,CAACI,MAAD,CAAb;AACA;AACD,KA1b0B,CA4b3B;;;AACA,QAAIO,OAAO,GAAG9D,MAAd;AACAA,IAAAA,MAAM,GAAGD,SAAT;AACA,WAAO+D,OAAP;AACA;;AAp8BkD;;AAu8BpDC,MAAM,CAACC,OAAP,GAAiBhH,gBAAjB;AAEA+G,MAAM,CAACC,OAAP,CAAevH,uBAAf,GAAyCA,uBAAzC;AACAsH,MAAM,CAACC,OAAP,CAAerH,qBAAf,GAAuCA,qBAAvC","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/*\nFormat:\n\nFile -> Section*\n\nSection -> NullsSection |\n\t\t\t\t\t BooleansSection |\n\t\t\t\t\t F64NumbersSection |\n\t\t\t\t\t I32NumbersSection |\n\t\t\t\t\t I8NumbersSection |\n\t\t\t\t\t ShortStringSection |\n\t\t\t\t\t BigIntSection |\n\t\t\t\t\t I32BigIntSection |\n\t\t\t\t\t I8BigIntSection\n\t\t\t\t\t StringSection |\n\t\t\t\t\t BufferSection |\n\t\t\t\t\t NopSection\n\n\n\nNullsSection ->\n\tNullHeaderByte | Null2HeaderByte | Null3HeaderByte |\n\tNulls8HeaderByte 0xnn (n:count - 4) |\n\tNulls32HeaderByte n:ui32 (n:count - 260) |\nBooleansSection -> TrueHeaderByte | FalseHeaderByte | BooleansSectionHeaderByte BooleansCountAndBitsByte\nF64NumbersSection -> F64NumbersSectionHeaderByte f64*\nI32NumbersSection -> I32NumbersSectionHeaderByte i32*\nI8NumbersSection -> I8NumbersSectionHeaderByte i8*\nShortStringSection -> ShortStringSectionHeaderByte ascii-byte*\nStringSection -> StringSectionHeaderByte i32:length utf8-byte*\nBufferSection -> BufferSectionHeaderByte i32:length byte*\nNopSection --> NopSectionHeaderByte\nBigIntSection -> BigIntSectionHeaderByte i32:length ascii-byte*\nI32BigIntSection -> I32BigIntSectionHeaderByte i32\nI8BigIntSection -> I8BigIntSectionHeaderByte i8\n\nShortStringSectionHeaderByte -> 0b1nnn_nnnn (n:length)\n\nF64NumbersSectionHeaderByte -> 0b001n_nnnn (n:count - 1)\nI32NumbersSectionHeaderByte -> 0b010n_nnnn (n:count - 1)\nI8NumbersSectionHeaderByte -> 0b011n_nnnn (n:count - 1)\n\nNullsSectionHeaderByte -> 0b0001_nnnn (n:count - 1)\nBooleansCountAndBitsByte ->\n\t0b0000_1xxx (count = 3) |\n\t0b0001_xxxx (count = 4) |\n\t0b001x_xxxx (count = 5) |\n\t0b01xx_xxxx (count = 6) |\n\t0b1nnn_nnnn (n:count - 7, 7 <= count <= 133)\n\t0xff n:ui32 (n:count, 134 <= count < 2^32)\n\nStringSectionHeaderByte -> 0b0000_1110\nBufferSectionHeaderByte -> 0b0000_1111\nNopSectionHeaderByte -> 0b0000_1011\nBigIntSectionHeaderByte -> 0b0001_1010\nI32BigIntSectionHeaderByte -> 0b0001_1100\nI8BigIntSectionHeaderByte -> 0b0001_1011\nFalseHeaderByte -> 0b0000_1100\nTrueHeaderByte -> 0b0000_1101\n\nRawNumber -> n (n <= 10)\n\n*/\n\nconst LAZY_HEADER = 0x0b;\nconst TRUE_HEADER = 0x0c;\nconst FALSE_HEADER = 0x0d;\nconst BOOLEANS_HEADER = 0x0e;\nconst NULL_HEADER = 0x10;\nconst NULL2_HEADER = 0x11;\nconst NULL3_HEADER = 0x12;\nconst NULLS8_HEADER = 0x13;\nconst NULLS32_HEADER = 0x14;\nconst NULL_AND_I8_HEADER = 0x15;\nconst NULL_AND_I32_HEADER = 0x16;\nconst NULL_AND_TRUE_HEADER = 0x17;\nconst NULL_AND_FALSE_HEADER = 0x18;\nconst BIGINT_HEADER = 0x1a;\nconst BIGINT_I8_HEADER = 0x1b;\nconst BIGINT_I32_HEADER = 0x1c;\nconst STRING_HEADER = 0x1e;\nconst BUFFER_HEADER = 0x1f;\nconst I8_HEADER = 0x60;\nconst I32_HEADER = 0x40;\nconst F64_HEADER = 0x20;\nconst SHORT_STRING_HEADER = 0x80;\n\n/** Uplift high-order bits */\nconst NUMBERS_HEADER_MASK = 0xe0; // 0b1010_0000\nconst NUMBERS_COUNT_MASK = 0x1f; // 0b0001_1111\nconst SHORT_STRING_LENGTH_MASK = 0x7f; // 0b0111_1111\n\nconst HEADER_SIZE = 1;\nconst I8_SIZE = 1;\nconst I32_SIZE = 4;\nconst F64_SIZE = 8;\n\nconst MEASURE_START_OPERATION = Symbol(\"MEASURE_START_OPERATION\");\nconst MEASURE_END_OPERATION = Symbol(\"MEASURE_END_OPERATION\");\n\n/** @typedef {typeof MEASURE_START_OPERATION} MEASURE_START_OPERATION_TYPE */\n/** @typedef {typeof MEASURE_END_OPERATION} MEASURE_END_OPERATION_TYPE */\n\n/**\n * @param {number} n number\n * @returns {0 | 1 | 2} type of number for serialization\n */\nconst identifyNumber = n => {\n\tif (n === (n | 0)) {\n\t\tif (n <= 127 && n >= -128) return 0;\n\t\tif (n <= 2147483647 && n >= -2147483648) return 1;\n\t}\n\treturn 2;\n};\n\n/**\n * @param {bigint} n bigint\n * @returns {0 | 1 | 2} type of bigint for serialization\n */\nconst identifyBigInt = n => {\n\tif (n <= BigInt(127) && n >= BigInt(-128)) return 0;\n\tif (n <= BigInt(2147483647) && n >= BigInt(-2147483648)) return 1;\n\treturn 2;\n};\n\n/**\n * @typedef {PrimitiveSerializableType[]} DeserializedType\n * @typedef {BufferSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass BinaryMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\treturn this._serialize(data, context);\n\t}\n\n\t_serializeLazy(fn, context) {\n\t\treturn SerializerMiddleware.serializeLazy(fn, data =>\n\t\t\tthis._serialize(data, context)\n\t\t);\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope\n\t * @returns {SerializedType} serialized data\n\t */\n\t_serialize(\n\t\tdata,\n\t\tcontext,\n\t\tallocationScope = {\n\t\t\tallocationSize: 1024,\n\t\t\tincreaseCounter: 0,\n\t\t\tleftOverBuffer: null\n\t\t}\n\t) {\n\t\t/** @type {Buffer} */\n\t\tlet leftOverBuffer = null;\n\t\t/** @type {BufferSerializableType[]} */\n\t\tlet buffers = [];\n\t\t/** @type {Buffer} */\n\t\tlet currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;\n\t\tallocationScope.leftOverBuffer = null;\n\t\tlet currentPosition = 0;\n\t\tif (currentBuffer === null) {\n\t\t\tcurrentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize);\n\t\t}\n\t\tconst allocate = bytesNeeded => {\n\t\t\tif (currentBuffer !== null) {\n\t\t\t\tif (currentBuffer.length - currentPosition >= bytesNeeded) return;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (leftOverBuffer && leftOverBuffer.length >= bytesNeeded) {\n\t\t\t\tcurrentBuffer = leftOverBuffer;\n\t\t\t\tleftOverBuffer = null;\n\t\t\t} else {\n\t\t\t\tcurrentBuffer = Buffer.allocUnsafe(\n\t\t\t\t\tMath.max(bytesNeeded, allocationScope.allocationSize)\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t!(allocationScope.increaseCounter =\n\t\t\t\t\t\t(allocationScope.increaseCounter + 1) % 4) &&\n\t\t\t\t\tallocationScope.allocationSize < 16777216\n\t\t\t\t) {\n\t\t\t\t\tallocationScope.allocationSize = allocationScope.allocationSize << 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst flush = () => {\n\t\t\tif (currentBuffer !== null) {\n\t\t\t\tif (currentPosition > 0) {\n\t\t\t\t\tbuffers.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcurrentBuffer.buffer,\n\t\t\t\t\t\t\tcurrentBuffer.byteOffset,\n\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!leftOverBuffer ||\n\t\t\t\t\tleftOverBuffer.length < currentBuffer.length - currentPosition\n\t\t\t\t) {\n\t\t\t\t\tleftOverBuffer = Buffer.from(\n\t\t\t\t\t\tcurrentBuffer.buffer,\n\t\t\t\t\t\tcurrentBuffer.byteOffset + currentPosition,\n\t\t\t\t\t\tcurrentBuffer.byteLength - currentPosition\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcurrentBuffer = null;\n\t\t\t\tcurrentPosition = 0;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {number} byte byte\n\t\t */\n\t\tconst writeU8 = byte => {\n\t\t\tcurrentBuffer.writeUInt8(byte, currentPosition++);\n\t\t};\n\t\t/**\n\t\t * @param {number} ui32 ui32\n\t\t */\n\t\tconst writeU32 = ui32 => {\n\t\t\tcurrentBuffer.writeUInt32LE(ui32, currentPosition);\n\t\t\tcurrentPosition += 4;\n\t\t};\n\t\t/** @type {number[]} */\n\t\tconst measureStack = [];\n\t\tconst measureStart = () => {\n\t\t\tmeasureStack.push(buffers.length, currentPosition);\n\t\t};\n\t\t/**\n\t\t * @returns {number} size\n\t\t */\n\t\tconst measureEnd = () => {\n\t\t\tconst oldPos = measureStack.pop();\n\t\t\tconst buffersIndex = measureStack.pop();\n\t\t\tlet size = currentPosition - oldPos;\n\t\t\tfor (let i = buffersIndex; i < buffers.length; i++) {\n\t\t\t\tsize += buffers[i].length;\n\t\t\t}\n\t\t\treturn size;\n\t\t};\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tconst thing = data[i];\n\t\t\tswitch (typeof thing) {\n\t\t\t\tcase \"function\": {\n\t\t\t\t\tif (!SerializerMiddleware.isLazy(thing))\n\t\t\t\t\t\tthrow new Error(\"Unexpected function \" + thing);\n\t\t\t\t\t/** @type {SerializedType | (() => SerializedType)} */\n\t\t\t\t\tlet serializedData =\n\t\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(thing);\n\t\t\t\t\tif (serializedData === undefined) {\n\t\t\t\t\t\tif (SerializerMiddleware.isLazy(thing, this)) {\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tallocationScope.leftOverBuffer = leftOverBuffer;\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t/** @type {(Exclude<PrimitiveSerializableType, Promise<PrimitiveSerializableType>>)[]} */ (\n\t\t\t\t\t\t\t\t\tthing()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst data = this._serialize(result, context, allocationScope);\n\t\t\t\t\t\t\tleftOverBuffer = allocationScope.leftOverBuffer;\n\t\t\t\t\t\t\tallocationScope.leftOverBuffer = null;\n\t\t\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(thing, data);\n\t\t\t\t\t\t\tserializedData = data;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tserializedData = this._serializeLazy(thing, context);\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(serializedData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(serializedData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/** @type {number[]} */\n\t\t\t\t\tconst lengths = [];\n\t\t\t\t\tfor (const item of serializedData) {\n\t\t\t\t\t\tlet last;\n\t\t\t\t\t\tif (typeof item === \"function\") {\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\t} else if (item.length === 0) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tlengths.length > 0 &&\n\t\t\t\t\t\t\t(last = lengths[lengths.length - 1]) !== 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst remaining = 0xffffffff - last;\n\t\t\t\t\t\t\tif (remaining >= item.length) {\n\t\t\t\t\t\t\t\tlengths[lengths.length - 1] += item.length;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlengths.push(item.length - remaining);\n\t\t\t\t\t\t\t\tlengths[lengths.length - 2] = 0xffffffff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlengths.push(item.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tallocate(5 + lengths.length * 4);\n\t\t\t\t\twriteU8(LAZY_HEADER);\n\t\t\t\t\twriteU32(lengths.length);\n\t\t\t\t\tfor (const l of lengths) {\n\t\t\t\t\t\twriteU32(l);\n\t\t\t\t\t}\n\t\t\t\t\tflush();\n\t\t\t\t\tfor (const item of serializedData) {\n\t\t\t\t\t\tbuffers.push(item);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"string\": {\n\t\t\t\t\tconst len = Buffer.byteLength(thing);\n\t\t\t\t\tif (len >= 128 || len !== thing.length) {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\twriteU8(STRING_HEADER);\n\t\t\t\t\t\twriteU32(len);\n\t\t\t\t\t\tcurrentBuffer.write(thing, currentPosition);\n\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t} else if (len >= 70) {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE);\n\t\t\t\t\t\twriteU8(SHORT_STRING_HEADER | len);\n\n\t\t\t\t\t\tcurrentBuffer.write(thing, currentPosition, \"latin1\");\n\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE);\n\t\t\t\t\t\twriteU8(SHORT_STRING_HEADER | len);\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tcurrentBuffer[currentPosition++] = thing.charCodeAt(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"bigint\": {\n\t\t\t\t\tconst type = identifyBigInt(thing);\n\t\t\t\t\tif (type === 0 && thing >= 0 && thing <= BigInt(10)) {\n\t\t\t\t\t\t// shortcut for very small bigints\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\twriteU8(BIGINT_I8_HEADER);\n\t\t\t\t\t\twriteU8(Number(thing));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tlet n = 1;\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE * n);\n\t\t\t\t\t\t\twriteU8(BIGINT_I8_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(\n\t\t\t\t\t\t\t\t\tNumber(/** @type {bigint} */ (data[i])),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tlet n = 1;\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE * n);\n\t\t\t\t\t\t\twriteU8(BIGINT_I32_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(\n\t\t\t\t\t\t\t\t\tNumber(/** @type {bigint} */ (data[i])),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tconst value = thing.toString();\n\t\t\t\t\t\t\tconst len = Buffer.byteLength(value);\n\t\t\t\t\t\t\tallocate(len + HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(BIGINT_HEADER);\n\t\t\t\t\t\t\twriteU32(len);\n\t\t\t\t\t\t\tcurrentBuffer.write(value, currentPosition);\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"number\": {\n\t\t\t\t\tconst type = identifyNumber(thing);\n\t\t\t\t\tif (type === 0 && thing >= 0 && thing <= 10) {\n\t\t\t\t\t\t// shortcut for very small numbers\n\t\t\t\t\t\tallocate(I8_SIZE);\n\t\t\t\t\t\twriteU8(thing);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * amount of numbers to write\n\t\t\t\t\t * @type {number}\n\t\t\t\t\t */\n\t\t\t\t\tlet n = 1;\n\t\t\t\t\tfor (; n < 32 && i + n < data.length; n++) {\n\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\tif (typeof item !== \"number\") break;\n\t\t\t\t\t\tif (identifyNumber(item) !== type) break;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE * n);\n\t\t\t\t\t\t\twriteU8(I8_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE * n);\n\t\t\t\t\t\t\twriteU8(I32_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + F64_SIZE * n);\n\t\t\t\t\t\t\twriteU8(F64_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeDoubleLE(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += F64_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"boolean\": {\n\t\t\t\t\tlet lastByte = thing === true ? 1 : 0;\n\t\t\t\t\tconst bytes = [];\n\t\t\t\t\tlet count = 1;\n\t\t\t\t\tlet n;\n\t\t\t\t\tfor (n = 1; n < 0xffffffff && i + n < data.length; n++) {\n\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\tif (typeof item !== \"boolean\") break;\n\t\t\t\t\t\tconst pos = count & 0x7;\n\t\t\t\t\t\tif (pos === 0) {\n\t\t\t\t\t\t\tbytes.push(lastByte);\n\t\t\t\t\t\t\tlastByte = item === true ? 1 : 0;\n\t\t\t\t\t\t} else if (item === true) {\n\t\t\t\t\t\t\tlastByte |= 1 << pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\ti += count - 1;\n\t\t\t\t\tif (count === 1) {\n\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\twriteU8(lastByte === 1 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t} else if (count === 2) {\n\t\t\t\t\t\tallocate(HEADER_SIZE * 2);\n\t\t\t\t\t\twriteU8(lastByte & 1 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t\twriteU8(lastByte & 2 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t} else if (count <= 6) {\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8((1 << count) | lastByte);\n\t\t\t\t\t} else if (count <= 133) {\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8(0x80 | (count - 7));\n\t\t\t\t\t\tfor (const byte of bytes) writeU8(byte);\n\t\t\t\t\t\twriteU8(lastByte);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallocate(\n\t\t\t\t\t\t\tHEADER_SIZE +\n\t\t\t\t\t\t\t\tI8_SIZE +\n\t\t\t\t\t\t\t\tI32_SIZE +\n\t\t\t\t\t\t\t\tI8_SIZE * bytes.length +\n\t\t\t\t\t\t\t\tI8_SIZE\n\t\t\t\t\t\t);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8(0xff);\n\t\t\t\t\t\twriteU32(count);\n\t\t\t\t\t\tfor (const byte of bytes) writeU8(byte);\n\t\t\t\t\t\twriteU8(lastByte);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"object\": {\n\t\t\t\t\tif (thing === null) {\n\t\t\t\t\t\tlet n;\n\t\t\t\t\t\tfor (n = 1; n < 0x100000104 && i + n < data.length; n++) {\n\t\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\t\tif (item !== null) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti += n - 1;\n\t\t\t\t\t\tif (n === 1) {\n\t\t\t\t\t\t\tif (i + 1 < data.length) {\n\t\t\t\t\t\t\t\tconst next = data[i + 1];\n\t\t\t\t\t\t\t\tif (next === true) {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_TRUE_HEADER);\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} else if (next === false) {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_FALSE_HEADER);\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} else if (typeof next === \"number\") {\n\t\t\t\t\t\t\t\t\tconst type = identifyNumber(next);\n\t\t\t\t\t\t\t\t\tif (type === 0) {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_I8_HEADER);\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(next, currentPosition);\n\t\t\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} else if (type === 1) {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_I32_HEADER);\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(next, currentPosition);\n\t\t\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (n === 2) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\twriteU8(NULL2_HEADER);\n\t\t\t\t\t\t} else if (n === 3) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\twriteU8(NULL3_HEADER);\n\t\t\t\t\t\t} else if (n < 260) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\t\twriteU8(NULLS8_HEADER);\n\t\t\t\t\t\t\twriteU8(n - 4);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(NULLS32_HEADER);\n\t\t\t\t\t\t\twriteU32(n - 260);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Buffer.isBuffer(thing)) {\n\t\t\t\t\t\tif (thing.length < 8192) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE + thing.length);\n\t\t\t\t\t\t\twriteU8(BUFFER_HEADER);\n\t\t\t\t\t\t\twriteU32(thing.length);\n\t\t\t\t\t\t\tthing.copy(currentBuffer, currentPosition);\n\t\t\t\t\t\t\tcurrentPosition += thing.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(BUFFER_HEADER);\n\t\t\t\t\t\t\twriteU32(thing.length);\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(thing);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"symbol\": {\n\t\t\t\t\tif (thing === MEASURE_START_OPERATION) {\n\t\t\t\t\t\tmeasureStart();\n\t\t\t\t\t} else if (thing === MEASURE_END_OPERATION) {\n\t\t\t\t\t\tconst size = measureEnd();\n\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\twriteU8(I32_HEADER);\n\t\t\t\t\t\tcurrentBuffer.writeInt32LE(size, currentPosition);\n\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflush();\n\n\t\tallocationScope.leftOverBuffer = leftOverBuffer;\n\n\t\t// avoid leaking memory\n\t\tcurrentBuffer = null;\n\t\tleftOverBuffer = null;\n\t\tallocationScope = undefined;\n\t\tconst _buffers = buffers;\n\t\tbuffers = undefined;\n\t\treturn _buffers;\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\treturn this._deserialize(data, context);\n\t}\n\n\t_createLazyDeserialized(content, context) {\n\t\treturn SerializerMiddleware.createLazy(\n\t\t\tmemoize(() => this._deserialize(content, context)),\n\t\t\tthis,\n\t\t\tundefined,\n\t\t\tcontent\n\t\t);\n\t}\n\n\t_deserializeLazy(fn, context) {\n\t\treturn SerializerMiddleware.deserializeLazy(fn, data =>\n\t\t\tthis._deserialize(data, context)\n\t\t);\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType} deserialized data\n\t */\n\t_deserialize(data, context) {\n\t\tlet currentDataItem = 0;\n\t\tlet currentBuffer = data[0];\n\t\tlet currentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\tlet currentPosition = 0;\n\n\t\tconst retainedBuffer = context.retainedBuffer || (x => x);\n\n\t\tconst checkOverflow = () => {\n\t\t\tif (currentPosition >= currentBuffer.length) {\n\t\t\t\tcurrentPosition = 0;\n\t\t\t\tcurrentDataItem++;\n\t\t\t\tcurrentBuffer =\n\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t}\n\t\t};\n\t\tconst isInCurrentBuffer = n => {\n\t\t\treturn currentIsBuffer && n + currentPosition <= currentBuffer.length;\n\t\t};\n\t\tconst ensureBuffer = () => {\n\t\t\tif (!currentIsBuffer) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tcurrentBuffer === null\n\t\t\t\t\t\t? \"Unexpected end of stream\"\n\t\t\t\t\t\t: \"Unexpected lazy element in stream\"\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * Reads n bytes\n\t\t * @param {number} n amount of bytes to read\n\t\t * @returns {Buffer} buffer with bytes\n\t\t */\n\t\tconst read = n => {\n\t\t\tensureBuffer();\n\t\t\tconst rem = currentBuffer.length - currentPosition;\n\t\t\tif (rem < n) {\n\t\t\t\tconst buffers = [read(rem)];\n\t\t\t\tn -= rem;\n\t\t\t\tensureBuffer();\n\t\t\t\twhile (currentBuffer.length < n) {\n\t\t\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\t\t\tbuffers.push(b);\n\t\t\t\t\tn -= b.length;\n\t\t\t\t\tcurrentDataItem++;\n\t\t\t\t\tcurrentBuffer =\n\t\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t\t\tensureBuffer();\n\t\t\t\t}\n\t\t\t\tbuffers.push(read(n));\n\t\t\t\treturn Buffer.concat(buffers);\n\t\t\t}\n\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\tconst res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n\t\t\tcurrentPosition += n;\n\t\t\tcheckOverflow();\n\t\t\treturn res;\n\t\t};\n\t\t/**\n\t\t * Reads up to n bytes\n\t\t * @param {number} n amount of bytes to read\n\t\t * @returns {Buffer} buffer with bytes\n\t\t */\n\t\tconst readUpTo = n => {\n\t\t\tensureBuffer();\n\t\t\tconst rem = currentBuffer.length - currentPosition;\n\t\t\tif (rem < n) {\n\t\t\t\tn = rem;\n\t\t\t}\n\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\tconst res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n\t\t\tcurrentPosition += n;\n\t\t\tcheckOverflow();\n\t\t\treturn res;\n\t\t};\n\t\t/**\n\t\t * @returns {number} U8\n\t\t */\n\t\tconst readU8 = () => {\n\t\t\tensureBuffer();\n\t\t\t/**\n\t\t\t * There is no need to check remaining buffer size here\n\t\t\t * since {@link checkOverflow} guarantees at least one byte remaining\n\t\t\t */\n\t\t\tconst byte = /** @type {Buffer} */ (currentBuffer).readUInt8(\n\t\t\t\tcurrentPosition\n\t\t\t);\n\t\t\tcurrentPosition += I8_SIZE;\n\t\t\tcheckOverflow();\n\t\t\treturn byte;\n\t\t};\n\t\t/**\n\t\t * @returns {number} U32\n\t\t */\n\t\tconst readU32 = () => {\n\t\t\treturn read(I32_SIZE).readUInt32LE(0);\n\t\t};\n\t\tconst readBits = (data, n) => {\n\t\t\tlet mask = 1;\n\t\t\twhile (n !== 0) {\n\t\t\t\tresult.push((data & mask) !== 0);\n\t\t\t\tmask = mask << 1;\n\t\t\t\tn--;\n\t\t\t}\n\t\t};\n\t\tconst dispatchTable = Array.from({ length: 256 }).map((_, header) => {\n\t\t\tswitch (header) {\n\t\t\t\tcase LAZY_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst count = readU32();\n\t\t\t\t\t\tconst lengths = Array.from({ length: count }).map(() => readU32());\n\t\t\t\t\t\tconst content = [];\n\t\t\t\t\t\tfor (let l of lengths) {\n\t\t\t\t\t\t\tif (l === 0) {\n\t\t\t\t\t\t\t\tif (typeof currentBuffer !== \"function\") {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Unexpected non-lazy element in stream\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontent.push(currentBuffer);\n\t\t\t\t\t\t\t\tcurrentDataItem++;\n\t\t\t\t\t\t\t\tcurrentBuffer =\n\t\t\t\t\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\t\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\tconst buf = readUpTo(l);\n\t\t\t\t\t\t\t\t\tl -= buf.length;\n\t\t\t\t\t\t\t\t\tcontent.push(retainedBuffer(buf));\n\t\t\t\t\t\t\t\t} while (l > 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push(this._createLazyDeserialized(content, context));\n\t\t\t\t\t};\n\t\t\t\tcase BUFFER_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tresult.push(retainedBuffer(read(len)));\n\t\t\t\t\t};\n\t\t\t\tcase TRUE_HEADER:\n\t\t\t\t\treturn () => result.push(true);\n\t\t\t\tcase FALSE_HEADER:\n\t\t\t\t\treturn () => result.push(false);\n\t\t\t\tcase NULL3_HEADER:\n\t\t\t\t\treturn () => result.push(null, null, null);\n\t\t\t\tcase NULL2_HEADER:\n\t\t\t\t\treturn () => result.push(null, null);\n\t\t\t\tcase NULL_HEADER:\n\t\t\t\t\treturn () => result.push(null);\n\t\t\t\tcase NULL_AND_TRUE_HEADER:\n\t\t\t\t\treturn () => result.push(null, true);\n\t\t\t\tcase NULL_AND_FALSE_HEADER:\n\t\t\t\t\treturn () => result.push(null, false);\n\t\t\t\tcase NULL_AND_I8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(currentPosition)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(null, read(I8_SIZE).readInt8(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULL_AND_I32_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\tif (isInCurrentBuffer(I32_SIZE)) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(I32_SIZE).readInt32LE(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULLS8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU8() + 4;\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULLS32_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32() + 260;\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase BOOLEANS_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst innerHeader = readU8();\n\t\t\t\t\t\tif ((innerHeader & 0xf0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 3);\n\t\t\t\t\t\t} else if ((innerHeader & 0xe0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 4);\n\t\t\t\t\t\t} else if ((innerHeader & 0xc0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 5);\n\t\t\t\t\t\t} else if ((innerHeader & 0x80) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 6);\n\t\t\t\t\t\t} else if (innerHeader !== 0xff) {\n\t\t\t\t\t\t\tlet count = (innerHeader & 0x7f) + 7;\n\t\t\t\t\t\t\twhile (count > 8) {\n\t\t\t\t\t\t\t\treadBits(readU8(), 8);\n\t\t\t\t\t\t\t\tcount -= 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadBits(readU8(), count);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet count = readU32();\n\t\t\t\t\t\t\twhile (count > 8) {\n\t\t\t\t\t\t\t\treadBits(readU8(), 8);\n\t\t\t\t\t\t\t\tcount -= 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadBits(readU8(), count);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase STRING_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tif (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(len).toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase SHORT_STRING_HEADER:\n\t\t\t\t\treturn () => result.push(\"\");\n\t\t\t\tcase SHORT_STRING_HEADER | 1:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer && currentPosition < 0x7ffffffe) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\tcurrentPosition + 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition++;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(1).toString(\"latin1\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase I8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(currentPosition)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition++;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(1).readInt8(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase BIGINT_I8_HEADER: {\n\t\t\t\t\tconst len = 1;\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst need = I8_SIZE * len;\n\n\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value =\n\t\t\t\t\t\t\t\t\t/** @type {Buffer} */\n\t\t\t\t\t\t\t\t\t(currentBuffer).readInt8(currentPosition);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value = buf.readInt8(i * I8_SIZE);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase BIGINT_I32_HEADER: {\n\t\t\t\t\tconst len = 1;\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst need = I32_SIZE * len;\n\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value = /** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value = buf.readInt32LE(i * I32_SIZE);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase BIGINT_HEADER: {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tif (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n\t\t\t\t\t\t\tconst value = currentBuffer.toString(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst value = read(len).toString();\n\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tif (header <= 10) {\n\t\t\t\t\t\treturn () => result.push(header);\n\t\t\t\t\t} else if ((header & SHORT_STRING_HEADER) === SHORT_STRING_HEADER) {\n\t\t\t\t\t\tconst len = header & SHORT_STRING_LENGTH_MASK;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisInCurrentBuffer(len) &&\n\t\t\t\t\t\t\t\tcurrentPosition + len < 0x7fffffff\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.push(read(len).toString(\"latin1\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === F64_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = F64_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readDoubleLE(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += F64_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readDoubleLE(i * F64_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === I32_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = I32_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readInt32LE(i * I32_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === I8_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = I8_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readInt8(i * I8_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected header byte 0x${header.toString(16)}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/** @type {DeserializedType} */\n\t\tlet result = [];\n\t\twhile (currentBuffer !== null) {\n\t\t\tif (typeof currentBuffer === \"function\") {\n\t\t\t\tresult.push(this._deserializeLazy(currentBuffer, context));\n\t\t\t\tcurrentDataItem++;\n\t\t\t\tcurrentBuffer =\n\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t} else {\n\t\t\t\tconst header = readU8();\n\t\t\t\tdispatchTable[header]();\n\t\t\t}\n\t\t}\n\n\t\t// avoid leaking memory in context\n\t\tlet _result = result;\n\t\tresult = undefined;\n\t\treturn _result;\n\t}\n}\n\nmodule.exports = BinaryMiddleware;\n\nmodule.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION;\nmodule.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;\n"]},"metadata":{},"sourceType":"script"}