{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _AbstractPage_client;\n\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch } from \"./_shims/index.mjs\";\nimport { isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm } from \"./uploads.mjs\";\n\nasync function defaultParseResponse(props) {\n  const {\n    response\n  } = props;\n\n  if (props.options.stream) {\n    debug('response', response.status, response.url, response.headers, response.body); // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n\n    return Stream.fromSSEResponse(response, props.controller);\n  } // fetch refuses to read the body when the status code is 204.\n\n\n  if (response.status === 204) {\n    return null;\n  }\n\n  if (props.options.__binaryResponse) {\n    return response;\n  }\n\n  const contentType = response.headers.get('content-type');\n\n  if (contentType?.includes('application/json')) {\n    const json = await response.json();\n    debug('response', response.status, response.url, response.headers, json);\n    return json;\n  }\n\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text); // TODO handle blob, arraybuffer, other content types, etc.\n\n  return text;\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\n\n\nexport class APIPromise extends Promise {\n  constructor(responsePromise) {\n    let parseResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultParseResponse;\n    super(resolve => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null);\n    });\n    this.responsePromise = responsePromise;\n    this.parseResponse = parseResponse;\n  }\n\n  _thenUnwrap(transform) {\n    return new APIPromise(this.responsePromise, async props => transform(await this.parseResponse(props)));\n  }\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n\n\n  asResponse() {\n    return this.responsePromise.then(p => p.response);\n  }\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   *\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n\n\n  async withResponse() {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return {\n      data,\n      response\n    };\n  }\n\n  parse() {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\n    }\n\n    return this.parsedPromise;\n  }\n\n  then(onfulfilled, onrejected) {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  catch(onrejected) {\n    return this.parse().catch(onrejected);\n  }\n\n  finally(onfinally) {\n    return this.parse().finally(onfinally);\n  }\n\n}\nexport class APIClient {\n  constructor(_ref) {\n    let {\n      baseURL,\n      maxRetries = 2,\n      timeout = 600000,\n      // 10 minutes\n      httpAgent,\n      fetch: overridenFetch\n    } = _ref;\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n    this.fetch = overridenFetch ?? fetch;\n  }\n\n  authHeaders(opts) {\n    return {};\n  }\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n\n\n  defaultHeaders(opts) {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders(opts)\n    };\n  }\n  /**\n   * Override this to add your own headers validation:\n   */\n\n\n  validateHeaders(headers, customHeaders) {}\n\n  defaultIdempotencyKey() {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n\n  get(path, opts) {\n    return this.methodRequest('get', path, opts);\n  }\n\n  post(path, opts) {\n    return this.methodRequest('post', path, opts);\n  }\n\n  patch(path, opts) {\n    return this.methodRequest('patch', path, opts);\n  }\n\n  put(path, opts) {\n    return this.methodRequest('put', path, opts);\n  }\n\n  delete(path, opts) {\n    return this.methodRequest('delete', path, opts);\n  }\n\n  methodRequest(method, path, opts) {\n    return this.request(Promise.resolve(opts).then(opts => ({\n      method,\n      path,\n      ...opts\n    })));\n  }\n\n  getAPIList(path, Page, opts) {\n    return this.requestAPIList(Page, {\n      method: 'get',\n      path,\n      ...opts\n    });\n  }\n\n  calculateContentLength(body) {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    }\n\n    return null;\n  }\n\n  buildRequest(options) {\n    const {\n      method,\n      path,\n      query,\n      headers = {}\n    } = options;\n    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;\n    const contentLength = this.calculateContentLength(body);\n    const url = this.buildURL(path, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    const timeout = options.timeout ?? this.timeout;\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n    const minAgentTimeout = timeout + 1000;\n\n    if (typeof httpAgent?.options?.timeout === 'number' && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      httpAgent.options.timeout = minAgentTimeout;\n    }\n\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n\n    const reqHeaders = { ...(contentLength && {\n        'Content-Length': contentLength\n      }),\n      ...this.defaultHeaders(options),\n      ...headers\n    }; // let builtin fetch set the Content-Type for multipart bodies\n\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\n      delete reqHeaders['Content-Type'];\n    } // Strip any headers being explicitly omitted with null\n\n\n    Object.keys(reqHeaders).forEach(key => reqHeaders[key] === null && delete reqHeaders[key]);\n    const req = {\n      method,\n      ...(body && {\n        body: body\n      }),\n      headers: reqHeaders,\n      ...(httpAgent && {\n        agent: httpAgent\n      }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: options.signal ?? null\n    };\n    this.validateHeaders(reqHeaders, headers);\n    return {\n      req,\n      url,\n      timeout\n    };\n  }\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n\n\n  async prepareRequest(request, _ref2) {\n    let {\n      url,\n      options\n    } = _ref2;\n  }\n\n  parseHeaders(headers) {\n    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map(header => [...header])) : { ...headers\n    };\n  }\n\n  makeStatusError(status, error, message, headers) {\n    return APIError.generate(status, error, message, headers);\n  }\n\n  request(options) {\n    let remainingRetries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n\n  async makeRequest(optionsInput, retriesRemaining) {\n    const options = await optionsInput;\n\n    if (retriesRemaining == null) {\n      retriesRemaining = options.maxRetries ?? this.maxRetries;\n    }\n\n    const {\n      req,\n      url,\n      timeout\n    } = this.buildRequest(options);\n    await this.prepareRequest(req, {\n      url,\n      options\n    });\n    debug('request', url, options, req.headers);\n\n    if (options.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n\n    if (response instanceof Error) {\n      if (options.signal?.aborted) {\n        throw new APIUserAbortError();\n      }\n\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n\n      if (response.name === 'AbortError') {\n        throw new APIConnectionTimeoutError();\n      }\n\n      throw new APIConnectionError({\n        cause: response\n      });\n    }\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n\n      const errText = await response.text().catch(e => castToError(e).message);\n      const errJSON = safeJSON(errText);\n      const errMessage = errJSON ? undefined : errText;\n      debug('response', response.status, url, responseHeaders, errMessage);\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n\n    return {\n      response,\n      options,\n      controller\n    };\n  }\n\n  requestAPIList(Page, options) {\n    const request = this.makeRequest(options, null);\n    return new PagePromise(this, request, Page);\n  }\n\n  buildURL(path, query) {\n    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n    const defaultQuery = this.defaultQuery();\n\n    if (!isEmptyObj(defaultQuery)) {\n      query = { ...defaultQuery,\n        ...query\n      };\n    }\n\n    if (query) {\n      url.search = this.stringifyQuery(query);\n    }\n\n    return url.toString();\n  }\n\n  stringifyQuery(query) {\n    return Object.entries(query).filter(_ref3 => {\n      let [_, value] = _ref3;\n      return typeof value !== 'undefined';\n    }).map(_ref4 => {\n      let [key, value] = _ref4;\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n      }\n\n      if (value === null) {\n        return `${encodeURIComponent(key)}=`;\n      }\n\n      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n    }).join('&');\n  }\n\n  async fetchWithTimeout(url, init, ms, controller) {\n    const {\n      signal,\n      ...options\n    } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n    const timeout = setTimeout(() => controller.abort(), ms);\n    return this.getRequestClient() // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n    .fetch.call(undefined, url, {\n      signal: controller.signal,\n      ...options\n    }).finally(() => {\n      clearTimeout(timeout);\n    });\n  }\n\n  getRequestClient() {\n    return {\n      fetch: this.fetch\n    };\n  }\n\n  shouldRetry(response) {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry'); // If the server explicitly says whether or not to retry, obey.\n\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false; // Retry on request timeouts.\n\n    if (response.status === 408) return true; // Retry on lock timeouts.\n\n    if (response.status === 409) return true; // Retry on rate limits.\n\n    if (response.status === 429) return true; // Retry internal errors.\n\n    if (response.status >= 500) return true;\n    return false;\n  }\n\n  async retryRequest(options, retriesRemaining, responseHeaders) {\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    let timeoutMillis;\n    const retryAfterHeader = responseHeaders?.['retry-after'];\n\n    if (retryAfterHeader) {\n      const timeoutSeconds = parseInt(retryAfterHeader);\n\n      if (!Number.isNaN(timeoutSeconds)) {\n        timeoutMillis = timeoutSeconds * 1000;\n      } else {\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n      }\n    } // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says, but otherwise calculate a default\n\n\n    if (!timeoutMillis || !Number.isInteger(timeoutMillis) || timeoutMillis <= 0 || timeoutMillis > 60 * 1000) {\n      const maxRetries = options.maxRetries ?? this.maxRetries;\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n    }\n\n    await sleep(timeoutMillis);\n    return this.makeRequest(options, retriesRemaining - 1);\n  }\n\n  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 8.0;\n    const numRetries = maxRetries - retriesRemaining; // Apply exponential backoff, but not more than the max.\n\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay); // Apply some jitter, take up to at most 25 percent of the retry time.\n\n    const jitter = 1 - Math.random() * 0.25;\n    return sleepSeconds * jitter * 1000;\n  }\n\n  getUserAgent() {\n    return `${this.constructor.name}/JS ${VERSION}`;\n  }\n\n}\nexport class APIResource {\n  constructor(client) {\n    this.client = client;\n    this.get = client.get.bind(client);\n    this.post = client.post.bind(client);\n    this.patch = client.patch.bind(client);\n    this.put = client.put.bind(client);\n    this.delete = client.delete.bind(client);\n    this.getAPIList = client.getAPIList.bind(client);\n  }\n\n}\nexport class AbstractPage {\n  constructor(client, response, body, options) {\n    _AbstractPage_client.set(this, void 0);\n\n    __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n\n  hasNextPage() {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n\n  async getNextPage() {\n    const nextInfo = this.nextPageInfo();\n\n    if (!nextInfo) {\n      throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n    }\n\n    const nextOptions = { ...this.options\n    };\n\n    if ('params' in nextInfo) {\n      nextOptions.query = { ...nextOptions.query,\n        ...nextInfo.params\n      };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value);\n      }\n\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n\n    return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page = this;\n    yield page;\n\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\n\nexport class PagePromise extends APIPromise {\n  constructor(client, request, Page) {\n    super(request, async props => new Page(client, props.response, await defaultParseResponse(props), props.options));\n  }\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n\n\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n\n    for await (const item of page) {\n      yield item;\n    }\n  }\n\n}\nexport const createResponseHeaders = headers => {\n  return new Proxy(Object.fromEntries( // @ts-ignore\n  headers.entries()), {\n    get(target, name) {\n      const key = name.toString();\n      return target[key.toLowerCase()] || target[key];\n    }\n\n  });\n}; // This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\n\nconst requestOptionsKeys = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true,\n  __binaryResponse: true\n};\nexport const isRequestOptions = obj => {\n  return typeof obj === 'object' && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every(k => hasOwn(requestOptionsKeys, k));\n};\n\nconst getPlatformProperties = () => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version': Deno.version\n    };\n  }\n\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version\n    };\n  } // Check if Node.js\n\n\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version\n    };\n  }\n\n  const browserInfo = getBrowserInfo();\n\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version\n    };\n  } // TODO add support for Cloudflare workers, etc.\n\n\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown'\n  };\n}; // Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\n\n\nfunction getBrowserInfo() {\n  if (typeof navigator === 'undefined' || !navigator) {\n    return null;\n  } // NOTE: The order matters here!\n\n\n  const browserPatterns = [{\n    key: 'edge',\n    pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'ie',\n    pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'ie',\n    pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'chrome',\n    pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'firefox',\n    pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'safari',\n    pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/\n  }]; // Find the FIRST matching browser\n\n  for (const {\n    key,\n    pattern\n  } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n      return {\n        browser: key,\n        version: `${major}.${minor}.${patch}`\n      };\n    }\n  }\n\n  return null;\n}\n\nconst normalizeArch = arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\n\nconst normalizePlatform = platform => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n  platform = platform.toLowerCase(); // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\n\nlet _platformHeaders;\n\nconst getPlatformHeaders = () => {\n  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());\n};\n\nexport const safeJSON = text => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n}; // https://stackoverflow.com/a/19709846\n\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\n\nconst isAbsoluteURL = url => {\n  return startsWithSchemeRegexp.test(url);\n};\n\nexport const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nconst validatePositiveInteger = (name, n) => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new OpenAIError(`${name} must be an integer`);\n  }\n\n  if (n < 0) {\n    throw new OpenAIError(`${name} must be a positive integer`);\n  }\n\n  return n;\n};\n\nexport const castToError = err => {\n  if (err instanceof Error) return err;\n  return new Error(err);\n};\nexport const ensurePresent = value => {\n  if (value == null) throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\n/**\n * Read an environment variable.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\n\nexport const readEnv = env => {\n  if (typeof process !== 'undefined') {\n    return process.env?.[env] ?? undefined;\n  }\n\n  if (typeof Deno !== 'undefined') {\n    return Deno.env?.get?.(env);\n  }\n\n  return undefined;\n};\nexport const coerceInteger = value => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = value => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = value => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\nexport const maybeCoerceInteger = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n\n  return coerceInteger(value);\n};\nexport const maybeCoerceFloat = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n\n  return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n\n  return coerceBoolean(value);\n}; // https://stackoverflow.com/a/34491287\n\nexport function isEmptyObj(obj) {\n  if (!obj) return true;\n\n  for (const _k in obj) return false;\n\n  return true;\n} // https://eslint.org/docs/latest/rules/no-prototype-builtins\n\nexport function hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexport function debug(action) {\n  if (typeof process !== 'undefined' && process.env['DEBUG'] === 'true') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    console.log(`OpenAI:DEBUG:${action}`, ...args);\n  }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\n\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\n\nexport const isRunningInBrowser = () => {\n  return (// @ts-ignore\n    typeof window !== 'undefined' && // @ts-ignore\n    typeof window.document !== 'undefined' && // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\nexport const isHeadersProtocol = headers => {\n  return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n  const lowerCasedHeader = header.toLowerCase();\n\n  if (isHeadersProtocol(headers)) {\n    // to deal with the case where the header looks like Stainless-Event-Id\n    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n      const value = headers.get(key);\n\n      if (value) {\n        return value;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(headers)) {\n    if (key.toLowerCase() === lowerCasedHeader) {\n      if (Array.isArray(value)) {\n        if (value.length <= 1) return value[0];\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n        return value[0];\n      }\n\n      return value;\n    }\n  }\n\n  throw new Error(`Could not find ${header} header`);\n};\n/**\n * Encodes a string to Base64 format.\n */\n\nexport const toBase64 = str => {\n  if (!str) return '';\n\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n\n  throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};","map":{"version":3,"mappings":"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","names":["VERSION","Stream","OpenAIError","APIError","APIConnectionError","APIConnectionTimeoutError","APIUserAbortError","kind","shimsKind","getDefaultAgent","fetch","isMultipartBody","maybeMultipartFormRequestOptions","multipartFormRequestOptions","createForm","defaultParseResponse","props","response","options","stream","debug","status","url","headers","body","fromSSEResponse","controller","__binaryResponse","contentType","get","includes","json","text","APIPromise","Promise","constructor","responsePromise","parseResponse","resolve","_thenUnwrap","transform","asResponse","then","p","withResponse","data","all","parse","parsedPromise","onfulfilled","onrejected","catch","finally","onfinally","APIClient","baseURL","maxRetries","timeout","httpAgent","overridenFetch","validatePositiveInteger","authHeaders","opts","defaultHeaders","Accept","getUserAgent","getPlatformHeaders","validateHeaders","customHeaders","defaultIdempotencyKey","uuid4","path","methodRequest","post","patch","put","delete","method","request","getAPIList","Page","requestAPIList","calculateContentLength","Buffer","byteLength","toString","TextEncoder","encoder","encoded","encode","length","buildRequest","query","JSON","stringify","contentLength","buildURL","minAgentTimeout","idempotencyHeader","idempotencyKey","reqHeaders","Object","keys","forEach","key","req","agent","signal","prepareRequest","parseHeaders","Symbol","iterator","fromEntries","Array","from","map","header","makeStatusError","error","message","generate","remainingRetries","makeRequest","optionsInput","retriesRemaining","aborted","AbortController","fetchWithTimeout","castToError","Error","retryRequest","name","cause","responseHeaders","createResponseHeaders","ok","shouldRetry","errText","e","errJSON","safeJSON","errMessage","undefined","err","PagePromise","isAbsoluteURL","URL","endsWith","startsWith","slice","defaultQuery","isEmptyObj","search","stringifyQuery","entries","filter","_","value","encodeURIComponent","join","init","ms","addEventListener","abort","setTimeout","getRequestClient","call","clearTimeout","shouldRetryHeader","timeoutMillis","retryAfterHeader","timeoutSeconds","parseInt","Number","isNaN","Date","now","isInteger","calculateDefaultRetryTimeoutMillis","sleep","initialRetryDelay","maxRetryDelay","numRetries","sleepSeconds","Math","min","pow","jitter","random","APIResource","client","bind","AbstractPage","_AbstractPage_client","__classPrivateFieldSet","hasNextPage","items","getPaginatedItems","nextPageInfo","getNextPage","nextInfo","nextOptions","params","searchParams","set","__classPrivateFieldGet","iterPages","page","asyncIterator","item","Proxy","target","toLowerCase","requestOptionsKeys","isRequestOptions","obj","every","k","hasOwn","getPlatformProperties","Deno","build","normalizePlatform","os","normalizeArch","arch","version","EdgeRuntime","process","prototype","platform","browserInfo","getBrowserInfo","browser","navigator","browserPatterns","pattern","match","exec","userAgent","major","minor","_platformHeaders","startsWithSchemeRegexp","RegExp","test","n","ensurePresent","readEnv","env","coerceInteger","round","coerceFloat","parseFloat","coerceBoolean","Boolean","maybeCoerceInteger","maybeCoerceFloat","maybeCoerceBoolean","_k","hasOwnProperty","action","args","console","log","replace","c","r","v","isRunningInBrowser","window","document","isHeadersProtocol","getRequiredHeader","lowerCasedHeader","intercapsHeader","toUpperCase","substring","_m","g1","g2","isArray","warn","toBase64","str","btoa"],"sources":["/Users/zachjohnson/Desktop/React-Wordle-lesson-16/node_modules/openai/src/core.ts"],"sourcesContent":["import { VERSION } from './version';\nimport { Stream } from './streaming';\nimport {\n  OpenAIError,\n  APIError,\n  APIConnectionError,\n  APIConnectionTimeoutError,\n  APIUserAbortError,\n} from './error';\nimport {\n  kind as shimsKind,\n  type Readable,\n  getDefaultAgent,\n  type Agent,\n  fetch,\n  type RequestInfo,\n  type RequestInit,\n  type Response,\n  type HeadersInit,\n} from './_shims/index';\nexport { type Response };\nimport { isMultipartBody } from './uploads';\nexport {\n  maybeMultipartFormRequestOptions,\n  multipartFormRequestOptions,\n  createForm,\n  type Uploadable,\n} from './uploads';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\ntype APIResponseProps = {\n  response: Response;\n  options: FinalRequestOptions;\n  controller: AbortController;\n};\n\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<T> {\n  const { response } = props;\n  if (props.options.stream) {\n    debug('response', response.status, response.url, response.headers, response.body);\n\n    // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n    return Stream.fromSSEResponse(response, props.controller) as any;\n  }\n\n  // fetch refuses to read the body when the status code is 204.\n  if (response.status === 204) {\n    return null as T;\n  }\n\n  if (props.options.__binaryResponse) {\n    return response as unknown as T;\n  }\n\n  const contentType = response.headers.get('content-type');\n  if (contentType?.includes('application/json')) {\n    const json = await response.json();\n\n    debug('response', response.status, response.url, response.headers, json);\n\n    return json as T;\n  }\n\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text);\n\n  // TODO handle blob, arraybuffer, other content types, etc.\n  return text as unknown as T;\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise<T> extends Promise<T> {\n  private parsedPromise: Promise<T> | undefined;\n\n  constructor(\n    private responsePromise: Promise<APIResponseProps>,\n    private parseResponse: (props: APIResponseProps) => PromiseOrValue<T> = defaultParseResponse,\n  ) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  _thenUnwrap<U>(transform: (data: T) => U): APIPromise<U> {\n    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   *\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\n    }\n    return this.parsedPromise;\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport abstract class APIClient {\n  baseURL: string;\n  maxRetries: number;\n  timeout: number;\n  httpAgent: Agent | undefined;\n\n  private fetch: Fetch;\n  protected idempotencyHeader?: string;\n\n  constructor({\n    baseURL,\n    maxRetries = 2,\n    timeout = 600000, // 10 minutes\n    httpAgent,\n    fetch: overridenFetch,\n  }: {\n    baseURL: string;\n    maxRetries?: number | undefined;\n    timeout: number | undefined;\n    httpAgent: Agent | undefined;\n    fetch: Fetch | undefined;\n  }) {\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n\n    this.fetch = overridenFetch ?? fetch;\n  }\n\n  protected authHeaders(opts: FinalRequestOptions): Headers {\n    return {};\n  }\n\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  protected defaultHeaders(opts: FinalRequestOptions): Headers {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders(opts),\n    };\n  }\n\n  protected abstract defaultQuery(): DefaultQuery | undefined;\n\n  /**\n   * Override this to add your own headers validation:\n   */\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\n\n  protected defaultIdempotencyKey(): string {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n\n  get<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('get', path, opts);\n  }\n\n  post<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('post', path, opts);\n  }\n\n  patch<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('patch', path, opts);\n  }\n\n  put<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('put', path, opts);\n  }\n\n  delete<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('delete', path, opts);\n  }\n\n  private methodRequest<Req extends {}, Rsp>(\n    method: HTTPMethod,\n    path: string,\n    opts?: PromiseOrValue<RequestOptions<Req>>,\n  ): APIPromise<Rsp> {\n    return this.request(Promise.resolve(opts).then((opts) => ({ method, path, ...opts })));\n  }\n\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    path: string,\n    Page: new (...args: any[]) => PageClass,\n    opts?: RequestOptions<any>,\n  ): PagePromise<PageClass, Item> {\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\n  }\n\n  private calculateContentLength(body: unknown): string | null {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    }\n\n    return null;\n  }\n\n  buildRequest<Req extends {}>(\n    options: FinalRequestOptions<Req>,\n  ): { req: RequestInit; url: string; timeout: number } {\n    const { method, path, query, headers: headers = {} } = options;\n\n    const body =\n      isMultipartBody(options.body) ? options.body.body\n      : options.body ? JSON.stringify(options.body, null, 2)\n      : null;\n    const contentLength = this.calculateContentLength(body);\n\n    const url = this.buildURL(path!, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    const timeout = options.timeout ?? this.timeout;\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n    const minAgentTimeout = timeout + 1000;\n    if (\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\n    ) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      (httpAgent as any).options.timeout = minAgentTimeout;\n    }\n\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n\n    const reqHeaders: Record<string, string> = {\n      ...(contentLength && { 'Content-Length': contentLength }),\n      ...this.defaultHeaders(options),\n      ...headers,\n    };\n    // let builtin fetch set the Content-Type for multipart bodies\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\n      delete reqHeaders['Content-Type'];\n    }\n\n    // Strip any headers being explicitly omitted with null\n    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);\n\n    const req: RequestInit = {\n      method,\n      ...(body && { body: body as any }),\n      headers: reqHeaders,\n      ...(httpAgent && { agent: httpAgent }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: options.signal ?? null,\n    };\n\n    this.validateHeaders(reqHeaders, headers);\n\n    return { req, url, timeout };\n  }\n\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  protected async prepareRequest(\n    request: RequestInit,\n    { url, options }: { url: string; options: FinalRequestOptions },\n  ): Promise<void> {}\n\n  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {\n    return (\n      !headers ? {}\n      : Symbol.iterator in headers ?\n        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))\n      : { ...headers }\n    );\n  }\n\n  protected makeStatusError(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ) {\n    return APIError.generate(status, error, message, headers);\n  }\n\n  request<Req extends {}, Rsp>(\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\n    remainingRetries: number | null = null,\n  ): APIPromise<Rsp> {\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n\n  private async makeRequest(\n    optionsInput: PromiseOrValue<FinalRequestOptions>,\n    retriesRemaining: number | null,\n  ): Promise<APIResponseProps> {\n    const options = await optionsInput;\n    if (retriesRemaining == null) {\n      retriesRemaining = options.maxRetries ?? this.maxRetries;\n    }\n\n    const { req, url, timeout } = this.buildRequest(options);\n\n    await this.prepareRequest(req, { url, options });\n\n    debug('request', url, options, req.headers);\n\n    if (options.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n\n    if (response instanceof Error) {\n      if (options.signal?.aborted) {\n        throw new APIUserAbortError();\n      }\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n      if (response.name === 'AbortError') {\n        throw new APIConnectionTimeoutError();\n      }\n      throw new APIConnectionError({ cause: response });\n    }\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n\n      const errText = await response.text().catch((e) => castToError(e).message);\n      const errJSON = safeJSON(errText);\n      const errMessage = errJSON ? undefined : errText;\n\n      debug('response', response.status, url, responseHeaders, errMessage);\n\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n\n    return { response, options, controller };\n  }\n\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n    options: FinalRequestOptions,\n  ): PagePromise<PageClass, Item> {\n    const request = this.makeRequest(options, null);\n    return new PagePromise<PageClass, Item>(this, request, Page);\n  }\n\n  buildURL<Req extends Record<string, unknown>>(path: string, query: Req | null | undefined): string {\n    const url =\n      isAbsoluteURL(path) ?\n        new URL(path)\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n\n    const defaultQuery = this.defaultQuery();\n    if (!isEmptyObj(defaultQuery)) {\n      query = { ...defaultQuery, ...query } as Req;\n    }\n\n    if (query) {\n      url.search = this.stringifyQuery(query);\n    }\n\n    return url.toString();\n  }\n\n  protected stringifyQuery(query: Record<string, unknown>): string {\n    return Object.entries(query)\n      .filter(([_, value]) => typeof value !== 'undefined')\n      .map(([key, value]) => {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n        }\n        if (value === null) {\n          return `${encodeURIComponent(key)}=`;\n        }\n        throw new OpenAIError(\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\n        );\n      })\n      .join('&');\n  }\n\n  async fetchWithTimeout(\n    url: RequestInfo,\n    init: RequestInit | undefined,\n    ms: number,\n    controller: AbortController,\n  ): Promise<Response> {\n    const { signal, ...options } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n\n    const timeout = setTimeout(() => controller.abort(), ms);\n\n    return (\n      this.getRequestClient()\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        .fetch.call(undefined, url, { signal: controller.signal as any, ...options })\n        .finally(() => {\n          clearTimeout(timeout);\n        })\n    );\n  }\n\n  protected getRequestClient(): RequestClient {\n    return { fetch: this.fetch };\n  }\n\n  private shouldRetry(response: Response): boolean {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry');\n\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false;\n\n    // Retry on request timeouts.\n    if (response.status === 408) return true;\n\n    // Retry on lock timeouts.\n    if (response.status === 409) return true;\n\n    // Retry on rate limits.\n    if (response.status === 429) return true;\n\n    // Retry internal errors.\n    if (response.status >= 500) return true;\n\n    return false;\n  }\n\n  private async retryRequest(\n    options: FinalRequestOptions,\n    retriesRemaining: number,\n    responseHeaders?: Headers | undefined,\n  ): Promise<APIResponseProps> {\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    let timeoutMillis: number | undefined;\n    const retryAfterHeader = responseHeaders?.['retry-after'];\n    if (retryAfterHeader) {\n      const timeoutSeconds = parseInt(retryAfterHeader);\n      if (!Number.isNaN(timeoutSeconds)) {\n        timeoutMillis = timeoutSeconds * 1000;\n      } else {\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n      }\n    }\n\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says, but otherwise calculate a default\n    if (\n      !timeoutMillis ||\n      !Number.isInteger(timeoutMillis) ||\n      timeoutMillis <= 0 ||\n      timeoutMillis > 60 * 1000\n    ) {\n      const maxRetries = options.maxRetries ?? this.maxRetries;\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n    }\n    await sleep(timeoutMillis);\n\n    return this.makeRequest(options, retriesRemaining - 1);\n  }\n\n  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 8.0;\n\n    const numRetries = maxRetries - retriesRemaining;\n\n    // Apply exponential backoff, but not more than the max.\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n\n    // Apply some jitter, take up to at most 25 percent of the retry time.\n    const jitter = 1 - Math.random() * 0.25;\n\n    return sleepSeconds * jitter * 1000;\n  }\n\n  private getUserAgent(): string {\n    return `${this.constructor.name}/JS ${VERSION}`;\n  }\n}\n\nexport class APIResource {\n  protected client: APIClient;\n  constructor(client: APIClient) {\n    this.client = client;\n\n    this.get = client.get.bind(client);\n    this.post = client.post.bind(client);\n    this.patch = client.patch.bind(client);\n    this.put = client.put.bind(client);\n    this.delete = client.delete.bind(client);\n    this.getAPIList = client.getAPIList.bind(client);\n  }\n\n  protected get: APIClient['get'];\n  protected post: APIClient['post'];\n  protected patch: APIClient['patch'];\n  protected put: APIClient['put'];\n  protected delete: APIClient['delete'];\n  protected getAPIList: APIClient['getAPIList'];\n}\n\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\n\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\n  #client: APIClient;\n  protected options: FinalRequestOptions;\n\n  protected response: Response;\n  protected body: unknown;\n\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\n    this.#client = client;\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n\n  /**\n   * @deprecated Use nextPageInfo instead\n   */\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\n  abstract nextPageInfo(): PageInfo | null;\n\n  abstract getPaginatedItems(): Item[];\n\n  hasNextPage(): boolean {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n\n  async getNextPage(): Promise<this> {\n    const nextInfo = this.nextPageInfo();\n    if (!nextInfo) {\n      throw new OpenAIError(\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\n      );\n    }\n    const nextOptions = { ...this.options };\n    if ('params' in nextInfo) {\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value as any);\n      }\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: AbstractPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise<\n    PageClass extends AbstractPage<Item>,\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\n  >\n  extends APIPromise<PageClass>\n  implements AsyncIterable<Item>\n{\n  constructor(\n    client: APIClient,\n    request: Promise<APIResponseProps>,\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n  ) {\n    super(\n      request,\n      async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options),\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport const createResponseHeaders = (\n  headers: Awaited<ReturnType<Fetch>>['headers'],\n): Record<string, string> => {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries(),\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    },\n  );\n};\n\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\n\nexport type RequestClient = { fetch: Fetch };\nexport type Headers = Record<string, string | null | undefined>;\nexport type DefaultQuery = Record<string, string | undefined>;\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\n\nexport type RequestOptions<Req extends {} = Record<string, unknown> | Readable> = {\n  method?: HTTPMethod;\n  path?: string;\n  query?: Req | undefined;\n  body?: Req | undefined;\n  headers?: Headers | undefined;\n\n  maxRetries?: number;\n  stream?: boolean | undefined;\n  timeout?: number;\n  httpAgent?: Agent;\n  signal?: AbortSignal | undefined | null;\n  idempotencyKey?: string;\n\n  __binaryResponse?: boolean | undefined;\n};\n\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true,\n\n  __binaryResponse: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions<Record<string, unknown> | Readable> => {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\nexport type FinalRequestOptions<Req extends {} = Record<string, unknown> | Readable> = RequestOptions<Req> & {\n  method: HTTPMethod;\n  path: string;\n};\n\ndeclare const Deno: any;\ndeclare const EdgeRuntime: any;\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\ntype PlatformName =\n  | 'MacOS'\n  | 'Linux'\n  | 'Windows'\n  | 'FreeBSD'\n  | 'OpenBSD'\n  | 'iOS'\n  | 'Android'\n  | `Other:${string}`\n  | 'Unknown';\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\ntype PlatformProperties = {\n  'X-Stainless-Lang': 'js';\n  'X-Stainless-Package-Version': string;\n  'X-Stainless-OS': PlatformName;\n  'X-Stainless-Arch': Arch;\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\n  'X-Stainless-Runtime-Version': string;\n};\nconst getPlatformProperties = (): PlatformProperties => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version': Deno.version,\n    };\n  }\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n  // Check if Node.js\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n\n  const browserInfo = getBrowserInfo();\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version,\n    };\n  }\n\n  // TODO add support for Cloudflare workers, etc.\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown',\n  };\n};\n\ntype BrowserInfo = {\n  browser: Browser;\n  version: string;\n};\n\ndeclare const navigator: { userAgent: string } | undefined;\n\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo(): BrowserInfo | null {\n  if (typeof navigator === 'undefined' || !navigator) {\n    return null;\n  }\n\n  // NOTE: The order matters here!\n  const browserPatterns = [\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n  ];\n\n  // Find the FIRST matching browser\n  for (const { key, pattern } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n\n      return { browser: key, version: `${major}.${minor}.${patch}` };\n    }\n  }\n\n  return null;\n}\n\nconst normalizeArch = (arch: string): Arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\n\nconst normalizePlatform = (platform: string): PlatformName => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n\n  platform = platform.toLowerCase();\n\n  // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\n\nlet _platformHeaders: PlatformProperties;\nconst getPlatformHeaders = () => {\n  return (_platformHeaders ??= getPlatformProperties());\n};\n\nexport const safeJSON = (text: string) => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n};\n\n// https://stackoverflow.com/a/19709846\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\nconst isAbsoluteURL = (url: string): boolean => {\n  return startsWithSchemeRegexp.test(url);\n};\n\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst validatePositiveInteger = (name: string, n: unknown): number => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new OpenAIError(`${name} must be an integer`);\n  }\n  if (n < 0) {\n    throw new OpenAIError(`${name} must be a positive integer`);\n  }\n  return n;\n};\n\nexport const castToError = (err: any): Error => {\n  if (err instanceof Error) return err;\n  return new Error(err);\n};\n\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\n  if (value == null) throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\n\n/**\n * Read an environment variable.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env: string): string | undefined => {\n  if (typeof process !== 'undefined') {\n    return process.env?.[env] ?? undefined;\n  }\n  if (typeof Deno !== 'undefined') {\n    return Deno.env?.get?.(env);\n  }\n  return undefined;\n};\n\nexport const coerceInteger = (value: unknown): number => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceFloat = (value: unknown): number => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceBoolean = (value: unknown): boolean => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\n\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceInteger(value);\n};\n\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceFloat(value);\n};\n\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceBoolean(value);\n};\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function debug(action: string, ...args: any[]) {\n  if (typeof process !== 'undefined' && process.env['DEBUG'] === 'true') {\n    console.log(`OpenAI:DEBUG:${action}`, ...args);\n  }\n}\n\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nexport const isRunningInBrowser = () => {\n  return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n    // @ts-ignore\n    typeof window.document !== 'undefined' &&\n    // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\n\nexport interface HeadersProtocol {\n  get: (header: string) => string | null | undefined;\n}\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\n\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\n  return typeof headers?.get === 'function';\n};\n\nexport const getRequiredHeader = (headers: HeadersLike, header: string): string => {\n  const lowerCasedHeader = header.toLowerCase();\n  if (isHeadersProtocol(headers)) {\n    // to deal with the case where the header looks like Stainless-Event-Id\n    const intercapsHeader =\n      header[0]?.toUpperCase() +\n      header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n      const value = headers.get(key);\n      if (value) {\n        return value;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(headers)) {\n    if (key.toLowerCase() === lowerCasedHeader) {\n      if (Array.isArray(value)) {\n        if (value.length <= 1) return value[0];\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n        return value[0];\n      }\n      return value;\n    }\n  }\n\n  throw new Error(`Could not find ${header} header`);\n};\n\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str: string | null | undefined): string => {\n  if (!str) return '';\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n\n  throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\n"]},"metadata":{},"sourceType":"module"}