{"ast":null,"code":"import { ReadableStream } from \"./_shims/index.mjs\";\nimport { OpenAIError } from \"./error.mjs\";\nimport { APIError } from 'openai/error';\nexport class Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    const decoder = new SSEDecoder();\n\n    async function* iterMessages() {\n      if (!response.body) {\n        controller.abort();\n        throw new OpenAIError(`Attempted to iterate over a response with no body`);\n      }\n\n      const lineDecoder = new LineDecoder();\n      const iter = readableStreamAsyncIterable(response.body);\n\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          const sse = decoder.decode(line);\n          if (sse) yield sse;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        const sse = decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    async function* iterator() {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n\n      consumed = true;\n      let done = false;\n\n      try {\n        for await (const sse of iterMessages()) {\n          if (done) continue;\n\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n\n          if (sse.event === null) {\n            let data;\n\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n\n            if (data && data.error) {\n              throw new APIError(undefined, data.error, undefined, undefined);\n            }\n\n            yield data;\n          }\n        }\n\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n\n\n  static fromReadableStream(readableStream, controller) {\n    let consumed = false;\n\n    async function* iterLines() {\n      const lineDecoder = new LineDecoder();\n      const iter = readableStreamAsyncIterable(readableStream);\n\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator() {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n\n      consumed = true;\n      let done = false;\n\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n\n\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n\n          return queue.shift();\n        }\n      };\n    };\n\n    return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];\n  }\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n\n\n  toReadableStream() {\n    const self = this;\n    let iter;\n    const encoder = new TextEncoder();\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n\n      async cancel() {\n        await iter.return?.();\n      }\n\n    });\n  }\n\n}\n\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n\n}\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\n\n\nclass LineDecoder {\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk) {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes) {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes; // Node:\n\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n    } // Browser\n\n\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n    }\n\n    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n  }\n\n  flush() {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n\n} // prettier-ignore\n\n\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\n\n\nfunction readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n\n        throw e;\n      }\n    },\n\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}","map":{"version":3,"mappings":"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","names":["ReadableStream","OpenAIError","APIError","Stream","constructor","iterator","controller","fromSSEResponse","response","consumed","decoder","SSEDecoder","iterMessages","body","abort","lineDecoder","LineDecoder","iter","readableStreamAsyncIterable","chunk","line","decode","sse","flush","Error","done","data","startsWith","event","JSON","parse","e","console","error","raw","undefined","name","fromReadableStream","readableStream","iterLines","Symbol","asyncIterator","tee","left","right","teeIterator","queue","next","length","result","push","shift","toReadableStream","self","encoder","TextEncoder","start","pull","ctrl","value","close","bytes","encode","stringify","enqueue","err","cancel","return","chunks","endsWith","substring","join","fieldname","_","partition","buffer","trailingCR","text","decodeText","slice","trailingNewline","NEWLINE_CHARS","has","lines","split","NEWLINE_REGEXP","pop","Buffer","toString","Uint8Array","from","TextDecoder","ArrayBuffer","textDecoder","Set","str","delimiter","index","indexOf","stream","reader","getReader","read","releaseLock","cancelPromise"],"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/openai/src/streaming.ts"],"sourcesContent":["import { ReadableStream, type Response } from './_shims/index';\nimport { OpenAIError } from './error';\n\nimport { APIError } from \"./error\";\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\ntype ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  constructor(private iterator: () => AsyncIterator<Item>, controller: AbortController) {\n    this.controller = controller;\n  }\n\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\n    let consumed = false;\n    const decoder = new SSEDecoder();\n\n    async function* iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\n      if (!response.body) {\n        controller.abort();\n        throw new OpenAIError(`Attempted to iterate over a response with no body`);\n      }\n\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(response.body);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          const sse = decoder.decode(line);\n          if (sse) yield sse;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        const sse = decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of iterMessages()) {\n          if (done) continue;\n\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n\n          if (sse.event === null) {\n            let data;\n\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n\n            if (data && data.error) {\n              throw new APIError(undefined, data.error, undefined, undefined);\n            }\n\n            yield data;\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\n    let consumed = false;\n\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\n    return this.iterator();\n  }\n\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee(): [Stream<Item>, Stream<Item>] {\n    const left: Array<Promise<IteratorResult<Item>>> = [];\n    const right: Array<Promise<IteratorResult<Item>>> = [];\n    const iterator = this.iterator();\n\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift()!;\n        },\n      };\n    };\n\n    return [\n      new Stream(() => teeIterator(left), this.controller),\n      new Stream(() => teeIterator(right), this.controller),\n    ];\n  }\n\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream(): ReadableStream {\n    const self = this;\n    let iter: AsyncIterator<Item>;\n    const encoder = new TextEncoder();\n\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const { value, done } = await iter.next();\n          if (done) return ctrl.close();\n\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      },\n    });\n  }\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new OpenAIError(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new OpenAIError(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new OpenAIError(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}