{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\n\nconst forEachBail = require(\"./forEachBail\");\n\nconst {\n  processImportsField\n} = require(\"./util/entrypoints\");\n\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\n\nconst {\n  checkImportsExportsFieldTarget\n} = require(\"./util/path\");\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\n\nconst dotCode = \".\".charCodeAt(0);\nmodule.exports = class ImportsFieldPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} targetFile target file\n   * @param {string | ResolveStepHook} targetPackage target package\n   */\n  constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage) {\n    this.source = source;\n    this.targetFile = targetFile;\n    this.targetPackage = targetPackage;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<JsonObject, FieldProcessor>} */\n\n    this.fieldProcessorCache = new WeakMap();\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  apply(resolver) {\n    const targetFile = resolver.ensureHook(this.targetFile);\n    const targetPackage = resolver.ensureHook(this.targetPackage);\n    resolver.getHook(this.source).tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n      // When there is no description file, abort\n      if (!request.descriptionFilePath || request.request === undefined) {\n        return callback();\n      }\n\n      const remainingRequest = request.request + request.query + request.fragment;\n      const importsField =\n      /** @type {ImportsField|null|undefined} */\n      DescriptionFileUtils.getField(\n      /** @type {JsonObject} */\n      request.descriptionFileData, this.fieldName);\n      if (!importsField) return callback();\n\n      if (request.directory) {\n        return callback(new Error(`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`));\n      }\n      /** @type {string[]} */\n\n\n      let paths;\n\n      try {\n        // We attach the cache to the description file instead of the importsField value\n        // because we use a WeakMap and the importsField could be a string too.\n        // Description file is always an object when exports field can be accessed.\n        let fieldProcessor = this.fieldProcessorCache.get(\n        /** @type {JsonObject} */\n        request.descriptionFileData);\n\n        if (fieldProcessor === undefined) {\n          fieldProcessor = processImportsField(importsField);\n          this.fieldProcessorCache.set(\n          /** @type {JsonObject} */\n          request.descriptionFileData, fieldProcessor);\n        }\n\n        paths = fieldProcessor(remainingRequest, this.conditionNames);\n      } catch (\n      /** @type {unknown} */\n      err) {\n        if (resolveContext.log) {\n          resolveContext.log(`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`);\n        }\n\n        return callback(\n        /** @type {Error} */\n        err);\n      }\n\n      if (paths.length === 0) {\n        return callback(new Error(`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`));\n      }\n\n      forEachBail(paths,\n      /**\n       * @param {string} p path\n       * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n       * @returns {void}\n       */\n      (p, callback) => {\n        const parsedIdentifier = parseIdentifier(p);\n        if (!parsedIdentifier) return callback();\n        const [path_, query, fragment] = parsedIdentifier;\n        const error = checkImportsExportsFieldTarget(path_);\n\n        if (error) {\n          return callback(error);\n        }\n\n        switch (path_.charCodeAt(0)) {\n          // should be relative\n          case dotCode:\n            {\n              /** @type {ResolveRequest} */\n              const obj = { ...request,\n                request: undefined,\n                path: path.join(\n                /** @type {string} */\n                request.descriptionFileRoot, path_),\n                relativePath: path_,\n                query,\n                fragment\n              };\n              resolver.doResolve(targetFile, obj, \"using imports field: \" + p, resolveContext, callback);\n              break;\n            }\n          // package resolving\n\n          default:\n            {\n              /** @type {ResolveRequest} */\n              const obj = { ...request,\n                request: path_,\n                relativePath: path_,\n                fullySpecified: true,\n                query,\n                fragment\n              };\n              resolver.doResolve(targetPackage, obj, \"using imports field: \" + p, resolveContext, callback);\n            }\n        }\n      },\n      /**\n       * @param {null|Error} [err] error\n       * @param {null|ResolveRequest} [result] result\n       * @returns {void}\n       */\n      (err, result) => callback(err, result || null));\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js"],"names":["path","require","DescriptionFileUtils","forEachBail","processImportsField","parseIdentifier","checkImportsExportsFieldTarget","dotCode","charCodeAt","module","exports","ImportsFieldPlugin","constructor","source","conditionNames","fieldNamePath","targetFile","targetPackage","fieldName","fieldProcessorCache","WeakMap","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","undefined","remainingRequest","query","fragment","importsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","path_","error","obj","join","relativePath","doResolve","fullySpecified","result"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processImportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst { checkImportsExportsFieldTarget } = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\nconst dotCode = \".\".charCodeAt(0);\n\nmodule.exports = class ImportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} targetFile target file\n\t * @param {string | ResolveStepHook} targetPackage target package\n\t */\n\tconstructor(\n\t\tsource,\n\t\tconditionNames,\n\t\tfieldNamePath,\n\t\ttargetFile,\n\t\ttargetPackage\n\t) {\n\t\tthis.source = source;\n\t\tthis.targetFile = targetFile;\n\t\tthis.targetPackage = targetPackage;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<JsonObject, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst targetFile = resolver.ensureHook(this.targetFile);\n\t\tconst targetPackage = resolver.ensureHook(this.targetPackage);\n\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath || request.request === undefined) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.request + request.query + request.fragment;\n\t\t\t\tconst importsField =\n\t\t\t\t\t/** @type {ImportsField|null|undefined} */\n\t\t\t\t\t(\n\t\t\t\t\t\tDescriptionFileUtils.getField(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tthis.fieldName\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\tif (!importsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tlet paths;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the importsField value\n\t\t\t\t\t// because we use a WeakMap and the importsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData)\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processImportsField(importsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tfieldProcessor\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\n\t\t\t\t} catch (/** @type {unknown} */ err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(/** @type {Error} */ (err));\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} p path\n\t\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(p, callback) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [path_, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tconst error = checkImportsExportsFieldTarget(path_);\n\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (path_.charCodeAt(0)) {\n\t\t\t\t\t\t\t// should be relative\n\t\t\t\t\t\t\tcase dotCode: {\n\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\t\t\tpath: path.join(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\t\t\tpath_\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetFile,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\"using imports field: \" + p,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// package resolving\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: path_,\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tfullySpecified: true,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetPackage,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\"using imports field: \" + p,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {null|Error} [err] error\n\t\t\t\t\t * @param {null|ResolveRequest} [result] result\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(err, result) => callback(err, result || null)\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}