{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  AsyncSeriesBailHook,\n  AsyncSeriesHook,\n  SyncHook\n} = require(\"tapable\");\n\nconst createInnerContext = require(\"./createInnerContext\");\n\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\n\nconst {\n  normalize,\n  cachedJoin: join,\n  getType,\n  PathType\n} = require(\"./util/path\");\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/** @typedef {Error & {details?: string}} ErrorWithDetail */\n\n/** @typedef {(err: ErrorWithDetail|null, res?: string|false, req?: ResolveRequest) => void} ResolveCallback */\n\n/**\n * @typedef {Object} FileSystemStats\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} FileSystemDirent\n * @property {Buffer | string} name\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} PossibleFileSystemError\n * @property {string=} code\n * @property {number=} errno\n * @property {string=} path\n * @property {string=} syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null | undefined} err\n * @param {T=} result\n */\n\n/** @typedef {function((NodeJS.ErrnoException | null)=, (string | Buffer)[] | import(\"fs\").Dirent[]=): void} DirentArrayCallback */\n\n/**\n * @typedef {Object} ReaddirOptions\n * @property {BufferEncoding | null | 'buffer'} [encoding]\n * @property {boolean | undefined} [withFileTypes=false]\n */\n\n/**\n * @typedef {Object} FileSystem\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readFile\n * @property {function(string, (ReaddirOptions | BufferEncoding | null | undefined | 'buffer' | DirentArrayCallback)=,  DirentArrayCallback=): void} readdir\n * @property {((function(string, FileSystemCallback<object>): void) & function(string, object, FileSystemCallback<object>): void)=} readJson\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readlink\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void=} lstat\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} stat\n */\n\n/**\n * @typedef {Object} SyncFileSystem\n * @property {function(string, object=): Buffer | string} readFileSync\n * @property {function(string, object=): (Buffer | string)[] | FileSystemDirent[]} readdirSync\n * @property {(function(string, object=): object)=} readJsonSync\n * @property {function(string, object=): Buffer | string} readlinkSync\n * @property {function(string, object=): FileSystemStats=} lstatSync\n * @property {function(string, object=): FileSystemStats} statSync\n */\n\n/**\n * @typedef {Object} ParsedIdentifier\n * @property {string} request\n * @property {string} query\n * @property {string} fragment\n * @property {boolean} directory\n * @property {boolean} module\n * @property {boolean} file\n * @property {boolean} internal\n */\n\n/** @typedef {string | number | boolean | null} JsonPrimitive */\n\n/** @typedef {JsonValue[]} JsonArray */\n\n/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */\n\n/** @typedef {{[Key in string]: JsonValue} & {[Key in string]?: JsonValue | undefined}} JsonObject */\n\n/**\n * @typedef {Object} BaseResolveRequest\n * @property {string | false} path\n * @property {object=} context\n * @property {string=} descriptionFilePath\n * @property {string=} descriptionFileRoot\n * @property {JsonObject=} descriptionFileData\n * @property {string=} relativePath\n * @property {boolean=} ignoreSymlinks\n * @property {boolean=} fullySpecified\n * @property {string=} __innerRequest\n * @property {string=} __innerRequest_request\n * @property {string=} __innerRequest_relativePath\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/**\n * @template T\n * @typedef {{ add: (item: T) => void }} WriteOnlySet\n */\n\n/** @typedef {(function (ResolveRequest): void)} ResolveContextYield */\n\n/**\n * Resolve context\n * @typedef {Object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {(function(string): void)=} log log function\n * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @typedef {Object} KnownHooks\n * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep\n * @property {SyncHook<[ResolveRequest, Error]>} noResolve\n * @property {ResolveStepHook} resolve\n * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result\n */\n\n/**\n * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks\n */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, str => str.slice(1).toUpperCase());\n}\n\nclass Resolver {\n  /**\n   * @param {ResolveStepHook} hook hook\n   * @param {ResolveRequest} request request\n   * @returns {StackEntry} stack entry\n   */\n  static createStackEntry(hook, request) {\n    return hook.name + \": (\" + request.path + \") \" + (request.request || \"\") + (request.query || \"\") + (request.fragment || \"\") + (request.directory ? \" directory\" : \"\") + (request.module ? \" module\" : \"\");\n  }\n  /**\n   * @param {FileSystem} fileSystem a filesystem\n   * @param {ResolveOptions} options options\n   */\n\n\n  constructor(fileSystem, options) {\n    this.fileSystem = fileSystem;\n    this.options = options;\n    /** @type {KnownHooks} */\n\n    this.hooks = {\n      resolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n      noResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n      resolve: new AsyncSeriesBailHook([\"request\", \"resolveContext\"], \"resolve\"),\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n    };\n  }\n  /**\n   * @param {string | ResolveStepHook} name hook name or hook itself\n   * @returns {ResolveStepHook} the hook\n   */\n\n\n  ensureHook(name) {\n    if (typeof name !== \"string\") {\n      return name;\n    }\n\n    name = toCamelCase(name);\n\n    if (/^before/.test(name)) {\n      return (\n        /** @type {ResolveStepHook} */\n        this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n          stage: -10\n        })\n      );\n    }\n\n    if (/^after/.test(name)) {\n      return (\n        /** @type {ResolveStepHook} */\n        this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n          stage: 10\n        })\n      );\n    }\n    /** @type {ResolveStepHook} */\n\n\n    const hook =\n    /** @type {KnownHooks & EnsuredHooks} */\n    this.hooks[name];\n\n    if (!hook) {\n      /** @type {KnownHooks & EnsuredHooks} */\n      this.hooks[name] = new AsyncSeriesBailHook([\"request\", \"resolveContext\"], name);\n      return (\n        /** @type {KnownHooks & EnsuredHooks} */\n        this.hooks[name]\n      );\n    }\n\n    return hook;\n  }\n  /**\n   * @param {string | ResolveStepHook} name hook name or hook itself\n   * @returns {ResolveStepHook} the hook\n   */\n\n\n  getHook(name) {\n    if (typeof name !== \"string\") {\n      return name;\n    }\n\n    name = toCamelCase(name);\n\n    if (/^before/.test(name)) {\n      return (\n        /** @type {ResolveStepHook} */\n        this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n          stage: -10\n        })\n      );\n    }\n\n    if (/^after/.test(name)) {\n      return (\n        /** @type {ResolveStepHook} */\n        this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n          stage: 10\n        })\n      );\n    }\n    /** @type {ResolveStepHook} */\n\n\n    const hook =\n    /** @type {KnownHooks & EnsuredHooks} */\n    this.hooks[name];\n\n    if (!hook) {\n      throw new Error(`Hook ${name} doesn't exist`);\n    }\n\n    return hook;\n  }\n  /**\n   * @param {object} context context information object\n   * @param {string} path context path\n   * @param {string} request request string\n   * @returns {string | false} result\n   */\n\n\n  resolveSync(context, path, request) {\n    /** @type {Error | null | undefined} */\n    let err = undefined;\n    /** @type {string | false | undefined} */\n\n    let result = undefined;\n    let sync = false;\n    this.resolve(context, path, request, {}, (e, r) => {\n      err = e;\n      result = r;\n      sync = true;\n    });\n\n    if (!sync) {\n      throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n    }\n\n    if (err) throw err;\n    if (result === undefined) throw new Error(\"No result\");\n    return result;\n  }\n  /**\n   * @param {object} context context information object\n   * @param {string} path context path\n   * @param {string} request request string\n   * @param {ResolveContext} resolveContext resolve context\n   * @param {ResolveCallback} callback callback function\n   * @returns {void}\n   */\n\n\n  resolve(context, path, request, resolveContext, callback) {\n    if (!context || typeof context !== \"object\") return callback(new Error(\"context argument is not an object\"));\n    if (typeof path !== \"string\") return callback(new Error(\"path argument is not a string\"));\n    if (typeof request !== \"string\") return callback(new Error(\"request argument is not a string\"));\n    if (!resolveContext) return callback(new Error(\"resolveContext argument is not set\"));\n    /** @type {ResolveRequest} */\n\n    const obj = {\n      context: context,\n      path: path,\n      request: request\n    };\n    /** @type {ResolveContextYield | undefined} */\n\n    let yield_;\n    let yieldCalled = false;\n    /** @type {ResolveContextYield | undefined} */\n\n    let finishYield;\n\n    if (typeof resolveContext.yield === \"function\") {\n      const old = resolveContext.yield;\n      /**\n       * @param {ResolveRequest} obj object\n       */\n\n      yield_ = obj => {\n        old(obj);\n        yieldCalled = true;\n      };\n      /**\n       * @param {ResolveRequest} result result\n       * @returns {void}\n       */\n\n\n      finishYield = result => {\n        if (result) {\n          /** @type {ResolveContextYield} */\n          yield_(result);\n        }\n\n        callback(null);\n      };\n    }\n\n    const message = `resolve '${request}' in '${path}'`;\n    /**\n     * @param {ResolveRequest} result result\n     * @returns {void}\n     */\n\n    const finishResolved = result => {\n      return callback(null, result.path === false ? false : `${result.path.replace(/#/g, \"\\0#\")}${result.query ? result.query.replace(/#/g, \"\\0#\") : \"\"}${result.fragment || \"\"}`, result);\n    };\n    /**\n     * @param {string[]} log logs\n     * @returns {void}\n     */\n\n\n    const finishWithoutResolve = log => {\n      /**\n       * @type {ErrorWithDetail}\n       */\n      const error = new Error(\"Can't \" + message);\n      error.details = log.join(\"\\n\");\n      this.hooks.noResolve.call(obj, error);\n      return callback(error);\n    };\n\n    if (resolveContext.log) {\n      // We need log anyway to capture it in case of an error\n      const parentLog = resolveContext.log;\n      /** @type {string[]} */\n\n      const log = [];\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: msg => {\n          parentLog(msg);\n          log.push(msg);\n        },\n        yield: yield_,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n\n        if (yieldCalled || result && yield_) {\n          return (\n            /** @type {ResolveContextYield} */\n            finishYield(\n            /** @type {ResolveRequest} */\n            result)\n          );\n        }\n\n        if (result) return finishResolved(result);\n        return finishWithoutResolve(log);\n      });\n    } else {\n      // Try to resolve assuming there is no error\n      // We don't log stuff in this case\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: undefined,\n        yield: yield_,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n\n        if (yieldCalled || result && yield_) {\n          return (\n            /** @type {ResolveContextYield} */\n            finishYield(\n            /** @type {ResolveRequest} */\n            result)\n          );\n        }\n\n        if (result) return finishResolved(result); // log is missing for the error details\n        // so we redo the resolving for the log info\n        // this is more expensive to the success case\n        // is assumed by default\n\n        /** @type {string[]} */\n\n        const log = [];\n        return this.doResolve(this.hooks.resolve, obj, message, {\n          log: msg => log.push(msg),\n          yield: yield_,\n          stack: resolveContext.stack\n        }, (err, result) => {\n          if (err) return callback(err); // In a case that there is a race condition and yield will be called\n\n          if (yieldCalled || result && yield_) {\n            return (\n              /** @type {ResolveContextYield} */\n              finishYield(\n              /** @type {ResolveRequest} */\n              result)\n            );\n          }\n\n          return finishWithoutResolve(log);\n        });\n      });\n    }\n  }\n  /**\n   * @param {ResolveStepHook} hook hook\n   * @param {ResolveRequest} request request\n   * @param {null|string} message string\n   * @param {ResolveContext} resolveContext resolver context\n   * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback\n   * @returns {void}\n   */\n\n\n  doResolve(hook, request, message, resolveContext, callback) {\n    const stackEntry = Resolver.createStackEntry(hook, request);\n    /** @type {Set<string> | undefined} */\n\n    let newStack;\n\n    if (resolveContext.stack) {\n      newStack = new Set(resolveContext.stack);\n\n      if (resolveContext.stack.has(stackEntry)) {\n        /**\n         * Prevent recursion\n         * @type {Error & {recursion?: boolean}}\n         */\n        const recursionError = new Error(\"Recursion in resolving\\nStack:\\n  \" + Array.from(newStack).join(\"\\n  \"));\n        recursionError.recursion = true;\n        if (resolveContext.log) resolveContext.log(\"abort resolving because of recursion\");\n        return callback(recursionError);\n      }\n\n      newStack.add(stackEntry);\n    } else {\n      newStack = new Set([stackEntry]);\n    }\n\n    this.hooks.resolveStep.call(hook, request);\n\n    if (hook.isUsed()) {\n      const innerContext = createInnerContext({\n        log: resolveContext.log,\n        yield: resolveContext.yield,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: newStack\n      }, message);\n      return hook.callAsync(request, innerContext, (err, result) => {\n        if (err) return callback(err);\n        if (result) return callback(null, result);\n        callback();\n      });\n    } else {\n      callback();\n    }\n  }\n  /**\n   * @param {string} identifier identifier\n   * @returns {ParsedIdentifier} parsed identifier\n   */\n\n\n  parse(identifier) {\n    const part = {\n      request: \"\",\n      query: \"\",\n      fragment: \"\",\n      module: false,\n      directory: false,\n      file: false,\n      internal: false\n    };\n    const parsedIdentifier = parseIdentifier(identifier);\n    if (!parsedIdentifier) return part;\n    [part.request, part.query, part.fragment] = parsedIdentifier;\n\n    if (part.request.length > 0) {\n      part.internal = this.isPrivate(identifier);\n      part.module = this.isModule(part.request);\n      part.directory = this.isDirectory(part.request);\n\n      if (part.directory) {\n        part.request = part.request.slice(0, -1);\n      }\n    }\n\n    return part;\n  }\n  /**\n   * @param {string} path path\n   * @returns {boolean} true, if the path is a module\n   */\n\n\n  isModule(path) {\n    return getType(path) === PathType.Normal;\n  }\n  /**\n   * @param {string} path path\n   * @returns {boolean} true, if the path is private\n   */\n\n\n  isPrivate(path) {\n    return getType(path) === PathType.Internal;\n  }\n  /**\n   * @param {string} path a path\n   * @returns {boolean} true, if the path is a directory path\n   */\n\n\n  isDirectory(path) {\n    return path.endsWith(\"/\");\n  }\n  /**\n   * @param {string} path path\n   * @param {string} request request\n   * @returns {string} joined path\n   */\n\n\n  join(path, request) {\n    return join(path, request);\n  }\n  /**\n   * @param {string} path path\n   * @returns {string} normalized path\n   */\n\n\n  normalize(path) {\n    return normalize(path);\n  }\n\n}\n\nmodule.exports = Resolver;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/enhanced-resolve/lib/Resolver.js"],"names":["AsyncSeriesBailHook","AsyncSeriesHook","SyncHook","require","createInnerContext","parseIdentifier","normalize","cachedJoin","join","getType","PathType","toCamelCase","str","replace","slice","toUpperCase","Resolver","createStackEntry","hook","request","name","path","query","fragment","directory","module","constructor","fileSystem","options","hooks","resolveStep","noResolve","resolve","result","ensureHook","test","toLowerCase","withOptions","stage","getHook","Error","resolveSync","context","err","undefined","sync","e","r","resolveContext","callback","obj","yield_","yieldCalled","finishYield","yield","old","message","finishResolved","finishWithoutResolve","log","error","details","call","parentLog","doResolve","msg","push","fileDependencies","contextDependencies","missingDependencies","stack","stackEntry","newStack","Set","has","recursionError","Array","from","recursion","add","isUsed","innerContext","callAsync","parse","identifier","part","file","internal","parsedIdentifier","length","isPrivate","isModule","isDirectory","Normal","Internal","endsWith","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA,mBAAF;AAAuBC,EAAAA,eAAvB;AAAwCC,EAAAA;AAAxC,IAAqDC,OAAO,CAAC,SAAD,CAAlE;;AACA,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,sBAAD,CAAlC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAsBF,OAAO,CAAC,mBAAD,CAAnC;;AACA,MAAM;AACLG,EAAAA,SADK;AAELC,EAAAA,UAAU,EAAEC,IAFP;AAGLC,EAAAA,OAHK;AAILC,EAAAA;AAJK,IAKFP,OAAO,CAAC,aAAD,CALX;AAOA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,SAASQ,WAAT,CAAqBC,GAArB,EAA0B;AACzB,SAAOA,GAAG,CAACC,OAAJ,CAAY,WAAZ,EAAyBD,GAAG,IAAIA,GAAG,CAACE,KAAJ,CAAU,CAAV,EAAaC,WAAb,EAAhC,CAAP;AACA;;AAED,MAAMC,QAAN,CAAe;AACd;AACD;AACA;AACA;AACA;AACwB,SAAhBC,gBAAgB,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACtC,WACCD,IAAI,CAACE,I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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require(\"tapable\");\nconst createInnerContext = require(\"./createInnerContext\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst {\n\tnormalize,\n\tcachedJoin: join,\n\tgetType,\n\tPathType\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/** @typedef {Error & {details?: string}} ErrorWithDetail */\n\n/** @typedef {(err: ErrorWithDetail|null, res?: string|false, req?: ResolveRequest) => void} ResolveCallback */\n\n/**\n * @typedef {Object} FileSystemStats\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} FileSystemDirent\n * @property {Buffer | string} name\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} PossibleFileSystemError\n * @property {string=} code\n * @property {number=} errno\n * @property {string=} path\n * @property {string=} syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null | undefined} err\n * @param {T=} result\n */\n\n/** @typedef {function((NodeJS.ErrnoException | null)=, (string | Buffer)[] | import(\"fs\").Dirent[]=): void} DirentArrayCallback */\n\n/**\n * @typedef {Object} ReaddirOptions\n * @property {BufferEncoding | null | 'buffer'} [encoding]\n * @property {boolean | undefined} [withFileTypes=false]\n */\n\n/**\n * @typedef {Object} FileSystem\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readFile\n * @property {function(string, (ReaddirOptions | BufferEncoding | null | undefined | 'buffer' | DirentArrayCallback)=,  DirentArrayCallback=): void} readdir\n * @property {((function(string, FileSystemCallback<object>): void) & function(string, object, FileSystemCallback<object>): void)=} readJson\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readlink\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void=} lstat\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} stat\n */\n\n/**\n * @typedef {Object} SyncFileSystem\n * @property {function(string, object=): Buffer | string} readFileSync\n * @property {function(string, object=): (Buffer | string)[] | FileSystemDirent[]} readdirSync\n * @property {(function(string, object=): object)=} readJsonSync\n * @property {function(string, object=): Buffer | string} readlinkSync\n * @property {function(string, object=): FileSystemStats=} lstatSync\n * @property {function(string, object=): FileSystemStats} statSync\n */\n\n/**\n * @typedef {Object} ParsedIdentifier\n * @property {string} request\n * @property {string} query\n * @property {string} fragment\n * @property {boolean} directory\n * @property {boolean} module\n * @property {boolean} file\n * @property {boolean} internal\n */\n\n/** @typedef {string | number | boolean | null} JsonPrimitive */\n/** @typedef {JsonValue[]} JsonArray */\n/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */\n/** @typedef {{[Key in string]: JsonValue} & {[Key in string]?: JsonValue | undefined}} JsonObject */\n\n/**\n * @typedef {Object} BaseResolveRequest\n * @property {string | false} path\n * @property {object=} context\n * @property {string=} descriptionFilePath\n * @property {string=} descriptionFileRoot\n * @property {JsonObject=} descriptionFileData\n * @property {string=} relativePath\n * @property {boolean=} ignoreSymlinks\n * @property {boolean=} fullySpecified\n * @property {string=} __innerRequest\n * @property {string=} __innerRequest_request\n * @property {string=} __innerRequest_relativePath\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/**\n * @template T\n * @typedef {{ add: (item: T) => void }} WriteOnlySet\n */\n\n/** @typedef {(function (ResolveRequest): void)} ResolveContextYield */\n\n/**\n * Resolve context\n * @typedef {Object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {(function(string): void)=} log log function\n * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @typedef {Object} KnownHooks\n * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep\n * @property {SyncHook<[ResolveRequest, Error]>} noResolve\n * @property {ResolveStepHook} resolve\n * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result\n */\n\n/**\n * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks\n */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\nfunction toCamelCase(str) {\n\treturn str.replace(/-([a-z])/g, str => str.slice(1).toUpperCase());\n}\n\nclass Resolver {\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @returns {StackEntry} stack entry\n\t */\n\tstatic createStackEntry(hook, request) {\n\t\treturn (\n\t\t\thook.name +\n\t\t\t\": (\" +\n\t\t\trequest.path +\n\t\t\t\") \" +\n\t\t\t(request.request || \"\") +\n\t\t\t(request.query || \"\") +\n\t\t\t(request.fragment || \"\") +\n\t\t\t(request.directory ? \" directory\" : \"\") +\n\t\t\t(request.module ? \" module\" : \"\")\n\t\t);\n\t}\n\n\t/**\n\t * @param {FileSystem} fileSystem a filesystem\n\t * @param {ResolveOptions} options options\n\t */\n\tconstructor(fileSystem, options) {\n\t\tthis.fileSystem = fileSystem;\n\t\tthis.options = options;\n\t\t/** @type {KnownHooks} */\n\t\tthis.hooks = {\n\t\t\tresolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n\t\t\tnoResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n\t\t\tresolve: new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\t\"resolve\"\n\t\t\t),\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tensureHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n\t\t\t\t\tstage: -10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n\t\t\t\t\tstage: 10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t/** @type {ResolveStepHook} */\n\t\tconst hook = /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\tif (!hook) {\n\t\t\t/** @type {KnownHooks & EnsuredHooks} */\n\t\t\t(this.hooks)[name] = new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\tname\n\t\t\t);\n\n\t\t\treturn /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tgetHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n\t\t\t\t\tstage: -10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n\t\t\t\t\tstage: 10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t/** @type {ResolveStepHook} */\n\t\tconst hook = /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\tif (!hook) {\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @returns {string | false} result\n\t */\n\tresolveSync(context, path, request) {\n\t\t/** @type {Error | null | undefined} */\n\t\tlet err = undefined;\n\t\t/** @type {string | false | undefined} */\n\t\tlet result = undefined;\n\t\tlet sync = false;\n\t\tthis.resolve(context, path, request, {}, (e, r) => {\n\t\t\terr = e;\n\t\t\tresult = r;\n\t\t\tsync = true;\n\t\t});\n\t\tif (!sync) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\"\n\t\t\t);\n\t\t}\n\t\tif (err) throw err;\n\t\tif (result === undefined) throw new Error(\"No result\");\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @param {ResolveContext} resolveContext resolve context\n\t * @param {ResolveCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolve(context, path, request, resolveContext, callback) {\n\t\tif (!context || typeof context !== \"object\")\n\t\t\treturn callback(new Error(\"context argument is not an object\"));\n\t\tif (typeof path !== \"string\")\n\t\t\treturn callback(new Error(\"path argument is not a string\"));\n\t\tif (typeof request !== \"string\")\n\t\t\treturn callback(new Error(\"request argument is not a string\"));\n\t\tif (!resolveContext)\n\t\t\treturn callback(new Error(\"resolveContext argument is not set\"));\n\n\t\t/** @type {ResolveRequest} */\n\t\tconst obj = {\n\t\t\tcontext: context,\n\t\t\tpath: path,\n\t\t\trequest: request\n\t\t};\n\n\t\t/** @type {ResolveContextYield | undefined} */\n\t\tlet yield_;\n\t\tlet yieldCalled = false;\n\t\t/** @type {ResolveContextYield | undefined} */\n\t\tlet finishYield;\n\t\tif (typeof resolveContext.yield === \"function\") {\n\t\t\tconst old = resolveContext.yield;\n\t\t\t/**\n\t\t\t * @param {ResolveRequest} obj object\n\t\t\t */\n\t\t\tyield_ = obj => {\n\t\t\t\told(obj);\n\t\t\t\tyieldCalled = true;\n\t\t\t};\n\t\t\t/**\n\t\t\t * @param {ResolveRequest} result result\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tfinishYield = result => {\n\t\t\t\tif (result) {\n\t\t\t\t\t/** @type {ResolveContextYield} */ (yield_)(result);\n\t\t\t\t}\n\t\t\t\tcallback(null);\n\t\t\t};\n\t\t}\n\n\t\tconst message = `resolve '${request}' in '${path}'`;\n\n\t\t/**\n\t\t * @param {ResolveRequest} result result\n\t\t * @returns {void}\n\t\t */\n\t\tconst finishResolved = result => {\n\t\t\treturn callback(\n\t\t\t\tnull,\n\t\t\t\tresult.path === false\n\t\t\t\t\t? false\n\t\t\t\t\t: `${result.path.replace(/#/g, \"\\0#\")}${\n\t\t\t\t\t\t\tresult.query ? result.query.replace(/#/g, \"\\0#\") : \"\"\n\t\t\t\t\t  }${result.fragment || \"\"}`,\n\t\t\t\tresult\n\t\t\t);\n\t\t};\n\n\t\t/**\n\t\t * @param {string[]} log logs\n\t\t * @returns {void}\n\t\t */\n\t\tconst finishWithoutResolve = log => {\n\t\t\t/**\n\t\t\t * @type {ErrorWithDetail}\n\t\t\t */\n\t\t\tconst error = new Error(\"Can't \" + message);\n\t\t\terror.details = log.join(\"\\n\");\n\t\t\tthis.hooks.noResolve.call(obj, error);\n\t\t\treturn callback(error);\n\t\t};\n\n\t\tif (resolveContext.log) {\n\t\t\t// We need log anyway to capture it in case of an error\n\t\t\tconst parentLog = resolveContext.log;\n\t\t\t/** @type {string[]} */\n\t\t\tconst log = [];\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: msg => {\n\t\t\t\t\t\tparentLog(msg);\n\t\t\t\t\t\tlog.push(msg);\n\t\t\t\t\t},\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\t// Try to resolve assuming there is no error\n\t\t\t// We don't log stuff in this case\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: undefined,\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\t// log is missing for the error details\n\t\t\t\t\t// so we redo the resolving for the log info\n\t\t\t\t\t// this is more expensive to the success case\n\t\t\t\t\t// is assumed by default\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst log = [];\n\n\t\t\t\t\treturn this.doResolve(\n\t\t\t\t\t\tthis.hooks.resolve,\n\t\t\t\t\t\tobj,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog: msg => log.push(msg),\n\t\t\t\t\t\t\tyield: yield_,\n\t\t\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t// In a case that there is a race condition and yield will be called\n\t\t\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @param {null|string} message string\n\t * @param {ResolveContext} resolveContext resolver context\n\t * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback\n\t * @returns {void}\n\t */\n\tdoResolve(hook, request, message, resolveContext, callback) {\n\t\tconst stackEntry = Resolver.createStackEntry(hook, request);\n\n\t\t/** @type {Set<string> | undefined} */\n\t\tlet newStack;\n\t\tif (resolveContext.stack) {\n\t\t\tnewStack = new Set(resolveContext.stack);\n\t\t\tif (resolveContext.stack.has(stackEntry)) {\n\t\t\t\t/**\n\t\t\t\t * Prevent recursion\n\t\t\t\t * @type {Error & {recursion?: boolean}}\n\t\t\t\t */\n\t\t\t\tconst recursionError = new Error(\n\t\t\t\t\t\"Recursion in resolving\\nStack:\\n  \" +\n\t\t\t\t\t\tArray.from(newStack).join(\"\\n  \")\n\t\t\t\t);\n\t\t\t\trecursionError.recursion = true;\n\t\t\t\tif (resolveContext.log)\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\n\t\t\t\treturn callback(recursionError);\n\t\t\t}\n\t\t\tnewStack.add(stackEntry);\n\t\t} else {\n\t\t\tnewStack = new Set([stackEntry]);\n\t\t}\n\t\tthis.hooks.resolveStep.call(hook, request);\n\n\t\tif (hook.isUsed()) {\n\t\t\tconst innerContext = createInnerContext(\n\t\t\t\t{\n\t\t\t\t\tlog: resolveContext.log,\n\t\t\t\t\tyield: resolveContext.yield,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: newStack\n\t\t\t\t},\n\t\t\t\tmessage\n\t\t\t);\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) return callback(null, result);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t * @returns {ParsedIdentifier} parsed identifier\n\t */\n\tparse(identifier) {\n\t\tconst part = {\n\t\t\trequest: \"\",\n\t\t\tquery: \"\",\n\t\t\tfragment: \"\",\n\t\t\tmodule: false,\n\t\t\tdirectory: false,\n\t\t\tfile: false,\n\t\t\tinternal: false\n\t\t};\n\n\t\tconst parsedIdentifier = parseIdentifier(identifier);\n\n\t\tif (!parsedIdentifier) return part;\n\n\t\t[part.request, part.query, part.fragment] = parsedIdentifier;\n\n\t\tif (part.request.length > 0) {\n\t\t\tpart.internal = this.isPrivate(identifier);\n\t\t\tpart.module = this.isModule(part.request);\n\t\t\tpart.directory = this.isDirectory(part.request);\n\t\t\tif (part.directory) {\n\t\t\t\tpart.request = part.request.slice(0, -1);\n\t\t\t}\n\t\t}\n\n\t\treturn part;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {boolean} true, if the path is a module\n\t */\n\tisModule(path) {\n\t\treturn getType(path) === PathType.Normal;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {boolean} true, if the path is private\n\t */\n\tisPrivate(path) {\n\t\treturn getType(path) === PathType.Internal;\n\t}\n\n\t/**\n\t * @param {string} path a path\n\t * @returns {boolean} true, if the path is a directory path\n\t */\n\tisDirectory(path) {\n\t\treturn path.endsWith(\"/\");\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {string} request request\n\t * @returns {string} joined path\n\t */\n\tjoin(path, request) {\n\t\treturn join(path, request);\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {string} normalized path\n\t */\n\tnormalize(path) {\n\t\treturn normalize(path);\n\t}\n}\n\nmodule.exports = Resolver;\n"]},"metadata":{},"sourceType":"script"}