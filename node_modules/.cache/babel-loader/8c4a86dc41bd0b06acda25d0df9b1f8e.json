{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  Parser: AcornParser\n} = require(\"acorn\");\n\nconst {\n  importAssertions\n} = require(\"acorn-import-assertions\");\n\nconst {\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\n\nconst vm = require(\"vm\");\n\nconst Parser = require(\"../Parser\");\n\nconst StackedMap = require(\"../util/StackedMap\");\n\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpression */\n\n/** @typedef {import(\"estree\").BlockStatement} BlockStatement */\n\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpression */\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n\n/** @typedef {import(\"estree\").BaseCallExpression} BaseCallExpression */\n\n/** @typedef {import(\"estree\").StaticBlock} StaticBlock */\n\n/** @typedef {import(\"estree\").ImportExpression} ImportExpression */\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclaration */\n\n/** @typedef {import(\"estree\").ForStatement} ForStatement */\n\n/** @typedef {import(\"estree\").SwitchStatement} SwitchStatement */\n\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclaration */\n\n/** @typedef {import(\"estree\").ClassExpression} ClassExpression */\n\n/** @typedef {import(\"estree\").Comment} Comment */\n\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpression */\n\n/** @typedef {import(\"estree\").Declaration} Declaration */\n\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifier */\n\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinition */\n\n/** @typedef {import(\"estree\").Expression} Expression */\n\n/** @typedef {import(\"estree\").Identifier} Identifier */\n\n/** @typedef {import(\"estree\").VariableDeclaration} VariableDeclaration */\n\n/** @typedef {import(\"estree\").IfStatement} IfStatement */\n\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatement */\n\n/** @typedef {import(\"estree\").Literal} Literal */\n\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpression */\n\n/** @typedef {import(\"estree\").ChainExpression} ChainExpression */\n\n/** @typedef {import(\"estree\").MemberExpression} MemberExpression */\n\n/** @typedef {import(\"estree\").YieldExpression} YieldExpression */\n\n/** @typedef {import(\"estree\").MetaProperty} MetaProperty */\n\n/** @typedef {import(\"estree\").Property} Property */\n\n/** @typedef {import(\"estree\").AssignmentPattern} AssignmentPattern */\n\n/** @typedef {import(\"estree\").ChainElement} ChainElement */\n\n/** @typedef {import(\"estree\").Pattern} Pattern */\n\n/** @typedef {import(\"estree\").UpdateExpression} UpdateExpression */\n\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpression */\n\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpression */\n\n/** @typedef {import(\"estree\").ArrayPattern} ArrayPattern */\n\n/** @typedef {import(\"estree\").AwaitExpression} AwaitExpression */\n\n/** @typedef {import(\"estree\").ThisExpression} ThisExpression */\n\n/** @typedef {import(\"estree\").RestElement} RestElement */\n\n/** @typedef {import(\"estree\").ObjectPattern} ObjectPattern */\n\n/** @typedef {import(\"estree\").SwitchCase} SwitchCase */\n\n/** @typedef {import(\"estree\").CatchClause} CatchClause */\n\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclarator */\n\n/** @typedef {import(\"estree\").ForInStatement} ForInStatement */\n\n/** @typedef {import(\"estree\").ForOfStatement} ForOfStatement */\n\n/** @typedef {import(\"estree\").ReturnStatement} ReturnStatement */\n\n/** @typedef {import(\"estree\").WithStatement} WithStatement */\n\n/** @typedef {import(\"estree\").ThrowStatement} ThrowStatement */\n\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinition */\n\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclaration */\n\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n\n/** @typedef {import(\"estree\").FunctionExpression} FunctionExpression */\n\n/** @typedef {import(\"estree\").WhileStatement} WhileStatement */\n\n/** @typedef {import(\"estree\").ArrowFunctionExpression} ArrowFunctionExpression */\n\n/** @typedef {import(\"estree\").ExpressionStatement} ExpressionStatement */\n\n/** @typedef {import(\"estree\").FunctionDeclaration} FunctionDeclaration */\n\n/** @typedef {import(\"estree\").DoWhileStatement} DoWhileStatement */\n\n/** @typedef {import(\"estree\").TryStatement} TryStatement */\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n\n/** @typedef {import(\"estree\").Program} Program */\n\n/** @typedef {import(\"estree\").Directive} Directive */\n\n/** @typedef {import(\"estree\").Statement} Statement */\n\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclaration */\n\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclaration */\n\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclaration */\n\n/** @typedef {import(\"estree\").Super} Super */\n\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpression */\n\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteral */\n\n/** @typedef {Record<string, any>} Assertions */\n\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[] }} GetInfoResult */\n\n\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst parser = AcornParser.extend(importAssertions);\n\nclass VariableInfo {\n  /**\n   * @param {ScopeInfo} declaredScope scope in which the variable is declared\n   * @param {string | true | undefined} freeName which free name the variable aliases, or true when none\n   * @param {TagInfo | undefined} tagInfo info about tags\n   */\n  constructor(declaredScope, freeName, tagInfo) {\n    this.declaredScope = declaredScope;\n    this.freeName = freeName;\n    this.tagInfo = tagInfo;\n  }\n\n}\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n\n/** @typedef {Literal | string | null | undefined} ImportSource */\n\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean | string} inShorthand\n * @property {boolean} inTaggedTemplateTag\n * @property {boolean} inTry\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n */\n\n/** @typedef {[number, number]} Range */\n\n/**\n * Helper function for joining two ranges into a single range. This is useful\n * when working with AST nodes, as it allows you to combine the ranges of child nodes\n * to create the range of the _parent node_.\n *\n * @param {[number, number]} startRange start range to join\n * @param {[number, number]} endRange end range to join\n * @returns {[number, number]} joined range\n *\n * @example\n * ```js\n * \tconst startRange = [0, 5];\n * \tconst endRange = [10, 15];\n * \tconst joinedRange = joinRanges(startRange, endRange);\n * \tconsole.log(joinedRange); // [0, 15]\n * ```\n *\n */\n\n\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n/**\n * Helper function used to generate a string representation of a\n * [member expression](https://github.com/estree/estree/blob/master/es5.md#memberexpression).\n *\n * @param {string} object object to name\n * @param {string[]} membersReversed reversed list of members\n * @returns {string} member expression as a string\n * @example\n * ```js\n * const membersReversed = [\"property1\", \"property2\", \"property3\"]; // Members parsed from the AST\n * const name = objectAndMembersToName(\"myObject\", membersReversed);\n *\n * console.log(name); // \"myObject.property1.property2.property3\"\n * ```\n *\n */\n\n\nconst objectAndMembersToName = (object, membersReversed) => {\n  let name = object;\n\n  for (let i = membersReversed.length - 1; i >= 0; i--) {\n    name = name + \".\" + membersReversed[i];\n  }\n\n  return name;\n};\n/**\n * Grabs the name of a given expression and returns it as a string or undefined. Has particular\n * handling for [Identifiers](https://github.com/estree/estree/blob/master/es5.md#identifier),\n * [ThisExpressions](https://github.com/estree/estree/blob/master/es5.md#identifier), and\n * [MetaProperties](https://github.com/estree/estree/blob/master/es2015.md#metaproperty) which is\n * specifically for handling the `new.target` meta property.\n *\n * @param {Expression | Super} expression expression\n * @returns {string | \"this\" | undefined} name or variable info\n */\n\n\nconst getRootName = expression => {\n  switch (expression.type) {\n    case \"Identifier\":\n      return expression.name;\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"MetaProperty\":\n      return `${expression.meta.name}.${expression.property.name}`;\n\n    default:\n      return undefined;\n  }\n};\n/** @type {AcornOptions} */\n\n\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: \"latest\",\n  sourceType: \"module\",\n  // https://github.com/tc39/proposal-hashbang\n  allowHashBang: true,\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nclass JavascriptParser extends Parser {\n  /**\n   * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n   */\n  constructor() {\n    let sourceType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"auto\";\n    super();\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[Expression], BasicEvaluatedExpression | undefined | null>>} */\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateNewExpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n\n      /** @type {HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier, number], boolean | void>>} */\n      isPure: new HookMap(() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])),\n\n      /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n      preStatement: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n      blockPreStatement: new SyncBailHook([\"declaration\"]),\n\n      /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n      statement: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[IfStatement], boolean | void>} */\n      statementIf: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[Expression, ClassExpression | ClassDeclaration], boolean | void>} */\n      classExtendsExpression: new SyncBailHook([\"expression\", \"classDefinition\"]),\n\n      /** @type {SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration], boolean | void>} */\n      classBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\n      /** @type {SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration], boolean | void>} */\n      classBodyValue: new SyncBailHook([\"expression\", \"element\", \"classDefinition\"]),\n\n      /** @type {HookMap<SyncBailHook<[LabeledStatement], boolean | void>>} */\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n\n      /** @type {SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>} */\n      import: new SyncBailHook([\"statement\", \"source\"]),\n\n      /** @type {SyncBailHook<[ImportDeclaration, ImportSource, string, string], boolean | void>} */\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration], boolean | void>} */\n      export: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>} */\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>} */\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\n      /** @type {SyncBailHook<[ExportDefaultDeclaration, Declaration], boolean | void>} */\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>} */\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string, string, number | undefined], boolean | void>} */\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n\n      /** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n      preDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\n      /** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n      declarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[Identifier], boolean | void>>} */\n      pattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\n      /** @type {HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>} */\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>} */\n      assignMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\"])),\n\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {SyncBailHook<[ImportExpression], boolean | void>} */\n      importCall: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[Expression], boolean | void>} */\n      topLevelAwait: new SyncBailHook([\"expression\"]),\n\n      /** @type {HookMap<SyncBailHook<[CallExpression], boolean | void>>} */\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** Something like \"a.b()\" */\n\n      /** @type {HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>} */\n      callMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\", \"memberRanges\"])),\n\n      /** Something like \"a.b().c.d\" */\n\n      /** @type {HookMap<SyncBailHook<[Expression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n      memberChainOfCallMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"calleeMembers\", \"callExpression\", \"members\", \"memberRanges\"])),\n\n      /** Something like \"a.b().c.d()\"\" */\n\n      /** @type {HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n      callMemberChainOfCallMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"calleeMembers\", \"innerCallExpression\", \"members\", \"memberRanges\"])),\n\n      /** @type {SyncBailHook<[ChainExpression], boolean | void>} */\n      optionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\n      /** @type {HookMap<SyncBailHook<[NewExpression], boolean | void>>} */\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {SyncBailHook<[BinaryExpression], boolean | void>} */\n      binaryExpression: new SyncBailHook([\"binaryExpression\"]),\n\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>} */\n      expressionMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\", \"memberRanges\"])),\n\n      /** @type {HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>} */\n      unhandledExpressionMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\"])),\n\n      /** @type {SyncBailHook<[ConditionalExpression], boolean | void>} */\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[LogicalExpression], boolean | void>} */\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n      program: new SyncBailHook([\"ast\", \"comments\"]),\n\n      /** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n      finish: new SyncBailHook([\"ast\", \"comments\"])\n    });\n    this.sourceType = sourceType;\n    /** @type {ScopeInfo} */\n\n    this.scope = undefined;\n    /** @type {ParserState} */\n\n    this.state = undefined;\n    this.comments = undefined;\n    this.semicolons = undefined;\n    /** @type {(Statement | ModuleDeclaration | Expression)[]} */\n\n    this.statementPath = undefined;\n    /** @type {Statement | ModuleDeclaration | Expression | undefined} */\n\n    this.prevStatement = undefined;\n    /** @type {WeakMap<Expression, Set<string>>} */\n\n    this.destructuringAssignmentProperties = undefined;\n    this.currentTagData = undefined;\n\n    this._initializeEvaluating();\n  }\n\n  _initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {Literal} */\n      _expr;\n\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(\n          /** @type {Range} */\n          expr.range);\n\n        case \"bigint\":\n          return new BasicEvaluatedExpression().setBigInt(expr.value).setRange(\n          /** @type {Range} */\n          expr.range);\n\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(\n          /** @type {Range} */\n          expr.range);\n\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(\n          /** @type {Range} */\n          expr.range);\n      }\n\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(\n        /** @type {Range} */\n        expr.range);\n      }\n\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(\n        /** @type {Range} */\n        expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {NewExpression} */\n      _expr;\n      const callee = expr.callee;\n      if (callee.type !== \"Identifier\") return;\n\n      if (callee.name !== \"RegExp\") {\n        return this.callHooksForName(this.hooks.evaluateNewExpression, callee.name, expr);\n      } else if (expr.arguments.length > 2 || this.getVariableInfo(\"RegExp\") !== \"RegExp\") return;\n\n      let regExp, flags;\n      const arg1 = expr.arguments[0];\n\n      if (arg1) {\n        if (arg1.type === \"SpreadElement\") return;\n        const evaluatedRegExp = this.evaluateExpression(arg1);\n        if (!evaluatedRegExp) return;\n        regExp = evaluatedRegExp.asString();\n        if (!regExp) return;\n      } else {\n        return new BasicEvaluatedExpression().setRegExp(new RegExp(\"\")).setRange(\n        /** @type {Range} */\n        expr.range);\n      }\n\n      const arg2 = expr.arguments[1];\n\n      if (arg2) {\n        if (arg2.type === \"SpreadElement\") return;\n        const evaluatedFlags = this.evaluateExpression(arg2);\n        if (!evaluatedFlags) return;\n\n        if (!evaluatedFlags.isUndefined()) {\n          flags = evaluatedFlags.asString();\n          if (flags === undefined || !BasicEvaluatedExpression.isValidRegExpFlags(flags)) return;\n        }\n      }\n\n      return new BasicEvaluatedExpression().setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp)).setRange(\n      /** @type {Range} */\n      expr.range);\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {LogicalExpression} */\n      _expr;\n      const left = this.evaluateExpression(expr.left);\n      let returnRight = false;\n      /** @type {boolean|undefined} */\n\n      let allowedRight;\n\n      if (expr.operator === \"&&\") {\n        const leftAsBool = left.asBool();\n        if (leftAsBool === false) return left.setRange(expr.range);\n        returnRight = leftAsBool === true;\n        allowedRight = false;\n      } else if (expr.operator === \"||\") {\n        const leftAsBool = left.asBool();\n        if (leftAsBool === true) return left.setRange(expr.range);\n        returnRight = leftAsBool === false;\n        allowedRight = true;\n      } else if (expr.operator === \"??\") {\n        const leftAsNullish = left.asNullish();\n        if (leftAsNullish === false) return left.setRange(expr.range);\n        if (leftAsNullish !== true) return;\n        returnRight = true;\n      } else return;\n\n      const right = this.evaluateExpression(expr.right);\n\n      if (returnRight) {\n        if (left.couldHaveSideEffects()) right.setSideEffects();\n        return right.setRange(expr.range);\n      }\n\n      const asBool = right.asBool();\n\n      if (allowedRight === true && asBool === true) {\n        return new BasicEvaluatedExpression().setRange(expr.range).setTruthy();\n      } else if (allowedRight === false && asBool === false) {\n        return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n      }\n    });\n    /**\n     * In simple logical cases, we can use valueAsExpression to assist us in evaluating the expression on\n     * either side of a [BinaryExpression](https://github.com/estree/estree/blob/master/es5.md#binaryexpression).\n     * This supports scenarios in webpack like conditionally `import()`'ing modules based on some simple evaluation:\n     *\n     * ```js\n     * if (1 === 3) {\n     *  import(\"./moduleA\"); // webpack will auto evaluate this and not import the modules\n     * }\n     * ```\n     *\n     * Additional scenarios include evaluation of strings inside of dynamic import statements:\n     *\n     * ```js\n     * const foo = \"foo\";\n     * const bar = \"bar\";\n     *\n     * import(\"./\" + foo + bar); // webpack will auto evaluate this into import(\"./foobar\")\n     * ```\n     * @param {boolean | number | BigInt | string} value the value to convert to an expression\n     * @param {BinaryExpression | UnaryExpression} expr the expression being evaluated\n     * @param {boolean} sideEffects whether the expression has side effects\n     * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n     * @example\n     *\n     * ```js\n     * const binaryExpr = new BinaryExpression(\"+\",\n     * \t{ type: \"Literal\", value: 2 },\n     * \t{ type: \"Literal\", value: 3 }\n     * );\n     *\n     * const leftValue = 2;\n     * const rightValue = 3;\n     *\n     * const leftExpr = valueAsExpression(leftValue, binaryExpr.left, false);\n     * const rightExpr = valueAsExpression(rightValue, binaryExpr.right, false);\n     * const result = new BasicEvaluatedExpression()\n     * \t.setNumber(leftExpr.number + rightExpr.number)\n     * \t.setRange(binaryExpr.range);\n     *\n     * console.log(result.number); // Output: 5\n     * ```\n     */\n\n    const valueAsExpression = (value, expr, sideEffects) => {\n      switch (typeof value) {\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(value).setSideEffects(sideEffects).setRange(\n          /** @type {Range} */\n          expr.range);\n\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(value).setSideEffects(sideEffects).setRange(\n          /** @type {Range} */\n          expr.range);\n\n        case \"bigint\":\n          return new BasicEvaluatedExpression().setBigInt(value).setSideEffects(sideEffects).setRange(\n          /** @type {Range} */\n          expr.range);\n\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(value).setSideEffects(sideEffects).setRange(\n          /** @type {Range} */\n          expr.range);\n      }\n    };\n\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {BinaryExpression} */\n      _expr;\n      /**\n       * Evaluates a binary expression if and only if it is a const operation (e.g. 1 + 2, \"a\" + \"b\", etc.).\n       *\n       * @template T\n       * @param {(leftOperand: T, rightOperand: T) => boolean | number | BigInt | string} operandHandler the handler for the operation (e.g. (a, b) => a + b)\n       * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n       */\n\n      const handleConstOperation = operandHandler => {\n        const left = this.evaluateExpression(expr.left);\n        if (!left.isCompileTimeValue()) return;\n        const right = this.evaluateExpression(expr.right);\n        if (!right.isCompileTimeValue()) return;\n        const result = operandHandler(left.asCompileTimeValue(), right.asCompileTimeValue());\n        return valueAsExpression(result, expr, left.couldHaveSideEffects() || right.couldHaveSideEffects());\n      };\n      /**\n       * Helper function to determine if two booleans are always different. This is used in `handleStrictEqualityComparison`\n       * to determine if an expressions boolean or nullish conversion is equal or not.\n       *\n       * @param {boolean} a first boolean to compare\n       * @param {boolean} b second boolean to compare\n       * @returns {boolean} true if the two booleans are always different, false otherwise\n       */\n\n\n      const isAlwaysDifferent = (a, b) => a === true && b === false || a === false && b === true;\n\n      const handleTemplateStringCompare = (left, right, res, eql) => {\n        const getPrefix = parts => {\n          let value = \"\";\n\n          for (const p of parts) {\n            const v = p.asString();\n            if (v !== undefined) value += v;else break;\n          }\n\n          return value;\n        };\n\n        const getSuffix = parts => {\n          let value = \"\";\n\n          for (let i = parts.length - 1; i >= 0; i--) {\n            const v = parts[i].asString();\n            if (v !== undefined) value = v + value;else break;\n          }\n\n          return value;\n        };\n\n        const leftPrefix = getPrefix(left.parts);\n        const rightPrefix = getPrefix(right.parts);\n        const leftSuffix = getSuffix(left.parts);\n        const rightSuffix = getSuffix(right.parts);\n        const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n        const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n        const prefixMismatch = lenPrefix > 0 && leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix);\n        const suffixMismatch = lenSuffix > 0 && leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix);\n\n        if (prefixMismatch || suffixMismatch) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n      };\n      /**\n       * Helper function to handle BinaryExpressions using strict equality comparisons (e.g. \"===\" and \"!==\").\n       * @param {boolean} eql true for \"===\" and false for \"!==\"\n       * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n       */\n\n\n      const handleStrictEqualityComparison = eql => {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        res.setRange(\n        /** @type {Range} */\n        expr.range);\n        const leftConst = left.isCompileTimeValue();\n        const rightConst = right.isCompileTimeValue();\n\n        if (leftConst && rightConst) {\n          return res.setBoolean(eql === (left.asCompileTimeValue() === right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isArray() && right.isArray()) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isTemplateString() && right.isTemplateString()) {\n          return handleTemplateStringCompare(left, right, res, eql);\n        }\n\n        const leftPrimitive = left.isPrimitiveType();\n        const rightPrimitive = right.isPrimitiveType();\n\n        if ( // Primitive !== Object or\n        // compile-time object types are never equal to something at runtime\n        leftPrimitive === false && (leftConst || rightPrimitive === true) || rightPrimitive === false && (rightConst || leftPrimitive === true) || // Different nullish or boolish status also means not equal\n        isAlwaysDifferent(\n        /** @type {boolean} */\n        left.asBool(),\n        /** @type {boolean} */\n        right.asBool()) || isAlwaysDifferent(\n        /** @type {boolean} */\n        left.asNullish(),\n        /** @type {boolean} */\n        right.asNullish())) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n      };\n      /**\n       * Helper function to handle BinaryExpressions using abstract equality comparisons (e.g. \"==\" and \"!=\").\n       * @param {boolean} eql true for \"==\" and false for \"!=\"\n       * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n       */\n\n\n      const handleAbstractEqualityComparison = eql => {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        const leftConst = left.isCompileTimeValue();\n        const rightConst = right.isCompileTimeValue();\n\n        if (leftConst && rightConst) {\n          return res.setBoolean(eql === ( // eslint-disable-next-line eqeqeq\n          left.asCompileTimeValue() == right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isArray() && right.isArray()) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isTemplateString() && right.isTemplateString()) {\n          return handleTemplateStringCompare(left, right, res, eql);\n        }\n      };\n\n      if (expr.operator === \"+\") {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(left.string + right.string);\n          } else if (right.isNumber()) {\n            res.setString(left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftPrefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + right.string);\n          } else if (right.isNumber()) {\n            res.setNumber(left.number + right.number);\n          } else {\n            return;\n          }\n        } else if (left.isBigInt()) {\n          if (right.isBigInt()) {\n            res.setBigInt(left.bigint + right.bigint);\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixRight\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else {\n          if (right.isString()) {\n            // left + \"right\"\n            // => ([null] + left + \"right\")\n            res.setWrapped(null, right, [left]);\n          } else if (right.isWrapped()) {\n            // left + (prefix + inner + \"postfix\")\n            // => ([null] + left + prefix + inner + \"postfix\")\n            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n          } else {\n            return;\n          }\n        }\n\n        if (left.couldHaveSideEffects() || right.couldHaveSideEffects()) res.setSideEffects();\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        return handleConstOperation((l, r) => l - r);\n      } else if (expr.operator === \"*\") {\n        return handleConstOperation((l, r) => l * r);\n      } else if (expr.operator === \"/\") {\n        return handleConstOperation((l, r) => l / r);\n      } else if (expr.operator === \"**\") {\n        return handleConstOperation((l, r) => l ** r);\n      } else if (expr.operator === \"===\") {\n        return handleStrictEqualityComparison(true);\n      } else if (expr.operator === \"==\") {\n        return handleAbstractEqualityComparison(true);\n      } else if (expr.operator === \"!==\") {\n        return handleStrictEqualityComparison(false);\n      } else if (expr.operator === \"!=\") {\n        return handleAbstractEqualityComparison(false);\n      } else if (expr.operator === \"&\") {\n        return handleConstOperation((l, r) => l & r);\n      } else if (expr.operator === \"|\") {\n        return handleConstOperation((l, r) => l | r);\n      } else if (expr.operator === \"^\") {\n        return handleConstOperation((l, r) => l ^ r);\n      } else if (expr.operator === \">>>\") {\n        return handleConstOperation((l, r) => l >>> r);\n      } else if (expr.operator === \">>\") {\n        return handleConstOperation((l, r) => l >> r);\n      } else if (expr.operator === \"<<\") {\n        return handleConstOperation((l, r) => l << r);\n      } else if (expr.operator === \"<\") {\n        return handleConstOperation((l, r) => l < r);\n      } else if (expr.operator === \">\") {\n        return handleConstOperation((l, r) => l > r);\n      } else if (expr.operator === \"<=\") {\n        return handleConstOperation((l, r) => l <= r);\n      } else if (expr.operator === \">=\") {\n        return handleConstOperation((l, r) => l >= r);\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {UnaryExpression} */\n      _expr;\n      /**\n       * Evaluates a UnaryExpression if and only if it is a basic const operator (e.g. +a, -a, ~a).\n       *\n       * @template T\n       * @param {(operand: T) => boolean | number | BigInt | string} operandHandler handler for the operand\n       * @returns {BasicEvaluatedExpression | undefined} evaluated expression\n       */\n\n      const handleConstOperation = operandHandler => {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument.isCompileTimeValue()) return;\n        const result = operandHandler(argument.asCompileTimeValue());\n        return valueAsExpression(result, expr, argument.couldHaveSideEffects());\n      };\n\n      if (expr.operator === \"typeof\") {\n        switch (expr.argument.type) {\n          case \"Identifier\":\n            {\n              const res = this.callHooksForName(this.hooks.evaluateTypeof, expr.argument.name, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"MetaProperty\":\n            {\n              const res = this.callHooksForName(this.hooks.evaluateTypeof, getRootName(expr.argument), expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"MemberExpression\":\n            {\n              const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"ChainExpression\":\n            {\n              const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument.expression, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"FunctionExpression\":\n            {\n              return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n            }\n        }\n\n        const arg = this.evaluateExpression(expr.argument);\n        if (arg.isUnknown()) return;\n\n        if (arg.isString()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n        }\n\n        if (arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setSideEffects().setRange(expr.range);\n        }\n\n        if (arg.isUndefined()) {\n          return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n        }\n\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n        }\n\n        if (arg.isBigInt()) {\n          return new BasicEvaluatedExpression().setString(\"bigint\").setRange(expr.range);\n        }\n\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n        }\n\n        if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n        }\n\n        if (arg.isArray()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setSideEffects(arg.couldHaveSideEffects()).setRange(expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        const bool = argument.asBool();\n        if (typeof bool !== \"boolean\") return;\n        return new BasicEvaluatedExpression().setBoolean(!bool).setSideEffects(argument.couldHaveSideEffects()).setRange(expr.range);\n      } else if (expr.operator === \"~\") {\n        return handleConstOperation(v => ~v);\n      } else if (expr.operator === \"+\") {\n        return handleConstOperation(v => +v);\n      } else if (expr.operator === \"-\") {\n        return handleConstOperation(v => -v);\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => {\n      return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n      if (\n      /** @type {Identifier} */\n      expr.name === \"undefined\") {\n        return new BasicEvaluatedExpression().setUndefined().setRange(expr.range);\n      }\n    });\n    /**\n     * @param {string} exprType expression type name\n     * @param {function(Expression): GetInfoResult | undefined} getInfo get info\n     * @returns {void}\n     */\n\n    const tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n      /** @type {Expression | undefined} */\n      let cachedExpression = undefined;\n      /** @type {GetInfoResult | undefined} */\n\n      let cachedInfo = undefined;\n      this.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n        const expression =\n        /** @type {MemberExpression} */\n        expr;\n        const info = getInfo(expr);\n\n        if (info !== undefined) {\n          return this.callHooksForInfoWithFallback(this.hooks.evaluateIdentifier, info.name, name => {\n            cachedExpression = expression;\n            cachedInfo = info;\n          }, name => {\n            const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\n            if (hook !== undefined) {\n              return hook.call(expression);\n            }\n          }, expression);\n        }\n      });\n      this.hooks.evaluate.for(exprType).tap({\n        name: \"JavascriptParser\",\n        stage: 100\n      }, expr => {\n        const info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\n        if (info !== undefined) {\n          return new BasicEvaluatedExpression().setIdentifier(info.name, info.rootInfo, info.getMembers, info.getMembersOptionals, info.getMemberRanges).setRange(expr.range);\n        }\n      });\n      this.hooks.finish.tap(\"JavascriptParser\", () => {\n        // Cleanup for GC\n        cachedExpression = cachedInfo = undefined;\n      });\n    };\n\n    tapEvaluateWithVariableInfo(\"Identifier\", expr => {\n      const info = this.getVariableInfo(\n      /** @type {Identifier} */\n      expr.name);\n\n      if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n        return {\n          name: info,\n          rootInfo: info,\n          getMembers: () => [],\n          getMembersOptionals: () => [],\n          getMemberRanges: () => []\n        };\n      }\n    });\n    tapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n      const info = this.getVariableInfo(\"this\");\n\n      if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n        return {\n          name: info,\n          rootInfo: info,\n          getMembers: () => [],\n          getMembersOptionals: () => [],\n          getMemberRanges: () => []\n        };\n      }\n    });\n    this.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n      const metaProperty =\n      /** @type {MetaProperty} */\n      expr;\n      return this.callHooksForName(this.hooks.evaluateIdentifier, getRootName(expr), metaProperty);\n    });\n    tapEvaluateWithVariableInfo(\"MemberExpression\", expr => this.getMemberExpressionInfo(\n    /** @type {MemberExpression} */\n    expr, ALLOWED_MEMBER_TYPES_EXPRESSION));\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {CallExpression} */\n      _expr;\n\n      if (expr.callee.type === \"MemberExpression\" && expr.callee.property.type === (expr.callee.computed ? \"Literal\" : \"Identifier\")) {\n        // type Super also possible here\n        const param = this.evaluateExpression(\n        /** @type {Expression} */\n        expr.callee.object);\n        const property = expr.callee.property.type === \"Literal\" ? `${expr.callee.property.value}` : expr.callee.property.name;\n        const hook = this.hooks.evaluateCallExpressionMember.get(property);\n\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      } else if (expr.callee.type === \"Identifier\") {\n        return this.callHooksForName(this.hooks.evaluateCallExpression, expr.callee.name, expr);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"indexOf\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length === 0) return;\n      const [arg1, arg2] = expr.arguments;\n      if (arg1.type === \"SpreadElement\") return;\n      const arg1Eval = this.evaluateExpression(arg1);\n      if (!arg1Eval.isString()) return;\n      const arg1Value = arg1Eval.string;\n      let result;\n\n      if (arg2) {\n        if (arg2.type === \"SpreadElement\") return;\n        const arg2Eval = this.evaluateExpression(arg2);\n        if (!arg2Eval.isNumber()) return;\n        result = param.string.indexOf(arg1Value, arg2Eval.number);\n      } else {\n        result = param.string.indexOf(arg1Value);\n      }\n\n      return new BasicEvaluatedExpression().setNumber(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      if (expr.arguments[1].type === \"SpreadElement\") return;\n      let arg1 = this.evaluateExpression(expr.arguments[0]);\n      let arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      const arg1Value = arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      const arg2Value = arg2.string;\n      return new BasicEvaluatedExpression().setString(param.string.replace(arg1Value, arg2Value)).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n    });\n    [\"substr\", \"substring\", \"slice\"].forEach(fn => {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"JavascriptParser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result,\n            str = param.string;\n\n        switch (expr.arguments.length) {\n          case 1:\n            if (expr.arguments[0].type === \"SpreadElement\") return;\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[fn](arg1.number);\n            break;\n\n          case 2:\n            {\n              if (expr.arguments[0].type === \"SpreadElement\") return;\n              if (expr.arguments[1].type === \"SpreadElement\") return;\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[fn](arg1.number, arg2.number);\n              break;\n            }\n\n          default:\n            return;\n        }\n\n        return new BasicEvaluatedExpression().setString(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n    });\n    /**\n     * @param {\"cooked\" | \"raw\"} kind kind of values to get\n     * @param {TemplateLiteral} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      /** @type {BasicEvaluatedExpression[]} */\n      const quasis = [];\n      /** @type {BasicEvaluatedExpression[]} */\n\n      const parts = [];\n\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n\n          if (typeof exprAsString === \"string\" && !expr.couldHaveSideEffects()) {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n\n          parts.push(expr);\n        }\n\n        const part = new BasicEvaluatedExpression().setString(quasi).setRange(\n        /** @type {Range} */\n        quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n\n      return {\n        quasis,\n        parts\n      };\n    };\n\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"JavascriptParser\", _node => {\n      const node =\n      /** @type {TemplateLiteral} */\n      _node;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n\n      if (parts.length === 1) {\n        return parts[0].setRange(\n        /** @type {Range} */\n        node.range);\n      }\n\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(\n      /** @type {Range} */\n      node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"JavascriptParser\", _node => {\n      const node =\n      /** @type {TaggedTemplateExpression} */\n      _node;\n      const tag = this.evaluateExpression(node.tag);\n\n      if (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n        const {\n          quasis,\n          parts\n        } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(\n        /** @type {Range} */\n        node.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n      const innerExpressions = [];\n\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const arg = expr.arguments[i];\n        if (arg.type === \"SpreadElement\") return;\n        const argExpr = this.evaluateExpression(arg);\n\n        if (hasUnknownParams || !argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          innerExpressions.push(argExpr);\n          continue;\n        }\n\n        const value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange =\n        /** @type {Range} */\n        [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || argExpr.couldHaveSideEffects()).setRange(newRange);\n      }\n\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        const inner = param.isWrapped() && param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix, inner).setRange(expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        const inner = param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix, inner).setRange(expr.range);\n      } else {\n        const newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n        return new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || param.couldHaveSideEffects()).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n\n      if (arg.isString()) {\n        result = param.string.split(arg.string);\n      } else if (arg.isRegExp()) {\n        result = param.string.split(arg.regExp);\n      } else {\n        return;\n      }\n\n      return new BasicEvaluatedExpression().setArray(result).setSideEffects(param.couldHaveSideEffects()).setRange(\n      /** @type {Range} */\n      expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {ConditionalExpression} */\n      _expr;\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        res = new BasicEvaluatedExpression();\n\n        if (consequent.isConditional()) {\n          res.setOptions(\n          /** @type {BasicEvaluatedExpression[]} */\n          consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n\n        if (alternate.isConditional()) {\n          res.addOptions(\n          /** @type {BasicEvaluatedExpression[]} */\n          alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        if (condition.couldHaveSideEffects()) res.setSideEffects();\n      }\n\n      res.setRange(\n      /** @type {Range} */\n      expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {ArrayExpression} */\n      _expr;\n      const items = expr.elements.map(element => {\n        return element !== null && element.type !== \"SpreadElement\" && this.evaluateExpression(element);\n      });\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(items).setRange(\n      /** @type {Range} */\n      expr.range);\n    });\n    this.hooks.evaluate.for(\"ChainExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {ChainExpression} */\n      _expr;\n      /** @type {Expression[]} */\n\n      const optionalExpressionsStack = [];\n      /** @type {Expression|Super} */\n\n      let next = expr.expression;\n\n      while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n        if (next.type === \"MemberExpression\") {\n          if (next.optional) {\n            // SuperNode can not be optional\n            optionalExpressionsStack.push(\n            /** @type {Expression} */\n            next.object);\n          }\n\n          next = next.object;\n        } else {\n          if (next.optional) {\n            // SuperNode can not be optional\n            optionalExpressionsStack.push(\n            /** @type {Expression} */\n            next.callee);\n          }\n\n          next = next.callee;\n        }\n      }\n\n      while (optionalExpressionsStack.length > 0) {\n        const expression =\n        /** @type {Expression} */\n        optionalExpressionsStack.pop();\n        const evaluated = this.evaluateExpression(expression);\n\n        if (evaluated.asNullish()) {\n          return evaluated.setRange(\n          /** @type {Range} */\n          _expr.range);\n        }\n      }\n\n      return this.evaluateExpression(expr.expression);\n    });\n  }\n  /**\n   * @param {Expression} node node\n   * @returns {Set<string>|undefined} destructured identifiers\n   */\n\n\n  destructuringAssignmentPropertiesFor(node) {\n    if (!this.destructuringAssignmentProperties) return undefined;\n    return this.destructuringAssignmentProperties.get(node);\n  }\n  /**\n   * @param {Expression} expr expression\n   * @returns {string | VariableInfoInterface | undefined} identifier\n   */\n\n\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n\n    if (result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n  /**\n   * @param {ClassExpression | ClassDeclaration} classy a class node\n   * @returns {void}\n   */\n\n\n  walkClass(classy) {\n    if (classy.superClass) {\n      if (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n        this.walkExpression(classy.superClass);\n      }\n    }\n\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      const scopeParams = []; // Add class name in scope for recursive calls\n\n      if (classy.id) {\n        scopeParams.push(classy.id);\n      }\n\n      this.inClassScope(true, scopeParams, () => {\n        for (const classElement of\n        /** @type {TODO} */\n        classy.body.body) {\n          if (!this.hooks.classBodyElement.call(classElement, classy)) {\n            if (classElement.computed && classElement.key) {\n              this.walkExpression(classElement.key);\n            }\n\n            if (classElement.value) {\n              if (!this.hooks.classBodyValue.call(classElement.value, classElement, classy)) {\n                const wasTopLevel = this.scope.topLevelScope;\n                this.scope.topLevelScope = false;\n                this.walkExpression(classElement.value);\n                this.scope.topLevelScope = wasTopLevel;\n              }\n            } else if (classElement.type === \"StaticBlock\") {\n              const wasTopLevel = this.scope.topLevelScope;\n              this.scope.topLevelScope = false;\n              this.walkBlockStatement(classElement);\n              this.scope.topLevelScope = wasTopLevel;\n            }\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Pre walking iterates the scope for variable declarations\n   *\n   * @param {(Statement | ModuleDeclaration)[]} statements statements\n   */\n\n\n  preWalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.preWalkStatement(statement);\n    }\n  }\n  /**\n   * Block pre walking iterates the scope for block variable declarations\n   *\n   * @param {(Statement | ModuleDeclaration)[]} statements statements\n   */\n\n\n  blockPreWalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.blockPreWalkStatement(statement);\n    }\n  }\n  /**\n   * Walking iterates the statements and expressions and processes them\n   *\n   * @param {(Statement | ModuleDeclaration)[]} statements statements\n   */\n\n\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n  /**\n   * Walking iterates the statements and expressions and processes them\n   *\n   * @param {Statement | ModuleDeclaration} statement statement\n   */\n\n\n  preWalkStatement(statement) {\n    this.statementPath.push(statement);\n\n    if (this.hooks.preStatement.call(statement)) {\n      this.prevStatement = this.statementPath.pop();\n      return;\n    }\n\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.preWalkBlockStatement(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.preWalkDoWhileStatement(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.preWalkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.preWalkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.preWalkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.preWalkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.preWalkIfStatement(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.preWalkLabeledStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.preWalkSwitchStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.preWalkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.preWalkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.preWalkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.preWalkWithStatement(statement);\n        break;\n    }\n\n    this.prevStatement = this.statementPath.pop();\n  }\n  /**\n   * @param {Statement | ModuleDeclaration} statement statement\n   */\n\n\n  blockPreWalkStatement(statement) {\n    this.statementPath.push(statement);\n\n    if (this.hooks.blockPreStatement.call(statement)) {\n      this.prevStatement = this.statementPath.pop();\n      return;\n    }\n\n    switch (statement.type) {\n      case \"ImportDeclaration\":\n        this.blockPreWalkImportDeclaration(statement);\n        break;\n\n      case \"ExportAllDeclaration\":\n        this.blockPreWalkExportAllDeclaration(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.blockPreWalkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.blockPreWalkExportNamedDeclaration(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.blockPreWalkVariableDeclaration(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.blockPreWalkClassDeclaration(statement);\n        break;\n\n      case \"ExpressionStatement\":\n        this.blockPreWalkExpressionStatement(statement);\n    }\n\n    this.prevStatement = this.statementPath.pop();\n  }\n  /**\n   * @param {Statement | ModuleDeclaration} statement statement\n   */\n\n\n  walkStatement(statement) {\n    this.statementPath.push(statement);\n\n    if (this.hooks.statement.call(statement) !== undefined) {\n      this.prevStatement = this.statementPath.pop();\n      return;\n    }\n\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n\n    this.prevStatement = this.statementPath.pop();\n  }\n  /**\n   * Walks a statements that is nested within a parent statement\n   * and can potentially be a non-block statement.\n   * This enforces the nested statement to never be in ASI position.\n   *\n   * @param {Statement} statement the nested statement\n   */\n\n\n  walkNestedStatement(statement) {\n    this.prevStatement = undefined;\n    this.walkStatement(statement);\n  } // Real Statements\n\n  /**\n   * @param {BlockStatement} statement block statement\n   */\n\n\n  preWalkBlockStatement(statement) {\n    this.preWalkStatements(statement.body);\n  }\n  /**\n   * @param {BlockStatement} statement block statement\n   */\n\n\n  walkBlockStatement(statement) {\n    this.inBlockScope(() => {\n      const body = statement.body;\n      const prev = this.prevStatement;\n      this.blockPreWalkStatements(body);\n      this.prevStatement = prev;\n      this.walkStatements(body);\n    });\n  }\n  /**\n   * @param {ExpressionStatement} statement expression statement\n   */\n\n\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n  /**\n   * @param {IfStatement} statement if statement\n   */\n\n\n  preWalkIfStatement(statement) {\n    this.preWalkStatement(statement.consequent);\n\n    if (statement.alternate) {\n      this.preWalkStatement(statement.alternate);\n    }\n  }\n  /**\n   * @param {IfStatement} statement if statement\n   */\n\n\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkNestedStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.walkNestedStatement(statement.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkNestedStatement(statement.consequent);\n      } else if (statement.alternate) {\n        this.walkNestedStatement(statement.alternate);\n      }\n    }\n  }\n  /**\n   * @param {LabeledStatement} statement with statement\n   */\n\n\n  preWalkLabeledStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {LabeledStatement} statement with statement\n   */\n\n\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n\n    this.walkNestedStatement(statement.body);\n  }\n  /**\n   * @param {WithStatement} statement with statement\n   */\n\n\n  preWalkWithStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {WithStatement} statement with statement\n   */\n\n\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkNestedStatement(statement.body);\n  }\n  /**\n   * @param {SwitchStatement} statement switch statement\n   */\n\n\n  preWalkSwitchStatement(statement) {\n    this.preWalkSwitchCases(statement.cases);\n  }\n  /**\n   * @param {SwitchStatement} statement switch statement\n   */\n\n\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n  /**\n   * @param {ReturnStatement | ThrowStatement} statement return or throw statement\n   */\n\n\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n  /**\n   * @param {ReturnStatement} statement return statement\n   */\n\n\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n  /**\n   * @param {ThrowStatement} statement return statement\n   */\n\n\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n  /**\n   * @param {TryStatement} statement try statement\n   */\n\n\n  preWalkTryStatement(statement) {\n    this.preWalkStatement(statement.block);\n    if (statement.handler) this.preWalkCatchClause(statement.handler);\n    if (statement.finalizer) this.preWalkStatement(statement.finalizer);\n  }\n  /**\n   * @param {TryStatement} statement try statement\n   */\n\n\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n  /**\n   * @param {WhileStatement} statement while statement\n   */\n\n\n  preWalkWhileStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {WhileStatement} statement while statement\n   */\n\n\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkNestedStatement(statement.body);\n  }\n  /**\n   * @param {DoWhileStatement} statement do while statement\n   */\n\n\n  preWalkDoWhileStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {DoWhileStatement} statement do while statement\n   */\n\n\n  walkDoWhileStatement(statement) {\n    this.walkNestedStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n  /**\n   * @param {ForStatement} statement for statement\n   */\n\n\n  preWalkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.preWalkStatement(statement.init);\n      }\n    }\n\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {ForStatement} statement for statement\n   */\n\n\n  walkForStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.blockPreWalkVariableDeclaration(statement.init);\n          this.prevStatement = undefined;\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n  /**\n   * @param {ForInStatement} statement for statement\n   */\n\n\n  preWalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.preWalkVariableDeclaration(statement.left);\n    }\n\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {ForInStatement} statement for statement\n   */\n\n\n  walkForInStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPreWalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n\n  preWalkForOfStatement(statement) {\n    if (statement.await && this.scope.topLevelScope === true) {\n      this.hooks.topLevelAwait.call(statement);\n    }\n\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.preWalkVariableDeclaration(statement.left);\n    }\n\n    this.preWalkStatement(statement.body);\n  }\n  /**\n   * @param {ForOfStatement} statement for statement\n   */\n\n\n  walkForOfStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPreWalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n  /**\n   * @param {FunctionDeclaration} statement function declaration\n   */\n\n\n  preWalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.defineVariable(statement.id.name);\n    }\n  }\n  /**\n   * @param {FunctionDeclaration} statement function declaration\n   */\n\n\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inFunctionScope(true, statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectMode(statement.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(statement.body);\n        this.prevStatement = prev;\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  /**\n   * @param {ExpressionStatement} statement expression statement\n   */\n\n\n  blockPreWalkExpressionStatement(statement) {\n    const expression = statement.expression;\n\n    switch (expression.type) {\n      case \"AssignmentExpression\":\n        this.preWalkAssignmentExpression(expression);\n    }\n  }\n  /**\n   * @param {AssignmentExpression} expression assignment expression\n   */\n\n\n  preWalkAssignmentExpression(expression) {\n    if (expression.left.type !== \"ObjectPattern\" || !this.destructuringAssignmentProperties) return;\n\n    const keys = this._preWalkObjectPattern(expression.left);\n\n    if (!keys) return; // check multiple assignments\n\n    if (this.destructuringAssignmentProperties.has(expression)) {\n      const set = this.destructuringAssignmentProperties.get(expression);\n      this.destructuringAssignmentProperties.delete(expression);\n\n      for (const id of set) keys.add(id);\n    }\n\n    this.destructuringAssignmentProperties.set(expression.right.type === \"AwaitExpression\" ? expression.right.argument : expression.right, keys);\n\n    if (expression.right.type === \"AssignmentExpression\") {\n      this.preWalkAssignmentExpression(expression.right);\n    }\n  }\n\n  blockPreWalkImportDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.import.call(statement, source);\n\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, \"default\", name)) {\n            this.defineVariable(name);\n          }\n\n          break;\n\n        case \"ImportSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, specifier.imported.name || specifier.imported.value, name)) {\n            this.defineVariable(name);\n          }\n\n          break;\n\n        case \"ImportNamespaceSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n            this.defineVariable(name);\n          }\n\n          break;\n\n        default:\n          this.defineVariable(name);\n      }\n    }\n  }\n\n  enterDeclaration(declaration, onIdent) {\n    switch (declaration.type) {\n      case \"VariableDeclaration\":\n        for (const declarator of declaration.declarations) {\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, onIdent);\n                break;\n              }\n          }\n        }\n\n        break;\n\n      case \"FunctionDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n\n      case \"ClassDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n    }\n  }\n\n  blockPreWalkExportNamedDeclaration(statement) {\n    let source;\n\n    if (statement.source) {\n      source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n\n    if (statement.declaration) {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        const prev = this.prevStatement;\n        this.preWalkStatement(statement.declaration);\n        this.prevStatement = prev;\n        this.blockPreWalkStatement(statement.declaration);\n        let index = 0;\n        this.enterDeclaration(statement.declaration, def => {\n          this.hooks.exportSpecifier.call(statement, def, def, index++);\n        });\n      }\n    }\n\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const name = specifier.exported.name || specifier.exported.value;\n\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n              }\n\n              break;\n            }\n        }\n      }\n    }\n  }\n  /**\n   * @param {ExportNamedDeclaration} statement the statement\n   */\n\n\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n\n  blockPreWalkExportDefaultDeclaration(statement) {\n    const prev = this.prevStatement;\n    this.preWalkStatement(statement.declaration);\n    this.prevStatement = prev;\n    this.blockPreWalkStatement(statement.declaration);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\", undefined);\n    }\n  }\n\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.walkStatement(statement.declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\" || statement.declaration.type === \"ClassDeclaration\") {\n        this.walkStatement(statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n\n      if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\", undefined);\n      }\n    }\n  }\n\n  blockPreWalkExportAllDeclaration(statement) {\n    const source = statement.source.value;\n    const name = statement.exported ? statement.exported.name : null;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n  }\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   */\n\n\n  preWalkVariableDeclaration(statement) {\n    if (statement.kind !== \"var\") return;\n\n    this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n  }\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   */\n\n\n  blockPreWalkVariableDeclaration(statement) {\n    if (statement.kind === \"var\") return;\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n    this._preWalkVariableDeclaration(statement, hookMap);\n  }\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   * @param {TODO} hookMap map of hooks\n   */\n\n\n  _preWalkVariableDeclaration(statement, hookMap) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            this.preWalkVariableDeclarator(declarator);\n\n            if (!this.hooks.preDeclarator.call(declarator, statement)) {\n              this.enterPattern(declarator.id, (name, decl) => {\n                let hook = hookMap.get(name);\n\n                if (hook === undefined || !hook.call(decl)) {\n                  hook = this.hooks.varDeclaration.get(name);\n\n                  if (hook === undefined || !hook.call(decl)) {\n                    this.defineVariable(name);\n                  }\n                }\n              });\n            }\n\n            break;\n          }\n      }\n    }\n  }\n  /**\n   * @param {ObjectPattern} objectPattern object pattern\n   * @returns {Set<string> | undefined} set of names or undefined if not all keys are identifiers\n   */\n\n\n  _preWalkObjectPattern(objectPattern) {\n    const ids = new Set();\n    const properties = objectPattern.properties;\n\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (property.type !== \"Property\") return;\n      const key = property.key;\n\n      if (key.type === \"Identifier\") {\n        ids.add(key.name);\n      } else {\n        const id = this.evaluateExpression(key);\n        const str = id.asString();\n\n        if (str) {\n          ids.add(str);\n        } else {\n          // could not evaluate key\n          return;\n        }\n      }\n    }\n\n    return ids;\n  }\n  /**\n   * @param {VariableDeclarator} declarator variable declarator\n   */\n\n\n  preWalkVariableDeclarator(declarator) {\n    if (!declarator.init || declarator.id.type !== \"ObjectPattern\" || !this.destructuringAssignmentProperties) return;\n\n    const keys = this._preWalkObjectPattern(declarator.id);\n\n    if (!keys) return;\n    this.destructuringAssignmentProperties.set(declarator.init.type === \"AwaitExpression\" ? declarator.init.argument : declarator.init, keys);\n\n    if (declarator.init.type === \"AssignmentExpression\") {\n      this.preWalkAssignmentExpression(declarator.init);\n    }\n  }\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   */\n\n\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n\n              if (hook !== undefined && hook.call(declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n\n                if (hook === undefined || !hook.call(declarator.init)) {\n                  this.setVariable(declarator.id.name, renameIdentifier);\n                }\n\n                break;\n              }\n            }\n\n            if (!this.hooks.declarator.call(declarator, statement)) {\n              this.walkPattern(declarator.id);\n              if (declarator.init) this.walkExpression(declarator.init);\n            }\n\n            break;\n          }\n      }\n    }\n  }\n  /**\n   * @param {ClassDeclaration} statement class declaration\n   */\n\n\n  blockPreWalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.defineVariable(statement.id.name);\n    }\n  }\n  /**\n   * @param {ClassDeclaration} statement class declaration\n   */\n\n\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n  /**\n   * @param {SwitchCase[]} switchCases switch statement\n   */\n\n\n  preWalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.preWalkStatements(switchCase.consequent);\n    }\n  }\n  /**\n   * @param {SwitchCase[]} switchCases switch statement\n   */\n\n\n  walkSwitchCases(switchCases) {\n    this.inBlockScope(() => {\n      const len = switchCases.length; // we need to pre walk all statements first since we can have invalid code\n      // import A from \"module\";\n      // switch(1) {\n      //    case 1:\n      //      console.log(A); // should fail at runtime\n      //    case 2:\n      //      const A = 1;\n      // }\n\n      for (let index = 0; index < len; index++) {\n        const switchCase = switchCases[index];\n\n        if (switchCase.consequent.length > 0) {\n          const prev = this.prevStatement;\n          this.blockPreWalkStatements(switchCase.consequent);\n          this.prevStatement = prev;\n        }\n      }\n\n      for (let index = 0; index < len; index++) {\n        const switchCase = switchCases[index];\n\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n\n        if (switchCase.consequent.length > 0) {\n          this.walkStatements(switchCase.consequent);\n        }\n      }\n    });\n  }\n  /**\n   * @param {CatchClause} catchClause catch clause\n   */\n\n\n  preWalkCatchClause(catchClause) {\n    this.preWalkStatement(catchClause.body);\n  }\n  /**\n   * @param {CatchClause} catchClause catch clause\n   */\n\n\n  walkCatchClause(catchClause) {\n    this.inBlockScope(() => {\n      // Error binding is optional in catch clause since ECMAScript 2019\n      if (catchClause.param !== null) {\n        this.enterPattern(catchClause.param, ident => {\n          this.defineVariable(ident);\n        });\n        this.walkPattern(catchClause.param);\n      }\n\n      const prev = this.prevStatement;\n      this.blockPreWalkStatement(catchClause.body);\n      this.prevStatement = prev;\n      this.walkStatement(catchClause.body);\n    });\n  }\n  /**\n   * @param {Pattern} pattern pattern\n   */\n\n\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n  /**\n   * @param {AssignmentPattern} pattern assignment pattern\n   */\n\n\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n\n      if (prop) {\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n  /**\n   * @param {ArrayPattern} pattern array pattern\n   */\n\n\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n  /**\n   * @param {RestElement} pattern rest element\n   */\n\n\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n  /**\n   * @param {(Expression | SpreadElement | null)[]} expressions expressions\n   */\n\n\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n  /**\n   * @param {TODO} expression expression\n   */\n\n\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n\n      case \"ChainExpression\":\n        this.walkChainExpression(expression);\n        break;\n\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n\n      case \"ImportExpression\":\n        this.walkImportExpression(expression);\n        break;\n\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n\n      case \"MetaProperty\":\n        this.walkMetaProperty(expression);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n  /**\n   * @param {AwaitExpression} expression await expression\n   */\n\n\n  walkAwaitExpression(expression) {\n    if (this.scope.topLevelScope === true) this.hooks.topLevelAwait.call(expression);\n    this.walkExpression(expression.argument);\n  }\n  /**\n   * @param {ArrayExpression} expression array expression\n   */\n\n\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n  /**\n   * @param {SpreadElement} expression spread element\n   */\n\n\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n  /**\n   * @param {ObjectExpression} expression object expression\n   */\n\n\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n      this.walkProperty(prop);\n    }\n  }\n  /**\n   * @param {Property | SpreadElement} prop property or spread element\n   */\n\n\n  walkProperty(prop) {\n    if (prop.type === \"SpreadElement\") {\n      this.walkExpression(prop.argument);\n      return;\n    }\n\n    if (prop.computed) {\n      this.walkExpression(prop.key);\n    }\n\n    if (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n      this.scope.inShorthand = prop.value.name;\n      this.walkIdentifier(prop.value);\n      this.scope.inShorthand = false;\n    } else {\n      this.walkExpression(prop.value);\n    }\n  }\n  /**\n   * @param {FunctionExpression} expression arrow function expression\n   */\n\n\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = [...expression.params]; // Add function name in scope for recursive calls\n\n    if (expression.id) {\n      scopeParams.push(expression.id);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(expression.body);\n        this.prevStatement = prev;\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  /**\n   * @param {ArrowFunctionExpression} expression arrow function expression\n   */\n\n\n  walkArrowFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n    this.inFunctionScope(false, expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(expression.body);\n        this.prevStatement = prev;\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  /**\n   * @param {SequenceExpression} expression the sequence\n   */\n\n\n  walkSequenceExpression(expression) {\n    if (!expression.expressions) return; // We treat sequence expressions like statements when they are one statement level\n    // This has some benefits for optimizations that only work on statement level\n\n    const currentStatement = this.statementPath[this.statementPath.length - 1];\n\n    if (currentStatement === expression || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expression) {\n      const old = this.statementPath.pop();\n\n      for (const expr of expression.expressions) {\n        this.statementPath.push(expr);\n        this.walkExpression(expr);\n        this.statementPath.pop();\n      }\n\n      this.statementPath.push(old);\n    } else {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n  /**\n   * @param {UpdateExpression} expression the update expression\n   */\n\n\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n  /**\n   * @param {UnaryExpression} expression the unary expression\n   */\n\n\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const result = this.callHooksForExpression(this.hooks.typeof, expression.argument, expression);\n      if (result === true) return;\n\n      if (expression.argument.type === \"ChainExpression\") {\n        const result = this.callHooksForExpression(this.hooks.typeof, expression.argument.expression, expression);\n        if (result === true) return;\n      }\n    }\n\n    this.walkExpression(expression.argument);\n  }\n  /**\n   * @param {LogicalExpression | BinaryExpression} expression the expression\n   */\n\n\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n  /**\n   * @param {BinaryExpression} expression the binary expression\n   */\n\n\n  walkBinaryExpression(expression) {\n    if (this.hooks.binaryExpression.call(expression) === undefined) {\n      this.walkLeftRightExpression(expression);\n    }\n  }\n  /**\n   * @param {LogicalExpression} expression the logical expression\n   */\n\n\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else {\n      if (result) {\n        this.walkExpression(expression.right);\n      }\n    }\n  }\n  /**\n   * @param {AssignmentExpression} expression assignment expression\n   */\n\n\n  walkAssignmentExpression(expression) {\n    if (expression.left.type === \"Identifier\") {\n      const renameIdentifier = this.getRenameIdentifier(expression.right);\n\n      if (renameIdentifier) {\n        if (this.callHooksForInfo(this.hooks.canRename, renameIdentifier, expression.right)) {\n          // renaming \"a = b;\"\n          if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, expression.right)) {\n            this.setVariable(expression.left.name, typeof renameIdentifier === \"string\" ? this.getVariableInfo(renameIdentifier) : renameIdentifier);\n          }\n\n          return;\n        }\n      }\n\n      this.walkExpression(expression.right);\n      this.enterPattern(expression.left, (name, decl) => {\n        if (!this.callHooksForName(this.hooks.assign, name, expression)) {\n          this.walkExpression(expression.left);\n        }\n      });\n      return;\n    }\n\n    if (expression.left.type.endsWith(\"Pattern\")) {\n      this.walkExpression(expression.right);\n      this.enterPattern(expression.left, (name, decl) => {\n        if (!this.callHooksForName(this.hooks.assign, name, expression)) {\n          this.defineVariable(name);\n        }\n      });\n      this.walkPattern(expression.left);\n    } else if (expression.left.type === \"MemberExpression\") {\n      const exprName = this.getMemberExpressionInfo(expression.left, ALLOWED_MEMBER_TYPES_EXPRESSION);\n\n      if (exprName) {\n        if (this.callHooksForInfo(this.hooks.assignMemberChain, exprName.rootInfo, expression, exprName.getMembers())) {\n          return;\n        }\n      }\n\n      this.walkExpression(expression.right);\n      this.walkExpression(expression.left);\n    } else {\n      this.walkExpression(expression.right);\n      this.walkExpression(expression.left);\n    }\n  }\n  /**\n   * @param {ConditionalExpression} expression conditional expression\n   */\n\n\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkExpression(expression.consequent);\n      } else if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    }\n  }\n  /**\n   * @param {NewExpression} expression new expression\n   */\n\n\n  walkNewExpression(expression) {\n    const result = this.callHooksForExpression(this.hooks.new, expression.callee, expression);\n    if (result === true) return;\n    this.walkExpression(expression.callee);\n\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n  /**\n   * @param {YieldExpression} expression yield expression\n   */\n\n\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n  /**\n   * @param {TemplateLiteral} expression template literal\n   */\n\n\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n  /**\n   * @param {TaggedTemplateExpression} expression tagged template expression\n   */\n\n\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.scope.inTaggedTemplateTag = true;\n      this.walkExpression(expression.tag);\n      this.scope.inTaggedTemplateTag = false;\n    }\n\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n  /**\n   * @param {ClassExpression} expression the class expression\n   */\n\n\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n  /**\n   * @param {ChainExpression} expression expression\n   */\n\n\n  walkChainExpression(expression) {\n    const result = this.hooks.optionalChaining.call(expression);\n\n    if (result === undefined) {\n      if (expression.expression.type === \"CallExpression\") {\n        this.walkCallExpression(expression.expression);\n      } else {\n        this.walkMemberExpression(expression.expression);\n      }\n    }\n  }\n\n  _walkIIFE(functionExpression, options, currentThis) {\n    const getVarInfo = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n\n      if (renameIdentifier) {\n        if (this.callHooksForInfo(this.hooks.canRename, renameIdentifier, argOrThis)) {\n          if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, argOrThis)) {\n            return typeof renameIdentifier === \"string\" ? this.getVariableInfo(renameIdentifier) : renameIdentifier;\n          }\n        }\n      }\n\n      this.walkExpression(argOrThis);\n    };\n\n    const {\n      params,\n      type\n    } = functionExpression;\n    const arrow = type === \"ArrowFunctionExpression\";\n    const renameThis = currentThis ? getVarInfo(currentThis) : null;\n    const varInfoForArgs = options.map(getVarInfo);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n    const scopeParams = params.filter((identifier, idx) => !varInfoForArgs[idx]); // Add function name in scope for recursive calls\n\n    if (functionExpression.id) {\n      scopeParams.push(functionExpression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      if (renameThis && !arrow) {\n        this.setVariable(\"this\", renameThis);\n      }\n\n      for (let i = 0; i < varInfoForArgs.length; i++) {\n        const varInfo = varInfoForArgs[i];\n        if (!varInfo) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.setVariable(params[i].name, varInfo);\n      }\n\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.detectMode(functionExpression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(functionExpression.body);\n        this.prevStatement = prev;\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  /**\n   * @param {ImportExpression} expression import expression\n   */\n\n\n  walkImportExpression(expression) {\n    let result = this.hooks.importCall.call(expression);\n    if (result === true) return;\n    this.walkExpression(expression.source);\n  }\n\n  walkCallExpression(expression) {\n    const isSimpleFunction = fn => {\n      return fn.params.every(p => p.type === \"Identifier\");\n    };\n\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type.endsWith(\"FunctionExpression\") && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0 && isSimpleFunction(expression.callee.object)) {\n      // (function(…) { }.call/bind(?, …))\n      this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type.endsWith(\"FunctionExpression\") && isSimpleFunction(expression.callee)) {\n      // (function(…) { }(…))\n      this._walkIIFE(expression.callee, expression.arguments, null);\n    } else {\n      if (expression.callee.type === \"MemberExpression\") {\n        const exprInfo = this.getMemberExpressionInfo(expression.callee, ALLOWED_MEMBER_TYPES_CALL_EXPRESSION);\n\n        if (exprInfo && exprInfo.type === \"call\") {\n          const result = this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers(), exprInfo.getMemberRanges());\n          if (result === true) return;\n        }\n      }\n\n      const callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        const result1 = this.callHooksForInfo(this.hooks.callMemberChain, callee.rootInfo, expression, callee.getMembers(), callee.getMembersOptionals ? callee.getMembersOptionals() : callee.getMembers().map(() => false), callee.getMemberRanges ? callee.getMemberRanges() : []);\n        if (result1 === true) return;\n        const result2 = this.callHooksForInfo(this.hooks.call, callee.identifier, expression);\n        if (result2 === true) return;\n      }\n\n      if (expression.callee) {\n        if (expression.callee.type === \"MemberExpression\") {\n          // because of call context we need to walk the call context as expression\n          this.walkExpression(expression.callee.object);\n          if (expression.callee.computed === true) this.walkExpression(expression.callee.property);\n        } else {\n          this.walkExpression(expression.callee);\n        }\n      }\n\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n  /**\n   * @param {MemberExpression} expression member expression\n   */\n\n\n  walkMemberExpression(expression) {\n    const exprInfo = this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_ALL);\n\n    if (exprInfo) {\n      switch (exprInfo.type) {\n        case \"expression\":\n          {\n            const result1 = this.callHooksForInfo(this.hooks.expression, exprInfo.name, expression);\n            if (result1 === true) return;\n            const members = exprInfo.getMembers();\n            const membersOptionals = exprInfo.getMembersOptionals();\n            const memberRanges = exprInfo.getMemberRanges();\n            const result2 = this.callHooksForInfo(this.hooks.expressionMemberChain, exprInfo.rootInfo, expression, members, membersOptionals, memberRanges);\n            if (result2 === true) return;\n            this.walkMemberExpressionWithExpressionName(expression, exprInfo.name, exprInfo.rootInfo, members.slice(), () => this.callHooksForInfo(this.hooks.unhandledExpressionMemberChain, exprInfo.rootInfo, expression, members));\n            return;\n          }\n\n        case \"call\":\n          {\n            const result = this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers(), exprInfo.getMemberRanges());\n            if (result === true) return; // Fast skip over the member chain as we already called memberChainOfCallMemberChain\n            // and call computed property are literals anyway\n\n            this.walkExpression(exprInfo.call);\n            return;\n          }\n      }\n    }\n\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  walkMemberExpressionWithExpressionName(expression, name, rootInfo, members, onUnhandled) {\n    if (expression.object.type === \"MemberExpression\") {\n      // optimize the case where expression.object is a MemberExpression too.\n      // we can keep info here when calling walkMemberExpression directly\n      const property = expression.property.name || `${expression.property.value}`;\n      name = name.slice(0, -property.length - 1);\n      members.pop();\n      const result = this.callHooksForInfo(this.hooks.expression, name, expression.object);\n      if (result === true) return;\n      this.walkMemberExpressionWithExpressionName(expression.object, name, rootInfo, members, onUnhandled);\n    } else if (!onUnhandled || !onUnhandled()) {\n      this.walkExpression(expression.object);\n    }\n\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n  /**\n   * @param {ThisExpression} expression this expression\n   */\n\n\n  walkThisExpression(expression) {\n    this.callHooksForName(this.hooks.expression, \"this\", expression);\n  }\n  /**\n   * @param {Identifier} expression identifier\n   */\n\n\n  walkIdentifier(expression) {\n    this.callHooksForName(this.hooks.expression, expression.name, expression);\n  }\n  /**\n   * @param {MetaProperty} metaProperty meta property\n   */\n\n\n  walkMetaProperty(metaProperty) {\n    this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n  }\n\n  callHooksForExpression(hookMap, expr) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return this.callHooksForExpressionWithFallback(hookMap, expr, undefined, undefined, ...args);\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {MemberExpression} expr expression info\n   * @param {(function(string, string | ScopeInfo | VariableInfo, function(): string[]): any) | undefined} fallback callback when variable in not handled by hooks\n   * @param {(function(string): any) | undefined} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n\n\n  callHooksForExpressionWithFallback(hookMap, expr, fallback, defined) {\n    const exprName = this.getMemberExpressionInfo(expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n\n    if (exprName !== undefined) {\n      const members = exprName.getMembers();\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {\n        args[_key2 - 4] = arguments[_key2];\n      }\n\n      return this.callHooksForInfoWithFallback(hookMap, members.length === 0 ? exprName.rootInfo : exprName.name, fallback && (name => fallback(name, exprName.rootInfo, exprName.getMembers)), defined && (() => defined(exprName.name)), ...args);\n    }\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {string} name key in map\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n\n\n  callHooksForName(hookMap, name) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    return this.callHooksForNameWithFallback(hookMap, name, undefined, undefined, ...args);\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n   * @param {ExportedVariableInfo} info variable info\n   * @param  {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n\n\n  callHooksForInfo(hookMap, info) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      args[_key4 - 2] = arguments[_key4];\n    }\n\n    return this.callHooksForInfoWithFallback(hookMap, info, undefined, undefined, ...args);\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {ExportedVariableInfo} info variable info\n   * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n   * @param {(function(): any) | undefined} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n\n\n  callHooksForInfoWithFallback(hookMap, info, fallback, defined) {\n    let name;\n\n    for (var _len5 = arguments.length, args = new Array(_len5 > 4 ? _len5 - 4 : 0), _key5 = 4; _key5 < _len5; _key5++) {\n      args[_key5 - 4] = arguments[_key5];\n    }\n\n    if (typeof info === \"string\") {\n      name = info;\n    } else {\n      if (!(info instanceof VariableInfo)) {\n        if (defined !== undefined) {\n          return defined();\n        }\n\n        return;\n      }\n\n      let tagInfo = info.tagInfo;\n\n      while (tagInfo !== undefined) {\n        const hook = hookMap.get(tagInfo.tag);\n\n        if (hook !== undefined) {\n          this.currentTagData = tagInfo.data;\n          const result = hook.call(...args);\n          this.currentTagData = undefined;\n          if (result !== undefined) return result;\n        }\n\n        tagInfo = tagInfo.next;\n      }\n\n      if (info.freeName === true) {\n        if (defined !== undefined) {\n          return defined();\n        }\n\n        return;\n      }\n\n      name = info.freeName;\n    }\n\n    const hook = hookMap.get(name);\n\n    if (hook !== undefined) {\n      const result = hook.call(...args);\n      if (result !== undefined) return result;\n    }\n\n    if (fallback !== undefined) {\n      return fallback(name);\n    }\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {string} name key in map\n   * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n   * @param {(function(): any) | undefined} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n\n\n  callHooksForNameWithFallback(hookMap, name, fallback, defined) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 4 ? _len6 - 4 : 0), _key6 = 4; _key6 < _len6; _key6++) {\n      args[_key6 - 4] = arguments[_key6];\n    }\n\n    return this.callHooksForInfoWithFallback(hookMap, this.getVariableInfo(name), fallback, defined, ...args);\n  }\n  /**\n   * @deprecated\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    this.undefineVariable(\"this\");\n    this.enterPatterns(params, (ident, pattern) => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n  /**\n   * @param {boolean} hasThis true, when this is defined\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inClassScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n\n    if (hasThis) {\n      this.undefineVariable(\"this\");\n    }\n\n    this.enterPatterns(params, (ident, pattern) => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n  /**\n   * @param {boolean} hasThis true, when this is defined\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inFunctionScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n\n    if (hasThis) {\n      this.undefineVariable(\"this\");\n    }\n\n    this.enterPatterns(params, (ident, pattern) => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n  /**\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inBlockScope(fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: oldScope.inTry,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    fn();\n    this.scope = oldScope;\n  }\n  /**\n   * @param {Array<Directive | Statement | ModuleDeclaration>} statements statements\n   */\n\n\n  detectMode(statements) {\n    const isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n    if (isLiteral &&\n    /** @type {Literal} */\n\n    /** @type {ExpressionStatement} */\n    statements[0].expression.value === \"use strict\") {\n      this.scope.isStrict = true;\n    }\n\n    if (isLiteral &&\n    /** @type {Literal} */\n\n    /** @type {ExpressionStatement} */\n    statements[0].expression.value === \"use asm\") {\n      this.scope.isAsmJs = true;\n    }\n  }\n\n  enterPatterns(patterns, onIdent) {\n    for (const pattern of patterns) {\n      if (typeof pattern !== \"string\") {\n        this.enterPattern(pattern, onIdent);\n      } else if (pattern) {\n        onIdent(pattern);\n      }\n    }\n  }\n\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n\n      case \"Property\":\n        if (pattern.shorthand && pattern.value.type === \"Identifier\") {\n          this.scope.inShorthand = pattern.value.name;\n          this.enterIdentifier(pattern.value, onIdent);\n          this.scope.inShorthand = false;\n        } else {\n          this.enterPattern(pattern.value, onIdent);\n        }\n\n        break;\n    }\n  }\n  /**\n   * @param {Identifier} pattern identifier pattern\n   * @param {TODO} onIdent callback\n   */\n\n\n  enterIdentifier(pattern, onIdent) {\n    if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n      onIdent(pattern.name, pattern);\n    }\n  }\n  /**\n   * @param {ObjectPattern} pattern object pattern\n   * @param {TODO} onIdent callback\n   */\n\n\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop, onIdent);\n    }\n  }\n  /**\n   * @param {ArrayPattern} pattern object pattern\n   * @param {TODO} onIdent callback\n   */\n\n\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex]; // TODO check on `null`?\n\n      this.enterPattern(element, onIdent);\n    }\n  }\n  /**\n   * @param {RestElement} pattern object pattern\n   * @param {TODO} onIdent callback\n   */\n\n\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n  /**\n   * @param {AssignmentPattern} pattern object pattern\n   * @param {TODO} onIdent callback\n   */\n\n\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n  /**\n   * @param {TODO} expression expression node\n   * @returns {BasicEvaluatedExpression} evaluation result\n   */\n\n\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n\n        if (result !== undefined && result !== null) {\n          result.setExpression(expression);\n          return result;\n        }\n      }\n    } catch (e) {\n      console.warn(e); // ignore error\n    }\n\n    return new BasicEvaluatedExpression().setRange(\n    /** @type {Range} */\n    expression.range).setExpression(expression);\n  }\n  /**\n   * @param {Expression} expression expression\n   * @returns {string} parsed string\n   */\n\n\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(expression.left) + this.parseString(expression.right);\n        }\n\n        break;\n\n      case \"Literal\":\n        return expression.value + \"\";\n    }\n\n    throw new Error(expression.type + \" is not supported as parameter for require\");\n  }\n\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(expression.left);\n          const right = this.parseCalculatedString(expression.right);\n\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          } else {\n            return {\n              range: [left.range[0], right.range[1]],\n              value: left.value + right.value,\n              code: false,\n              conditional: false\n            };\n          }\n        }\n\n        break;\n\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: expression.value + \"\",\n          code: false,\n          conditional: false\n        };\n    }\n\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n  /**\n   * @param {string | Buffer | PreparsedAst} source the source to parse\n   * @param {ParserState} state the parser state\n   * @returns {ParserState} the parser state\n   */\n\n\n  parse(source, state) {\n    let ast;\n    let comments;\n    const semicolons = new Set();\n\n    if (source === null) {\n      throw new Error(\"source must not be null\");\n    }\n\n    if (Buffer.isBuffer(source)) {\n      source = source.toString(\"utf-8\");\n    }\n\n    if (typeof source === \"object\") {\n      ast =\n      /** @type {Program} */\n      source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = JavascriptParser._parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments,\n        onInsertedSemicolon: pos => semicolons.add(pos)\n      });\n    }\n\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    const oldSemicolons = this.semicolons;\n    const oldStatementPath = this.statementPath;\n    const oldPrevStatement = this.prevStatement;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: false,\n      isAsmJs: false,\n      definitions: new StackedMap()\n    };\n    /** @type {ParserState} */\n\n    this.state = state;\n    this.comments = comments;\n    this.semicolons = semicolons;\n    this.statementPath = [];\n    this.prevStatement = undefined;\n\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.destructuringAssignmentProperties = new WeakMap();\n      this.detectMode(ast.body);\n      this.preWalkStatements(ast.body);\n      this.prevStatement = undefined;\n      this.blockPreWalkStatements(ast.body);\n      this.prevStatement = undefined;\n      this.walkStatements(ast.body);\n      this.destructuringAssignmentProperties = undefined;\n    }\n\n    this.hooks.finish.call(ast, comments);\n    this.scope = oldScope;\n    /** @type {ParserState} */\n\n    this.state = oldState;\n    this.comments = oldComments;\n    this.semicolons = oldSemicolons;\n    this.statementPath = oldStatementPath;\n    this.prevStatement = oldPrevStatement;\n    return state;\n  }\n  /**\n   * @param {string} source source code\n   * @returns {BasicEvaluatedExpression} evaluation result\n   */\n\n\n  evaluate(source) {\n    const ast = JavascriptParser._parse(\"(\" + source + \")\", {\n      sourceType: this.sourceType,\n      locations: false\n    });\n\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    }\n\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n  /**\n   * @param {Expression | Declaration | PrivateIdentifier | null | undefined} expr an expression\n   * @param {number} commentsStartPos source position from which annotation comments are checked\n   * @returns {boolean} true, when the expression is pure\n   */\n\n\n  isPure(expr, commentsStartPos) {\n    if (!expr) return true;\n    const result = this.hooks.isPure.for(expr.type).call(expr, commentsStartPos);\n    if (typeof result === \"boolean\") return result;\n\n    switch (expr.type) {\n      // TODO handle more cases\n      case \"ClassDeclaration\":\n      case \"ClassExpression\":\n        {\n          if (expr.body.type !== \"ClassBody\") return false;\n\n          if (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n            return false;\n          }\n\n          const items =\n          /** @type {TODO[]} */\n          expr.body.body;\n          return items.every(item => {\n            if (item.computed && item.key && !this.isPure(item.key, item.range[0])) {\n              return false;\n            }\n\n            if (item.static && item.value && !this.isPure(item.value, item.key ? item.key.range[1] : item.range[0])) {\n              return false;\n            }\n\n            if (item.type === \"StaticBlock\") {\n              return false;\n            }\n\n            return true;\n          });\n        }\n\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"ThisExpression\":\n      case \"Literal\":\n      case \"TemplateLiteral\":\n      case \"Identifier\":\n      case \"PrivateIdentifier\":\n        return true;\n\n      case \"VariableDeclaration\":\n        return expr.declarations.every(decl => this.isPure(decl.init,\n        /** @type {Range} */\n        decl.range[0]));\n\n      case \"ConditionalExpression\":\n        return this.isPure(expr.test, commentsStartPos) && this.isPure(expr.consequent,\n        /** @type {Range} */\n        expr.test.range[1]) && this.isPure(expr.alternate,\n        /** @type {Range} */\n        expr.consequent.range[1]);\n\n      case \"LogicalExpression\":\n        return this.isPure(expr.left, commentsStartPos) && this.isPure(expr.right,\n        /** @type {Range} */\n        expr.left.range[1]);\n\n      case \"SequenceExpression\":\n        return expr.expressions.every(expr => {\n          const pureFlag = this.isPure(expr, commentsStartPos);\n          commentsStartPos =\n          /** @type {Range} */\n          expr.range[1];\n          return pureFlag;\n        });\n\n      case \"CallExpression\":\n        {\n          const pureFlag =\n          /** @type {Range} */\n          expr.range[0] - commentsStartPos > 12 && this.getComments([commentsStartPos,\n          /** @type {Range} */\n          expr.range[0]]).some(comment => comment.type === \"Block\" && /^\\s*(#|@)__PURE__\\s*$/.test(comment.value));\n          if (!pureFlag) return false;\n          commentsStartPos =\n          /** @type {Range} */\n          expr.callee.range[1];\n          return expr.arguments.every(arg => {\n            if (arg.type === \"SpreadElement\") return false;\n            const pureFlag = this.isPure(arg, commentsStartPos);\n            commentsStartPos =\n            /** @type {Range} */\n            arg.range[1];\n            return pureFlag;\n          });\n        }\n    }\n\n    const evaluated = this.evaluateExpression(expr);\n    return !evaluated.couldHaveSideEffects();\n  }\n  /**\n   * @param {Range} range range\n   * @returns {TODO[]} comments in the range\n   */\n\n\n  getComments(range) {\n    const [rangeStart, rangeEnd] = range;\n\n    const compare = (comment, needle) => comment.range[0] - needle;\n\n    let idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n    let commentsInRange = [];\n\n    while (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n      commentsInRange.push(this.comments[idx]);\n      idx++;\n    }\n\n    return commentsInRange;\n  }\n  /**\n   * @param {number} pos source code position\n   * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n   */\n\n\n  isAsiPosition(pos) {\n    const currentStatement = this.statementPath[this.statementPath.length - 1];\n    if (currentStatement === undefined) throw new Error(\"Not in statement\");\n    return (// Either asking directly for the end position of the current statement\n      currentStatement.range[1] === pos && this.semicolons.has(pos) || // Or asking for the start position of the current statement,\n      // here we have to check multiple things\n      currentStatement.range[0] === pos && // is there a previous statement which might be relevant?\n      this.prevStatement !== undefined && // is the end position of the previous statement an ASI position?\n      this.semicolons.has(this.prevStatement.range[1])\n    );\n  }\n  /**\n   * @param {number} pos source code position\n   * @returns {void}\n   */\n\n\n  unsetAsiPosition(pos) {\n    this.semicolons.delete(pos);\n  }\n  /**\n   * @param {Expression} expr expression\n   * @returns {boolean} true, when the expression is a statement level expression\n   */\n\n\n  isStatementLevelExpression(expr) {\n    const currentStatement = this.statementPath[this.statementPath.length - 1];\n    return expr === currentStatement || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expr;\n  }\n\n  getTagData(name, tag) {\n    const info = this.scope.definitions.get(name);\n\n    if (info instanceof VariableInfo) {\n      let tagInfo = info.tagInfo;\n\n      while (tagInfo !== undefined) {\n        if (tagInfo.tag === tag) return tagInfo.data;\n        tagInfo = tagInfo.next;\n      }\n    }\n  }\n\n  tagVariable(name, tag, data) {\n    const oldInfo = this.scope.definitions.get(name);\n    /** @type {VariableInfo} */\n\n    let newInfo;\n\n    if (oldInfo === undefined) {\n      newInfo = new VariableInfo(this.scope, name, {\n        tag,\n        data,\n        next: undefined\n      });\n    } else if (oldInfo instanceof VariableInfo) {\n      newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n        tag,\n        data,\n        next: oldInfo.tagInfo\n      });\n    } else {\n      newInfo = new VariableInfo(oldInfo, true, {\n        tag,\n        data,\n        next: undefined\n      });\n    }\n\n    this.scope.definitions.set(name, newInfo);\n  }\n  /**\n   * @param {string} name variable name\n   */\n\n\n  defineVariable(name) {\n    const oldInfo = this.scope.definitions.get(name); // Don't redefine variable in same scope to keep existing tags\n\n    if (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope) return;\n    this.scope.definitions.set(name, this.scope);\n  }\n  /**\n   * @param {string} name variable name\n   */\n\n\n  undefineVariable(name) {\n    this.scope.definitions.delete(name);\n  }\n  /**\n   * @param {string} name variable name\n   * @returns {boolean} true, when variable is defined\n   */\n\n\n  isVariableDefined(name) {\n    const info = this.scope.definitions.get(name);\n    if (info === undefined) return false;\n\n    if (info instanceof VariableInfo) {\n      return info.freeName === true;\n    }\n\n    return true;\n  }\n  /**\n   * @param {string} name variable name\n   * @returns {ExportedVariableInfo} info for this variable\n   */\n\n\n  getVariableInfo(name) {\n    const value = this.scope.definitions.get(name);\n\n    if (value === undefined) {\n      return name;\n    } else {\n      return value;\n    }\n  }\n  /**\n   * @param {string} name variable name\n   * @param {ExportedVariableInfo} variableInfo new info for this variable\n   * @returns {void}\n   */\n\n\n  setVariable(name, variableInfo) {\n    if (typeof variableInfo === \"string\") {\n      if (variableInfo === name) {\n        this.scope.definitions.delete(name);\n      } else {\n        this.scope.definitions.set(name, new VariableInfo(this.scope, variableInfo, undefined));\n      }\n    } else {\n      this.scope.definitions.set(name, variableInfo);\n    }\n  }\n  /**\n   * @param {TagInfo} tagInfo tag info\n   * @returns {VariableInfo} variable info\n   */\n\n\n  evaluatedVariable(tagInfo) {\n    return new VariableInfo(this.scope, undefined, tagInfo);\n  }\n  /**\n   * @param {Range} range range of the comment\n   * @returns {TODO} TODO\n   */\n\n\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n\n    let options = {};\n    /** @type {unknown[]} */\n\n    let errors = [];\n\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          for (let [key, val] of Object.entries(vm.runInNewContext(`(function(){return {${value}};})()`))) {\n            if (typeof val === \"object\" && val !== null) {\n              if (val.constructor.name === \"RegExp\") val = new RegExp(val);else val = JSON.parse(JSON.stringify(val));\n            }\n\n            options[key] = val;\n          }\n        } catch (e) {\n          const newErr = new Error(String(e.message));\n          newErr.stack = String(e.stack);\n          Object.assign(newErr, {\n            comment\n          });\n          errors.push(newErr);\n        }\n      }\n    }\n\n    return {\n      options,\n      errors\n    };\n  }\n  /**\n   * @param {MemberExpression} expression a member expression\n   * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] }} member names (reverse order) and remaining object\n   */\n\n\n  extractMemberExpressionChain(expression) {\n    /** @type {AnyNode} */\n    let expr = expression;\n    const members = [];\n    const membersOptionals = [];\n    const memberRanges = [];\n\n    while (expr.type === \"MemberExpression\") {\n      if (expr.computed) {\n        if (expr.property.type !== \"Literal\") break;\n        members.push(`${expr.property.value}`); // the literal\n\n        memberRanges.push(expr.object.range); // the range of the expression fragment before the literal\n      } else {\n        if (expr.property.type !== \"Identifier\") break;\n        members.push(expr.property.name); // the identifier\n\n        memberRanges.push(expr.object.range); // the range of the expression fragment before the identifier\n      }\n\n      membersOptionals.push(expr.optional);\n      expr = expr.object;\n    }\n\n    return {\n      members,\n      membersOptionals,\n      memberRanges,\n      object: expr\n    };\n  }\n  /**\n   * @param {string} varName variable name\n   * @returns {{name: string, info: VariableInfo | string} | undefined} name of the free variable and variable info for that\n   */\n\n\n  getFreeInfoFromVariable(varName) {\n    const info = this.getVariableInfo(varName);\n    let name;\n\n    if (info instanceof VariableInfo) {\n      name = info.freeName;\n      if (typeof name !== \"string\") return undefined;\n    } else if (typeof info !== \"string\") {\n      return undefined;\n    } else {\n      name = info;\n    }\n\n    return {\n      info,\n      name\n    };\n  }\n  /** @typedef {{ type: \"call\", call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} CallExpressionInfo */\n\n  /** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} ExpressionExpressionInfo */\n\n  /**\n   * @param {MemberExpression} expression a member expression\n   * @param {number} allowedTypes which types should be returned, presented in bit mask\n   * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n   */\n\n\n  getMemberExpressionInfo(expression, allowedTypes) {\n    const {\n      object,\n      members,\n      membersOptionals,\n      memberRanges\n    } = this.extractMemberExpressionChain(expression);\n\n    switch (object.type) {\n      case \"CallExpression\":\n        {\n          if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return undefined;\n          let callee = object.callee;\n          let rootMembers = EMPTY_ARRAY;\n\n          if (callee.type === \"MemberExpression\") {\n            ({\n              object: callee,\n              members: rootMembers\n            } = this.extractMemberExpressionChain(callee));\n          }\n\n          const rootName = getRootName(callee);\n          if (!rootName) return undefined;\n          const result = this.getFreeInfoFromVariable(rootName);\n          if (!result) return undefined;\n          const {\n            info: rootInfo,\n            name: resolvedRoot\n          } = result;\n          const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n          return {\n            type: \"call\",\n            call: object,\n            calleeName,\n            rootInfo,\n            getCalleeMembers: memoize(() => rootMembers.reverse()),\n            name: objectAndMembersToName(`${calleeName}()`, members),\n            getMembers: memoize(() => members.reverse()),\n            getMembersOptionals: memoize(() => membersOptionals.reverse()),\n            getMemberRanges: memoize(() => memberRanges.reverse())\n          };\n        }\n\n      case \"Identifier\":\n      case \"MetaProperty\":\n      case \"ThisExpression\":\n        {\n          if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return undefined;\n          const rootName = getRootName(object);\n          if (!rootName) return undefined;\n          const result = this.getFreeInfoFromVariable(rootName);\n          if (!result) return undefined;\n          const {\n            info: rootInfo,\n            name: resolvedRoot\n          } = result;\n          return {\n            type: \"expression\",\n            name: objectAndMembersToName(resolvedRoot, members),\n            rootInfo,\n            getMembers: memoize(() => members.reverse()),\n            getMembersOptionals: memoize(() => membersOptionals.reverse()),\n            getMemberRanges: memoize(() => memberRanges.reverse())\n          };\n        }\n    }\n  }\n  /**\n   * @param {MemberExpression} expression an expression\n   * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]} | undefined} name info\n   */\n\n\n  getNameForExpression(expression) {\n    return this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_EXPRESSION);\n  }\n  /**\n   * @param {string} code source code\n   * @param {ParseOptions} options parsing options\n   * @returns {Program} parsed ast\n   */\n\n\n  static _parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    /** @type {AcornOptions} */\n\n    const parserOptions = { ...defaultParserOptions,\n      allowReturnOutsideFunction: type === \"script\",\n      ...options,\n      sourceType: type === \"auto\" ? \"module\" : type\n    };\n    /** @type {AnyNode | undefined} */\n\n    let ast;\n    let error;\n    let threw = false;\n\n    try {\n      ast =\n      /** @type {AnyNode} */\n      parser.parse(code, parserOptions);\n    } catch (e) {\n      error = e;\n      threw = true;\n    }\n\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n\n      if (!(\"allowReturnOutsideFunction\" in options)) {\n        parserOptions.allowReturnOutsideFunction = true;\n      }\n\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n\n      try {\n        ast =\n        /** @type {AnyNode} */\n        parser.parse(code, parserOptions);\n        threw = false;\n      } catch (e) {// we use the error from first parse try\n        // so nothing to do here\n      }\n    }\n\n    if (threw) {\n      throw error;\n    }\n\n    return (\n      /** @type {Program} */\n      ast\n    );\n  }\n\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION = ALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/javascript/JavascriptParser.js"],"names":["Parser","AcornParser","require","importAssertions","SyncBailHook","HookMap","vm","StackedMap","binarySearchBounds","memoize","BasicEvaluatedExpression","EMPTY_ARRAY","ALLOWED_MEMBER_TYPES_CALL_EXPRESSION","ALLOWED_MEMBER_TYPES_EXPRESSION","ALLOWED_MEMBER_TYPES_ALL","parser","extend","VariableInfo","constructor","declaredScope","freeName","tagInfo","joinRanges","startRange","endRange","objectAndMembersToName","object","membersReversed","name","i","length","getRootName","expression","type","meta","property","undefined","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","allowHashBang","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","JavascriptParser","hooks","Object","freeze","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateNewExpression","evaluateCallExpression","evaluateCallExpressionMember","isPure","preStatement","blockPreStatement","statement","statementIf","classExtendsExpression","classBodyElement","classBodyValue","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","preDeclarator","declarator","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","pattern","canRename","rename","assign","assignMemberChain","typeof","importCall","topLevelAwait","call","callMemberChain","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","optionalChaining","new","binaryExpression","expressionMemberChain","unhandledExpressionMemberChain","expressionConditionalOperator","expressionLogicalOperator","program","finish","scope","state","comments","semicolons","statementPath","prevStatement","destructuringAssignmentProperties","currentTagData","_initializeEvaluating","for","tap","_expr","expr","value","setNumber","setRange","range","setBigInt","setString","setBoolean","setNull","setRegExp","callee","callHooksForName","arguments","getVariableInfo","regExp","flags","arg1","evaluatedRegExp","evaluateExpression","asString","arg2","evaluatedFlags","isUndefined","isValidRegExpFlags","left","returnRight","allowedRight","operator","leftAsBool","asBool","leftAsNullish","asNullish","right","couldHaveSideEffects","setSideEffects","setTruthy","setFalsy","valueAsExpression","sideEffects","handleConstOperation","operandHandler","isCompileTimeValue","result","asCompileTimeValue","isAlwaysDifferent","a","b","handleTemplateStringCompare","res","eql","getPrefix","parts","p","v","getSuffix","leftPrefix","rightPrefix","leftSuffix","rightSuffix","lenPrefix","Math","min","lenSuffix","prefixMismatch","slice","suffixMismatch","handleStrictEqualityComparison","leftConst","rightConst","isArray","isTemplateString","leftPrimitive","isPrimitiveType","rightPrimitive","handleAbstractEqualityComparison","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","isBigInt","bigint","concat","l","r","argument","callHooksForExpression","arg","isUnknown","isBoolean","isConstArray","isRegExp","isNull","bool","setUndefined","tapEvaluateWithVariableInfo","exprType","getInfo","cachedExpression","cachedInfo","info","callHooksForInfoWithFallback","hook","get","stage","setIdentifier","rootInfo","getMembers","getMembersOptionals","getMemberRanges","metaProperty","getMemberExpressionInfo","computed","param","arg1Eval","arg1Value","arg2Eval","indexOf","arg2Value","replace","forEach","fn","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","quasiExpr","quasi","prevExpr","expressions","exprAsString","setExpression","push","part","_node","node","setTemplateString","tag","isIdentifier","identifier","stringSuffix","hasUnknownParams","innerExpressions","argExpr","newString","newRange","inner","reverse","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","optionalExpressionsStack","next","optional","pop","evaluated","destructuringAssignmentPropertiesFor","getRenameIdentifier","walkClass","classy","superClass","walkExpression","body","scopeParams","id","inClassScope","classElement","key","wasTopLevel","topLevelScope","walkBlockStatement","preWalkStatements","statements","index","len","preWalkStatement","blockPreWalkStatements","blockPreWalkStatement","walkStatements","walkStatement","preWalkBlockStatement","preWalkDoWhileStatement","preWalkForInStatement","preWalkForOfStatement","preWalkForStatement","preWalkFunctionDeclaration","preWalkIfStatement","preWalkLabeledStatement","preWalkSwitchStatement","preWalkTryStatement","preWalkVariableDeclaration","preWalkWhileStatement","preWalkWithStatement","blockPreWalkImportDeclaration","blockPreWalkExportAllDeclaration","blockPreWalkExportDefaultDeclaration","blockPreWalkExportNamedDeclaration","blockPreWalkVariableDeclaration","blockPreWalkClassDeclaration","blockPreWalkExpressionStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","walkNestedStatement","inBlockScope","prev","preWalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","handler","preWalkCatchClause","finalizer","inTry","walkCatchClause","init","update","walkPattern","await","defineVariable","inFunctionScope","params","detectMode","preWalkAssignmentExpression","keys","_preWalkObjectPattern","has","set","delete","add","source","specifier","specifiers","local","imported","enterDeclaration","declaration","onIdent","declarations","enterPattern","def","specifierIndex","exported","_preWalkVariableDeclaration","hookMap","preWalkVariableDeclarator","decl","objectPattern","ids","Set","properties","renameIdentifier","setVariable","switchCases","switchCase","catchClause","ident","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","prop","walkExpressions","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkChainExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkImportExpression","walkLogicalExpression","walkMetaProperty","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","propIndex","walkProperty","shorthand","inShorthand","currentStatement","old","walkLeftRightExpression","callHooksForInfo","endsWith","exprName","inTaggedTemplateTag","_walkIIFE","functionExpression","currentThis","getVarInfo","argOrThis","arrow","renameThis","varInfoForArgs","filter","idx","varInfo","isSimpleFunction","exprInfo","getCalleeMembers","result1","result2","members","membersOptionals","memberRanges","walkMemberExpressionWithExpressionName","onUnhandled","args","callHooksForExpressionWithFallback","fallback","defined","callHooksForNameWithFallback","data","inScope","oldScope","isStrict","isAsmJs","definitions","createChild","undefineVariable","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","parse","ast","Buffer","isBuffer","toString","_parse","onInsertedSemicolon","pos","oldState","oldComments","oldSemicolons","oldStatementPath","oldPrevStatement","WeakMap","commentsStartPos","item","static","pureFlag","getComments","some","comment","rangeStart","rangeEnd","compare","needle","ge","commentsInRange","isAsiPosition","unsetAsiPosition","isStatementLevelExpression","getTagData","tagVariable","oldInfo","newInfo","isVariableDefined","variableInfo","evaluatedVariable","parseCommentOptions","val","entries","runInNewContext","JSON","stringify","newErr","String","message","stack","extractMemberExpressionChain","getFreeInfoFromVariable","varName","allowedTypes","rootMembers","rootName","resolvedRoot","calleeName","getNameForExpression","parserOptions","allowReturnOutsideFunction","error","threw","Array","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { Parser: AcornParser } = require(\"acorn\");\nconst { importAssertions } = require(\"acorn-import-assertions\");\nconst { SyncBailHook, HookMap } = require(\"tapable\");\nconst vm = require(\"vm\");\nconst Parser = require(\"../Parser\");\nconst StackedMap = require(\"../util/StackedMap\");\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\nconst memoize = require(\"../util/memoize\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpression */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatement */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpression */\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").BaseCallExpression} BaseCallExpression */\n/** @typedef {import(\"estree\").StaticBlock} StaticBlock */\n/** @typedef {import(\"estree\").ImportExpression} ImportExpression */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclaration */\n/** @typedef {import(\"estree\").ForStatement} ForStatement */\n/** @typedef {import(\"estree\").SwitchStatement} SwitchStatement */\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclaration */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpression */\n/** @typedef {import(\"estree\").Comment} Comment */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpression */\n/** @typedef {import(\"estree\").Declaration} Declaration */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifier */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinition */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n/** @typedef {import(\"estree\").VariableDeclaration} VariableDeclaration */\n/** @typedef {import(\"estree\").IfStatement} IfStatement */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatement */\n/** @typedef {import(\"estree\").Literal} Literal */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpression */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpression */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpression */\n/** @typedef {import(\"estree\").YieldExpression} YieldExpression */\n/** @typedef {import(\"estree\").MetaProperty} MetaProperty */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").AssignmentPattern} AssignmentPattern */\n/** @typedef {import(\"estree\").ChainElement} ChainElement */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").UpdateExpression} UpdateExpression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpression */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpression */\n/** @typedef {import(\"estree\").ArrayPattern} ArrayPattern */\n/** @typedef {import(\"estree\").AwaitExpression} AwaitExpression */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpression */\n/** @typedef {import(\"estree\").RestElement} RestElement */\n/** @typedef {import(\"estree\").ObjectPattern} ObjectPattern */\n/** @typedef {import(\"estree\").SwitchCase} SwitchCase */\n/** @typedef {import(\"estree\").CatchClause} CatchClause */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclarator */\n/** @typedef {import(\"estree\").ForInStatement} ForInStatement */\n/** @typedef {import(\"estree\").ForOfStatement} ForOfStatement */\n/** @typedef {import(\"estree\").ReturnStatement} ReturnStatement */\n/** @typedef {import(\"estree\").WithStatement} WithStatement */\n/** @typedef {import(\"estree\").ThrowStatement} ThrowStatement */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinition */\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclaration */\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"estree\").FunctionExpression} FunctionExpression */\n/** @typedef {import(\"estree\").WhileStatement} WhileStatement */\n/** @typedef {import(\"estree\").ArrowFunctionExpression} ArrowFunctionExpression */\n/** @typedef {import(\"estree\").ExpressionStatement} ExpressionStatement */\n/** @typedef {import(\"estree\").FunctionDeclaration} FunctionDeclaration */\n/** @typedef {import(\"estree\").DoWhileStatement} DoWhileStatement */\n/** @typedef {import(\"estree\").TryStatement} TryStatement */\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"estree\").Program} Program */\n/** @typedef {import(\"estree\").Directive} Directive */\n/** @typedef {import(\"estree\").Statement} Statement */\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclaration */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclaration */\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclaration */\n/** @typedef {import(\"estree\").Super} Super */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpression */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteral */\n/** @typedef {Record<string, any>} Assertions */\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[] }} GetInfoResult */\n\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11;\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst parser = AcornParser.extend(importAssertions);\n\nclass VariableInfo {\n\t/**\n\t * @param {ScopeInfo} declaredScope scope in which the variable is declared\n\t * @param {string | true | undefined} freeName which free name the variable aliases, or true when none\n\t * @param {TagInfo | undefined} tagInfo info about tags\n\t */\n\tconstructor(declaredScope, freeName, tagInfo) {\n\t\tthis.declaredScope = declaredScope;\n\t\tthis.freeName = freeName;\n\t\tthis.tagInfo = tagInfo;\n\t}\n}\n\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {Literal | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean | string} inShorthand\n * @property {boolean} inTaggedTemplateTag\n * @property {boolean} inTry\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n */\n\n/** @typedef {[number, number]} Range */\n\n/**\n * Helper function for joining two ranges into a single range. This is useful\n * when working with AST nodes, as it allows you to combine the ranges of child nodes\n * to create the range of the _parent node_.\n *\n * @param {[number, number]} startRange start range to join\n * @param {[number, number]} endRange end range to join\n * @returns {[number, number]} joined range\n *\n * @example\n * ```js\n * \tconst startRange = [0, 5];\n * \tconst endRange = [10, 15];\n * \tconst joinedRange = joinRanges(startRange, endRange);\n * \tconsole.log(joinedRange); // [0, 15]\n * ```\n *\n */\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\n/**\n * Helper function used to generate a string representation of a\n * [member expression](https://github.com/estree/estree/blob/master/es5.md#memberexpression).\n *\n * @param {string} object object to name\n * @param {string[]} membersReversed reversed list of members\n * @returns {string} member expression as a string\n * @example\n * ```js\n * const membersReversed = [\"property1\", \"property2\", \"property3\"]; // Members parsed from the AST\n * const name = objectAndMembersToName(\"myObject\", membersReversed);\n *\n * console.log(name); // \"myObject.property1.property2.property3\"\n * ```\n *\n */\nconst objectAndMembersToName = (object, membersReversed) => {\n\tlet name = object;\n\tfor (let i = membersReversed.length - 1; i >= 0; i--) {\n\t\tname = name + \".\" + membersReversed[i];\n\t}\n\treturn name;\n};\n\n/**\n * Grabs the name of a given expression and returns it as a string or undefined. Has particular\n * handling for [Identifiers](https://github.com/estree/estree/blob/master/es5.md#identifier),\n * [ThisExpressions](https://github.com/estree/estree/blob/master/es5.md#identifier), and\n * [MetaProperties](https://github.com/estree/estree/blob/master/es2015.md#metaproperty) which is\n * specifically for handling the `new.target` meta property.\n *\n * @param {Expression | Super} expression expression\n * @returns {string | \"this\" | undefined} name or variable info\n */\nconst getRootName = expression => {\n\tswitch (expression.type) {\n\t\tcase \"Identifier\":\n\t\t\treturn expression.name;\n\t\tcase \"ThisExpression\":\n\t\t\treturn \"this\";\n\t\tcase \"MetaProperty\":\n\t\t\treturn `${expression.meta.name}.${expression.property.name}`;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\n/** @type {AcornOptions} */\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: \"latest\",\n\tsourceType: \"module\",\n\t// https://github.com/tc39/proposal-hashbang\n\tallowHashBang: true,\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass JavascriptParser extends Parser {\n\t/**\n\t * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n\t */\n\tconstructor(sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateNewExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier, number], boolean | void>>} */\n\t\t\tisPure: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n\t\t\tpreStatement: new SyncBailHook([\"statement\"]),\n\n\t\t\t/** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n\t\t\tblockPreStatement: new SyncBailHook([\"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[IfStatement], boolean | void>} */\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[Expression, ClassExpression | ClassDeclaration], boolean | void>} */\n\t\t\tclassExtendsExpression: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration], boolean | void>} */\n\t\t\tclassBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\t\t\t/** @type {SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration], boolean | void>} */\n\t\t\tclassBodyValue: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"element\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {HookMap<SyncBailHook<[LabeledStatement], boolean | void>>} */\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\t/** @type {SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>} */\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ImportDeclaration, ImportSource, string, string], boolean | void>} */\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration], boolean | void>} */\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>} */\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>} */\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclaration, Declaration], boolean | void>} */\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>} */\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string, string, number | undefined], boolean | void>} */\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n\t\t\tpreDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n\t\t\tdeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Identifier], boolean | void>>} */\n\t\t\tpattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>} */\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>} */\n\t\t\tassignMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[ImportExpression], boolean | void>} */\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[Expression], boolean | void>} */\n\t\t\ttopLevelAwait: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression], boolean | void>>} */\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** Something like \"a.b()\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>} */\n\t\t\tcallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"membersOptionals\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n\t\t\tmemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"callExpression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d()\"\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n\t\t\tcallMemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"innerCallExpression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ChainExpression], boolean | void>} */\n\t\t\toptionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpression], boolean | void>>} */\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[BinaryExpression], boolean | void>} */\n\t\t\tbinaryExpression: new SyncBailHook([\"binaryExpression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>} */\n\t\t\texpressionMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"membersOptionals\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>} */\n\t\t\tunhandledExpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ConditionalExpression], boolean | void>} */\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[LogicalExpression], boolean | void>} */\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"]),\n\t\t\t/** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n\t\t\tfinish: new SyncBailHook([\"ast\", \"comments\"])\n\t\t});\n\t\tthis.sourceType = sourceType;\n\t\t/** @type {ScopeInfo} */\n\t\tthis.scope = undefined;\n\t\t/** @type {ParserState} */\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.semicolons = undefined;\n\t\t/** @type {(Statement | ModuleDeclaration | Expression)[]} */\n\t\tthis.statementPath = undefined;\n\t\t/** @type {Statement | ModuleDeclaration | Expression | undefined} */\n\t\tthis.prevStatement = undefined;\n\t\t/** @type {WeakMap<Expression, Set<string>>} */\n\t\tthis.destructuringAssignmentProperties = undefined;\n\t\tthis.currentTagData = undefined;\n\t\tthis._initializeEvaluating();\n\t}\n\n\t_initializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {Literal} */ (_expr);\n\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNull()\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {NewExpression} */ (_expr);\n\t\t\tconst callee = expr.callee;\n\t\t\tif (callee.type !== \"Identifier\") return;\n\t\t\tif (callee.name !== \"RegExp\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateNewExpression,\n\t\t\t\t\tcallee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\texpr.arguments.length > 2 ||\n\t\t\t\tthis.getVariableInfo(\"RegExp\") !== \"RegExp\"\n\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tlet regExp, flags;\n\t\t\tconst arg1 = expr.arguments[0];\n\n\t\t\tif (arg1) {\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedRegExp = this.evaluateExpression(arg1);\n\n\t\t\t\tif (!evaluatedRegExp) return;\n\n\t\t\t\tregExp = evaluatedRegExp.asString();\n\n\t\t\t\tif (!regExp) return;\n\t\t\t} else {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(new RegExp(\"\"))\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\n\t\t\tconst arg2 = expr.arguments[1];\n\n\t\t\tif (arg2) {\n\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedFlags = this.evaluateExpression(arg2);\n\n\t\t\t\tif (!evaluatedFlags) return;\n\n\t\t\t\tif (!evaluatedFlags.isUndefined()) {\n\t\t\t\t\tflags = evaluatedFlags.asString();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tflags === undefined ||\n\t\t\t\t\t\t!BasicEvaluatedExpression.isValidRegExpFlags(flags)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))\n\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"LogicalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {LogicalExpression} */ (_expr);\n\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tlet returnRight = false;\n\t\t\t\t/** @type {boolean|undefined} */\n\t\t\t\tlet allowedRight;\n\t\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === true;\n\t\t\t\t\tallowedRight = false;\n\t\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === false;\n\t\t\t\t\tallowedRight = true;\n\t\t\t\t} else if (expr.operator === \"??\") {\n\t\t\t\t\tconst leftAsNullish = left.asNullish();\n\t\t\t\t\tif (leftAsNullish === false) return left.setRange(expr.range);\n\t\t\t\t\tif (leftAsNullish !== true) return;\n\t\t\t\t\treturnRight = true;\n\t\t\t\t} else return;\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tif (returnRight) {\n\t\t\t\t\tif (left.couldHaveSideEffects()) right.setSideEffects();\n\t\t\t\t\treturn right.setRange(expr.range);\n\t\t\t\t}\n\n\t\t\t\tconst asBool = right.asBool();\n\n\t\t\t\tif (allowedRight === true && asBool === true) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setRange(expr.range)\n\t\t\t\t\t\t.setTruthy();\n\t\t\t\t} else if (allowedRight === false && asBool === false) {\n\t\t\t\t\treturn new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n\t\t\t\t}\n\t\t\t});\n\n\t\t/**\n\t\t * In simple logical cases, we can use valueAsExpression to assist us in evaluating the expression on\n\t\t * either side of a [BinaryExpression](https://github.com/estree/estree/blob/master/es5.md#binaryexpression).\n\t\t * This supports scenarios in webpack like conditionally `import()`'ing modules based on some simple evaluation:\n\t\t *\n\t\t * ```js\n\t\t * if (1 === 3) {\n\t\t *  import(\"./moduleA\"); // webpack will auto evaluate this and not import the modules\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * Additional scenarios include evaluation of strings inside of dynamic import statements:\n\t\t *\n\t\t * ```js\n\t\t * const foo = \"foo\";\n\t\t * const bar = \"bar\";\n\t\t *\n\t\t * import(\"./\" + foo + bar); // webpack will auto evaluate this into import(\"./foobar\")\n\t\t * ```\n\t\t * @param {boolean | number | BigInt | string} value the value to convert to an expression\n\t\t * @param {BinaryExpression | UnaryExpression} expr the expression being evaluated\n\t\t * @param {boolean} sideEffects whether the expression has side effects\n\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t * @example\n\t\t *\n\t\t * ```js\n\t\t * const binaryExpr = new BinaryExpression(\"+\",\n\t\t * \t{ type: \"Literal\", value: 2 },\n\t\t * \t{ type: \"Literal\", value: 3 }\n\t\t * );\n\t\t *\n\t\t * const leftValue = 2;\n\t\t * const rightValue = 3;\n\t\t *\n\t\t * const leftExpr = valueAsExpression(leftValue, binaryExpr.left, false);\n\t\t * const rightExpr = valueAsExpression(rightValue, binaryExpr.right, false);\n\t\t * const result = new BasicEvaluatedExpression()\n\t\t * \t.setNumber(leftExpr.number + rightExpr.number)\n\t\t * \t.setRange(binaryExpr.range);\n\t\t *\n\t\t * console.log(result.number); // Output: 5\n\t\t * ```\n\t\t */\n\t\tconst valueAsExpression = (value, expr, sideEffects) => {\n\t\t\tswitch (typeof value) {\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"BinaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {BinaryExpression} */ (_expr);\n\n\t\t\t\t/**\n\t\t\t\t * Evaluates a binary expression if and only if it is a const operation (e.g. 1 + 2, \"a\" + \"b\", etc.).\n\t\t\t\t *\n\t\t\t\t * @template T\n\t\t\t\t * @param {(leftOperand: T, rightOperand: T) => boolean | number | BigInt | string} operandHandler the handler for the operation (e.g. (a, b) => a + b)\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleConstOperation = operandHandler => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst result = operandHandler(\n\t\t\t\t\t\tleft.asCompileTimeValue(),\n\t\t\t\t\t\tright.asCompileTimeValue()\n\t\t\t\t\t);\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Helper function to determine if two booleans are always different. This is used in `handleStrictEqualityComparison`\n\t\t\t\t * to determine if an expressions boolean or nullish conversion is equal or not.\n\t\t\t\t *\n\t\t\t\t * @param {boolean} a first boolean to compare\n\t\t\t\t * @param {boolean} b second boolean to compare\n\t\t\t\t * @returns {boolean} true if the two booleans are always different, false otherwise\n\t\t\t\t */\n\t\t\t\tconst isAlwaysDifferent = (a, b) =>\n\t\t\t\t\t(a === true && b === false) || (a === false && b === true);\n\n\t\t\t\tconst handleTemplateStringCompare = (left, right, res, eql) => {\n\t\t\t\t\tconst getPrefix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (const p of parts) {\n\t\t\t\t\t\t\tconst v = p.asString();\n\t\t\t\t\t\t\tif (v !== undefined) value += v;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst getSuffix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tconst v = parts[i].asString();\n\t\t\t\t\t\t\tif (v !== undefined) value = v + value;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst leftPrefix = getPrefix(left.parts);\n\t\t\t\t\tconst rightPrefix = getPrefix(right.parts);\n\t\t\t\t\tconst leftSuffix = getSuffix(left.parts);\n\t\t\t\t\tconst rightSuffix = getSuffix(right.parts);\n\t\t\t\t\tconst lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n\t\t\t\t\tconst lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\t\t\t\t\tconst prefixMismatch =\n\t\t\t\t\t\tlenPrefix > 0 &&\n\t\t\t\t\t\tleftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix);\n\t\t\t\t\tconst suffixMismatch =\n\t\t\t\t\t\tlenSuffix > 0 &&\n\t\t\t\t\t\tleftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix);\n\t\t\t\t\tif (prefixMismatch || suffixMismatch) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Helper function to handle BinaryExpressions using strict equality comparisons (e.g. \"===\" and \"!==\").\n\t\t\t\t * @param {boolean} eql true for \"===\" and false for \"!==\"\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleStrictEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() === right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst leftPrimitive = left.isPrimitiveType();\n\t\t\t\t\tconst rightPrimitive = right.isPrimitiveType();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Primitive !== Object or\n\t\t\t\t\t\t// compile-time object types are never equal to something at runtime\n\t\t\t\t\t\t(leftPrimitive === false &&\n\t\t\t\t\t\t\t(leftConst || rightPrimitive === true)) ||\n\t\t\t\t\t\t(rightPrimitive === false &&\n\t\t\t\t\t\t\t(rightConst || leftPrimitive === true)) ||\n\t\t\t\t\t\t// Different nullish or boolish status also means not equal\n\t\t\t\t\t\tisAlwaysDifferent(\n\t\t\t\t\t\t\t/** @type {boolean} */ (left.asBool()),\n\t\t\t\t\t\t\t/** @type {boolean} */ (right.asBool())\n\t\t\t\t\t\t) ||\n\t\t\t\t\t\tisAlwaysDifferent(\n\t\t\t\t\t\t\t/** @type {boolean} */ (left.asNullish()),\n\t\t\t\t\t\t\t/** @type {boolean} */ (right.asNullish())\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Helper function to handle BinaryExpressions using abstract equality comparisons (e.g. \"==\" and \"!=\").\n\t\t\t\t * @param {boolean} eql true for \"==\" and false for \"!=\"\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleAbstractEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() == right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"+\") {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tif (left.isString()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"leftPrefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isBigInt()) {\n\t\t\t\t\t\tif (right.isBigInt()) {\n\t\t\t\t\t\t\tres.setBigInt(left.bigint + right.bigint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixRight\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (left.couldHaveSideEffects() || right.couldHaveSideEffects())\n\t\t\t\t\t\tres.setSideEffects();\n\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\treturn res;\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l - r);\n\t\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l * r);\n\t\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l / r);\n\t\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ** r);\n\t\t\t\t} else if (expr.operator === \"===\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"==\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"!==\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"!=\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l & r);\n\t\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l | r);\n\t\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ^ r);\n\t\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >>> r);\n\t\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >> r);\n\t\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l << r);\n\t\t\t\t} else if (expr.operator === \"<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l < r);\n\t\t\t\t} else if (expr.operator === \">\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l > r);\n\t\t\t\t} else if (expr.operator === \"<=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l <= r);\n\t\t\t\t} else if (expr.operator === \">=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >= r);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"UnaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {UnaryExpression} */ (_expr);\n\n\t\t\t\t/**\n\t\t\t\t * Evaluates a UnaryExpression if and only if it is a basic const operator (e.g. +a, -a, ~a).\n\t\t\t\t *\n\t\t\t\t * @template T\n\t\t\t\t * @param {(operand: T) => boolean | number | BigInt | string} operandHandler handler for the operand\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleConstOperation = operandHandler => {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (!argument.isCompileTimeValue()) return;\n\t\t\t\t\tconst result = operandHandler(argument.asCompileTimeValue());\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\targument.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\t\tswitch (expr.argument.type) {\n\t\t\t\t\t\tcase \"Identifier\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.name,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MetaProperty\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\tgetRootName(expr.argument),\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MemberExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"ChainExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.expression,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"FunctionExpression\": {\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (arg.isUnknown()) return;\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isWrapped()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setSideEffects()\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isUndefined()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"undefined\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBigInt()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"bigint\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isArray()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setSideEffects(arg.couldHaveSideEffects())\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tconst bool = argument.asBool();\n\t\t\t\t\tif (typeof bool !== \"boolean\") return;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!bool)\n\t\t\t\t\t\t.setSideEffects(argument.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\t\treturn handleConstOperation(v => ~v);\n\t\t\t\t} else if (expr.operator === \"+\") {\n\t\t\t\t\treturn handleConstOperation(v => +v);\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation(v => -v);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n\t\t\tif (/** @type {Identifier} */ (expr).name === \"undefined\") {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setUndefined()\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\t/**\n\t\t * @param {string} exprType expression type name\n\t\t * @param {function(Expression): GetInfoResult | undefined} getInfo get info\n\t\t * @returns {void}\n\t\t */\n\t\tconst tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n\t\t\t/** @type {Expression | undefined} */\n\t\t\tlet cachedExpression = undefined;\n\t\t\t/** @type {GetInfoResult | undefined} */\n\t\t\tlet cachedInfo = undefined;\n\t\t\tthis.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n\t\t\t\tconst expression = /** @type {MemberExpression} */ (expr);\n\n\t\t\t\tconst info = getInfo(expr);\n\t\t\t\tif (info !== undefined) {\n\t\t\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tcachedExpression = expression;\n\t\t\t\t\t\t\tcachedInfo = info;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.hooks.evaluate\n\t\t\t\t.for(exprType)\n\t\t\t\t.tap({ name: \"JavascriptParser\", stage: 100 }, expr => {\n\t\t\t\t\tconst info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\t\t\t\t\tif (info !== undefined) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setIdentifier(\n\t\t\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\t\t\tinfo.rootInfo,\n\t\t\t\t\t\t\t\tinfo.getMembers,\n\t\t\t\t\t\t\t\tinfo.getMembersOptionals,\n\t\t\t\t\t\t\t\tinfo.getMemberRanges\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.hooks.finish.tap(\"JavascriptParser\", () => {\n\t\t\t\t// Cleanup for GC\n\t\t\t\tcachedExpression = cachedInfo = undefined;\n\t\t\t});\n\t\t};\n\t\ttapEvaluateWithVariableInfo(\"Identifier\", expr => {\n\t\t\tconst info = this.getVariableInfo(/** @type {Identifier} */ (expr).name);\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => [],\n\t\t\t\t\tgetMemberRanges: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n\t\t\tconst info = this.getVariableInfo(\"this\");\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => [],\n\t\t\t\t\tgetMemberRanges: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n\t\t\tconst metaProperty = /** @type {MetaProperty} */ (expr);\n\n\t\t\treturn this.callHooksForName(\n\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\tgetRootName(expr),\n\t\t\t\tmetaProperty\n\t\t\t);\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"MemberExpression\", expr =>\n\t\t\tthis.getMemberExpressionInfo(\n\t\t\t\t/** @type {MemberExpression} */ (expr),\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t)\n\t\t);\n\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {CallExpression} */ (_expr);\n\t\t\tif (\n\t\t\t\texpr.callee.type === \"MemberExpression\" &&\n\t\t\t\texpr.callee.property.type ===\n\t\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t) {\n\t\t\t\t// type Super also possible here\n\t\t\t\tconst param = this.evaluateExpression(\n\t\t\t\t\t/** @type {Expression} */ (expr.callee.object)\n\t\t\t\t);\n\t\t\t\tconst property =\n\t\t\t\t\texpr.callee.property.type === \"Literal\"\n\t\t\t\t\t\t? `${expr.callee.property.value}`\n\t\t\t\t\t\t: expr.callee.property.name;\n\t\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr, param);\n\t\t\t\t}\n\t\t\t} else if (expr.callee.type === \"Identifier\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateCallExpression,\n\t\t\t\t\texpr.callee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"indexOf\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length === 0) return;\n\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\tconst arg1Eval = this.evaluateExpression(arg1);\n\t\t\t\tif (!arg1Eval.isString()) return;\n\t\t\t\tconst arg1Value = arg1Eval.string;\n\n\t\t\t\tlet result;\n\t\t\t\tif (arg2) {\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst arg2Eval = this.evaluateExpression(arg2);\n\t\t\t\t\tif (!arg2Eval.isNumber()) return;\n\t\t\t\t\tresult = param.string.indexOf(arg1Value, arg2Eval.number);\n\t\t\t\t} else {\n\t\t\t\t\tresult = param.string.indexOf(arg1Value);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNumber(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\tconst arg1Value = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\tconst arg2Value = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1Value, arg2Value))\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\", \"slice\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {\"cooked\" | \"raw\"} kind kind of values to get\n\t\t * @param {TemplateLiteral} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst quasis = [];\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof exprAsString === \"string\" &&\n\t\t\t\t\t\t!expr.couldHaveSideEffects()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(/** @type {Range} */ (quasiExpr.range))\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TemplateLiteral\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TemplateLiteral} */ (_node);\n\n\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\t\tif (parts.length === 1) {\n\t\t\t\t\treturn parts[0].setRange(/** @type {Range} */ (node.range));\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t\t.setRange(/** @type {Range} */ (node.range));\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TaggedTemplateExpression\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TaggedTemplateExpression} */ (_node);\n\t\t\t\tconst tag = this.evaluateExpression(node.tag);\n\n\t\t\t\tif (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n\t\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\n\t\t\t\t\t\t\"raw\",\n\t\t\t\t\t\tnode.quasi\n\t\t\t\t\t);\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (node.range));\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tconst innerExpressions = [];\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst arg = expr.arguments[i];\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return;\n\t\t\t\t\tconst argExpr = this.evaluateExpression(arg);\n\t\t\t\t\tif (\n\t\t\t\t\t\thasUnknownParams ||\n\t\t\t\t\t\t(!argExpr.isString() && !argExpr.isNumber())\n\t\t\t\t\t) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tinnerExpressions.push(argExpr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = /** @type {Range} */ ([\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t]);\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\targExpr.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\tconst inner =\n\t\t\t\t\t\tparam.isWrapped() && param.wrappedInnerExpressions\n\t\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\tconst inner = param.wrappedInnerExpressions\n\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\tparam.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ConditionalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ConditionalExpression} */ (_expr);\n\n\t\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\t\tconst conditionValue = condition.asBool();\n\t\t\t\tlet res;\n\t\t\t\tif (conditionValue === undefined) {\n\t\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\t\tres.setOptions(\n\t\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (consequent.options)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t\t}\n\t\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\t\tres.addOptions(\n\t\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (alternate.options)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t\t);\n\t\t\t\t\tif (condition.couldHaveSideEffects()) res.setSideEffects();\n\t\t\t\t}\n\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\treturn res;\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ArrayExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ArrayExpression} */ (_expr);\n\n\t\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\telement !== null &&\n\t\t\t\t\t\telement.type !== \"SpreadElement\" &&\n\t\t\t\t\t\tthis.evaluateExpression(element)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif (!items.every(Boolean)) return;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setItems(items)\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ChainExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ChainExpression} */ (_expr);\n\t\t\t\t/** @type {Expression[]} */\n\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t/** @type {Expression|Super} */\n\t\t\t\tlet next = expr.expression;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t) {\n\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {Expression} */ (next.object)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {Expression} */ (next.callee)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (optionalExpressionsStack.length > 0) {\n\t\t\t\t\tconst expression =\n\t\t\t\t\t\t/** @type {Expression} */\n\t\t\t\t\t\t(optionalExpressionsStack.pop());\n\t\t\t\t\tconst evaluated = this.evaluateExpression(expression);\n\n\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\treturn evaluated.setRange(/** @type {Range} */ (_expr.range));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {Expression} node node\n\t * @returns {Set<string>|undefined} destructured identifiers\n\t */\n\tdestructuringAssignmentPropertiesFor(node) {\n\t\tif (!this.destructuringAssignmentProperties) return undefined;\n\t\treturn this.destructuringAssignmentProperties.get(node);\n\t}\n\n\t/**\n\t * @param {Expression} expr expression\n\t * @returns {string | VariableInfoInterface | undefined} identifier\n\t */\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpression | ClassDeclaration} classy a class node\n\t * @returns {void}\n\t */\n\twalkClass(classy) {\n\t\tif (classy.superClass) {\n\t\t\tif (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n\t\t\t\tthis.walkExpression(classy.superClass);\n\t\t\t}\n\t\t}\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst scopeParams = [];\n\t\t\t// Add class name in scope for recursive calls\n\t\t\tif (classy.id) {\n\t\t\t\tscopeParams.push(classy.id);\n\t\t\t}\n\t\t\tthis.inClassScope(true, scopeParams, () => {\n\t\t\t\tfor (const classElement of /** @type {TODO} */ (classy.body.body)) {\n\t\t\t\t\tif (!this.hooks.classBodyElement.call(classElement, classy)) {\n\t\t\t\t\t\tif (classElement.computed && classElement.key) {\n\t\t\t\t\t\t\tthis.walkExpression(classElement.key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (classElement.value) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!this.hooks.classBodyValue.call(\n\t\t\t\t\t\t\t\t\tclassElement.value,\n\t\t\t\t\t\t\t\t\tclassElement,\n\t\t\t\t\t\t\t\t\tclassy\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\t\tthis.walkExpression(classElement.value);\n\t\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (classElement.type === \"StaticBlock\") {\n\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\tthis.walkBlockStatement(classElement);\n\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Pre walking iterates the scope for variable declarations\n\t *\n\t * @param {(Statement | ModuleDeclaration)[]} statements statements\n\t */\n\tpreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.preWalkStatement(statement);\n\t\t}\n\t}\n\n\t/**\n\t * Block pre walking iterates the scope for block variable declarations\n\t *\n\t * @param {(Statement | ModuleDeclaration)[]} statements statements\n\t */\n\tblockPreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPreWalkStatement(statement);\n\t\t}\n\t}\n\n\t/**\n\t * Walking iterates the statements and expressions and processes them\n\t *\n\t * @param {(Statement | ModuleDeclaration)[]} statements statements\n\t */\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\t/**\n\t * Walking iterates the statements and expressions and processes them\n\t *\n\t * @param {Statement | ModuleDeclaration} statement statement\n\t */\n\tpreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.preStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.preWalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.preWalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.preWalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.preWalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.preWalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.preWalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.preWalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.preWalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.preWalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.preWalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.preWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.preWalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.preWalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\t/**\n\t * @param {Statement | ModuleDeclaration} statement statement\n\t */\n\tblockPreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.blockPreStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.blockPreWalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.blockPreWalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPreWalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPreWalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPreWalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.blockPreWalkExpressionStatement(statement);\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\t/**\n\t * @param {Statement | ModuleDeclaration} statement statement\n\t */\n\twalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.statement.call(statement) !== undefined) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\t/**\n\t * Walks a statements that is nested within a parent statement\n\t * and can potentially be a non-block statement.\n\t * This enforces the nested statement to never be in ASI position.\n\t *\n\t * @param {Statement} statement the nested statement\n\t */\n\twalkNestedStatement(statement) {\n\t\tthis.prevStatement = undefined;\n\t\tthis.walkStatement(statement);\n\t}\n\n\t// Real Statements\n\t/**\n\t * @param {BlockStatement} statement block statement\n\t */\n\tpreWalkBlockStatement(statement) {\n\t\tthis.preWalkStatements(statement.body);\n\t}\n\n\t/**\n\t * @param {BlockStatement} statement block statement\n\t */\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatements(body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\t/**\n\t * @param {ExpressionStatement} statement expression statement\n\t */\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\t/**\n\t * @param {IfStatement} statement if statement\n\t */\n\tpreWalkIfStatement(statement) {\n\t\tthis.preWalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.preWalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IfStatement} statement if statement\n\t */\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {LabeledStatement} statement with statement\n\t */\n\tpreWalkLabeledStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {LabeledStatement} statement with statement\n\t */\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {WithStatement} statement with statement\n\t */\n\tpreWalkWithStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {WithStatement} statement with statement\n\t */\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {SwitchStatement} statement switch statement\n\t */\n\tpreWalkSwitchStatement(statement) {\n\t\tthis.preWalkSwitchCases(statement.cases);\n\t}\n\n\t/**\n\t * @param {SwitchStatement} statement switch statement\n\t */\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\t/**\n\t * @param {ReturnStatement | ThrowStatement} statement return or throw statement\n\t */\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\t/**\n\t * @param {ReturnStatement} statement return statement\n\t */\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\t/**\n\t * @param {ThrowStatement} statement return statement\n\t */\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\t/**\n\t * @param {TryStatement} statement try statement\n\t */\n\tpreWalkTryStatement(statement) {\n\t\tthis.preWalkStatement(statement.block);\n\t\tif (statement.handler) this.preWalkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.preWalkStatement(statement.finalizer);\n\t}\n\n\t/**\n\t * @param {TryStatement} statement try statement\n\t */\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\t/**\n\t * @param {WhileStatement} statement while statement\n\t */\n\tpreWalkWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {WhileStatement} statement while statement\n\t */\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {DoWhileStatement} statement do while statement\n\t */\n\tpreWalkDoWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {DoWhileStatement} statement do while statement\n\t */\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkNestedStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\t/**\n\t * @param {ForStatement} statement for statement\n\t */\n\tpreWalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.preWalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {ForStatement} statement for statement\n\t */\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.prevStatement = undefined;\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {ForInStatement} statement for statement\n\t */\n\tpreWalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {ForInStatement} statement for statement\n\t */\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForOfStatement(statement) {\n\t\tif (statement.await && this.scope.topLevelScope === true) {\n\t\t\tthis.hooks.topLevelAwait.call(statement);\n\t\t}\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {ForOfStatement} statement for statement\n\t */\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {FunctionDeclaration} statement function declaration\n\t */\n\tpreWalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {FunctionDeclaration} statement function declaration\n\t */\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {ExpressionStatement} statement expression statement\n\t */\n\tblockPreWalkExpressionStatement(statement) {\n\t\tconst expression = statement.expression;\n\t\tswitch (expression.type) {\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.preWalkAssignmentExpression(expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {AssignmentExpression} expression assignment expression\n\t */\n\tpreWalkAssignmentExpression(expression) {\n\t\tif (\n\t\t\texpression.left.type !== \"ObjectPattern\" ||\n\t\t\t!this.destructuringAssignmentProperties\n\t\t)\n\t\t\treturn;\n\t\tconst keys = this._preWalkObjectPattern(expression.left);\n\t\tif (!keys) return;\n\n\t\t// check multiple assignments\n\t\tif (this.destructuringAssignmentProperties.has(expression)) {\n\t\t\tconst set = this.destructuringAssignmentProperties.get(expression);\n\t\t\tthis.destructuringAssignmentProperties.delete(expression);\n\t\t\tfor (const id of set) keys.add(id);\n\t\t}\n\n\t\tthis.destructuringAssignmentProperties.set(\n\t\t\texpression.right.type === \"AwaitExpression\"\n\t\t\t\t? expression.right.argument\n\t\t\t\t: expression.right,\n\t\t\tkeys\n\t\t);\n\n\t\tif (expression.right.type === \"AssignmentExpression\") {\n\t\t\tthis.preWalkAssignmentExpression(expression.right);\n\t\t}\n\t}\n\n\tblockPreWalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(statement, source, \"default\", name)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(\n\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\tspecifier.imported.name || specifier.imported.value,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tif (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPreWalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.declaration);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name || specifier.exported.value;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ExportNamedDeclaration} statement the statement\n\t */\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPreWalkExportDefaultDeclaration(statement) {\n\t\tconst prev = this.prevStatement;\n\t\tthis.preWalkStatement(statement.declaration);\n\t\tthis.prevStatement = prev;\n\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\",\n\t\t\t\tundefined\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (\n\t\t\t\tstatement.declaration.type === \"FunctionDeclaration\" ||\n\t\t\t\tstatement.declaration.type === \"ClassDeclaration\"\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\",\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tconst name = statement.exported ? statement.exported.name : null;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t */\n\tpreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t */\n\tblockPreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._preWalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t * @param {TODO} hookMap map of hooks\n\t */\n\t_preWalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.preWalkVariableDeclarator(declarator);\n\t\t\t\t\tif (!this.hooks.preDeclarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectPattern} objectPattern object pattern\n\t * @returns {Set<string> | undefined} set of names or undefined if not all keys are identifiers\n\t */\n\t_preWalkObjectPattern(objectPattern) {\n\t\tconst ids = new Set();\n\t\tconst properties = objectPattern.properties;\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tif (property.type !== \"Property\") return;\n\t\t\tconst key = property.key;\n\t\t\tif (key.type === \"Identifier\") {\n\t\t\t\tids.add(key.name);\n\t\t\t} else {\n\t\t\t\tconst id = this.evaluateExpression(key);\n\t\t\t\tconst str = id.asString();\n\t\t\t\tif (str) {\n\t\t\t\t\tids.add(str);\n\t\t\t\t} else {\n\t\t\t\t\t// could not evaluate key\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ids;\n\t}\n\n\t/**\n\t * @param {VariableDeclarator} declarator variable declarator\n\t */\n\tpreWalkVariableDeclarator(declarator) {\n\t\tif (\n\t\t\t!declarator.init ||\n\t\t\tdeclarator.id.type !== \"ObjectPattern\" ||\n\t\t\t!this.destructuringAssignmentProperties\n\t\t)\n\t\t\treturn;\n\t\tconst keys = this._preWalkObjectPattern(declarator.id);\n\n\t\tif (!keys) return;\n\t\tthis.destructuringAssignmentProperties.set(\n\t\t\tdeclarator.init.type === \"AwaitExpression\"\n\t\t\t\t? declarator.init.argument\n\t\t\t\t: declarator.init,\n\t\t\tkeys\n\t\t);\n\n\t\tif (declarator.init.type === \"AssignmentExpression\") {\n\t\t\tthis.preWalkAssignmentExpression(declarator.init);\n\t\t}\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t */\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.setVariable(declarator.id.name, renameIdentifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.hooks.declarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassDeclaration} statement class declaration\n\t */\n\tblockPreWalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassDeclaration} statement class declaration\n\t */\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\t/**\n\t * @param {SwitchCase[]} switchCases switch statement\n\t */\n\tpreWalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.preWalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {SwitchCase[]} switchCases switch statement\n\t */\n\twalkSwitchCases(switchCases) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst len = switchCases.length;\n\n\t\t\t// we need to pre walk all statements first since we can have invalid code\n\t\t\t// import A from \"module\";\n\t\t\t// switch(1) {\n\t\t\t//    case 1:\n\t\t\t//      console.log(A); // should fail at runtime\n\t\t\t//    case 2:\n\t\t\t//      const A = 1;\n\t\t\t// }\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\t\tthis.blockPreWalkStatements(switchCase.consequent);\n\t\t\t\t\tthis.prevStatement = prev;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.test) {\n\t\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t\t}\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {CatchClause} catchClause catch clause\n\t */\n\tpreWalkCatchClause(catchClause) {\n\t\tthis.preWalkStatement(catchClause.body);\n\t}\n\n\t/**\n\t * @param {CatchClause} catchClause catch clause\n\t */\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.defineVariable(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatement(catchClause.body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Pattern} pattern pattern\n\t */\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {AssignmentPattern} pattern assignment pattern\n\t */\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ArrayPattern} pattern array pattern\n\t */\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\t/**\n\t * @param {RestElement} pattern rest element\n\t */\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\t/**\n\t * @param {(Expression | SpreadElement | null)[]} expressions expressions\n\t */\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {TODO} expression expression\n\t */\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ChainExpression\":\n\t\t\t\tthis.walkChainExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportExpression\":\n\t\t\t\tthis.walkImportExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MetaProperty\":\n\t\t\t\tthis.walkMetaProperty(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {AwaitExpression} expression await expression\n\t */\n\twalkAwaitExpression(expression) {\n\t\tif (this.scope.topLevelScope === true)\n\t\t\tthis.hooks.topLevelAwait.call(expression);\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\t/**\n\t * @param {ArrayExpression} expression array expression\n\t */\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\t/**\n\t * @param {SpreadElement} expression spread element\n\t */\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectExpression} expression object expression\n\t */\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tthis.walkProperty(prop);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Property | SpreadElement} prop property or spread element\n\t */\n\twalkProperty(prop) {\n\t\tif (prop.type === \"SpreadElement\") {\n\t\t\tthis.walkExpression(prop.argument);\n\t\t\treturn;\n\t\t}\n\t\tif (prop.computed) {\n\t\t\tthis.walkExpression(prop.key);\n\t\t}\n\t\tif (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n\t\t\tthis.scope.inShorthand = prop.value.name;\n\t\t\tthis.walkIdentifier(prop.value);\n\t\t\tthis.scope.inShorthand = false;\n\t\t} else {\n\t\t\tthis.walkExpression(prop.value);\n\t\t}\n\t}\n\n\t/**\n\t * @param {FunctionExpression} expression arrow function expression\n\t */\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = [...expression.params];\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {ArrowFunctionExpression} expression arrow function expression\n\t */\n\twalkArrowFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {SequenceExpression} expression the sequence\n\t */\n\twalkSequenceExpression(expression) {\n\t\tif (!expression.expressions) return;\n\t\t// We treat sequence expressions like statements when they are one statement level\n\t\t// This has some benefits for optimizations that only work on statement level\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (\n\t\t\tcurrentStatement === expression ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expression)\n\t\t) {\n\t\t\tconst old = this.statementPath.pop();\n\t\t\tfor (const expr of expression.expressions) {\n\t\t\t\tthis.statementPath.push(expr);\n\t\t\t\tthis.walkExpression(expr);\n\t\t\t\tthis.statementPath.pop();\n\t\t\t}\n\t\t\tthis.statementPath.push(old);\n\t\t} else {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\t/**\n\t * @param {UpdateExpression} expression the update expression\n\t */\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\t/**\n\t * @param {UnaryExpression} expression the unary expression\n\t */\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\tthis.hooks.typeof,\n\t\t\t\texpression.argument,\n\t\t\t\texpression\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tif (expression.argument.type === \"ChainExpression\") {\n\t\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\t\tthis.hooks.typeof,\n\t\t\t\t\texpression.argument.expression,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\t/**\n\t * @param {LogicalExpression | BinaryExpression} expression the expression\n\t */\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\t/**\n\t * @param {BinaryExpression} expression the binary expression\n\t */\n\twalkBinaryExpression(expression) {\n\t\tif (this.hooks.binaryExpression.call(expression) === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {LogicalExpression} expression the logical expression\n\t */\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {AssignmentExpression} expression assignment expression\n\t */\n\twalkAssignmentExpression(expression) {\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\texpression.right\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// renaming \"a = b;\"\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\texpression.right\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.setVariable(\n\t\t\t\t\t\t\texpression.left.name,\n\t\t\t\t\t\t\ttypeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t\t: renameIdentifier\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (expression.left.type.endsWith(\"Pattern\")) {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.walkPattern(expression.left);\n\t\t} else if (expression.left.type === \"MemberExpression\") {\n\t\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\t\texpression.left,\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t);\n\t\t\tif (exprName) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.assignMemberChain,\n\t\t\t\t\t\texprName.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprName.getMembers()\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t} else {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ConditionalExpression} expression conditional expression\n\t */\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {NewExpression} expression new expression\n\t */\n\twalkNewExpression(expression) {\n\t\tconst result = this.callHooksForExpression(\n\t\t\tthis.hooks.new,\n\t\t\texpression.callee,\n\t\t\texpression\n\t\t);\n\t\tif (result === true) return;\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\t/**\n\t * @param {YieldExpression} expression yield expression\n\t */\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TemplateLiteral} expression template literal\n\t */\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TaggedTemplateExpression} expression tagged template expression\n\t */\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.scope.inTaggedTemplateTag = true;\n\t\t\tthis.walkExpression(expression.tag);\n\t\t\tthis.scope.inTaggedTemplateTag = false;\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpression} expression the class expression\n\t */\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t/**\n\t * @param {ChainExpression} expression expression\n\t */\n\twalkChainExpression(expression) {\n\t\tconst result = this.hooks.optionalChaining.call(expression);\n\n\t\tif (result === undefined) {\n\t\t\tif (expression.expression.type === \"CallExpression\") {\n\t\t\t\tthis.walkCallExpression(expression.expression);\n\t\t\t} else {\n\t\t\t\tthis.walkMemberExpression(expression.expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst getVarInfo = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\targOrThis\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\targOrThis\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn typeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t: renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst { params, type } = functionExpression;\n\t\tconst arrow = type === \"ArrowFunctionExpression\";\n\t\tconst renameThis = currentThis ? getVarInfo(currentThis) : null;\n\t\tconst varInfoForArgs = options.map(getVarInfo);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n\t\tconst scopeParams = params.filter(\n\t\t\t(identifier, idx) => !varInfoForArgs[idx]\n\t\t);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis && !arrow) {\n\t\t\t\tthis.setVariable(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < varInfoForArgs.length; i++) {\n\t\t\t\tconst varInfo = varInfoForArgs[i];\n\t\t\t\tif (!varInfo) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.setVariable(params[i].name, varInfo);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(functionExpression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {ImportExpression} expression import expression\n\t */\n\twalkImportExpression(expression) {\n\t\tlet result = this.hooks.importCall.call(expression);\n\t\tif (result === true) return;\n\n\t\tthis.walkExpression(expression.source);\n\t}\n\n\twalkCallExpression(expression) {\n\t\tconst isSimpleFunction = fn => {\n\t\t\treturn fn.params.every(p => p.type === \"Identifier\");\n\t\t};\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type.endsWith(\"FunctionExpression\") &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0 &&\n\t\t\tisSimpleFunction(expression.callee.object)\n\t\t) {\n\t\t\t// (function(…) { }.call/bind(?, …))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (\n\t\t\texpression.callee.type.endsWith(\"FunctionExpression\") &&\n\t\t\tisSimpleFunction(expression.callee)\n\t\t) {\n\t\t\t// (function(…) { }(…))\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else {\n\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\t\t\texpression.callee,\n\t\t\t\t\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION\n\t\t\t\t);\n\t\t\t\tif (exprInfo && exprInfo.type === \"call\") {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.callMemberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers(),\n\t\t\t\t\t\texprInfo.getMemberRanges()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.callMemberChain,\n\t\t\t\t\tcallee.rootInfo,\n\t\t\t\t\texpression,\n\t\t\t\t\tcallee.getMembers(),\n\t\t\t\t\tcallee.getMembersOptionals\n\t\t\t\t\t\t? callee.getMembersOptionals()\n\t\t\t\t\t\t: callee.getMembers().map(() => false),\n\t\t\t\t\tcallee.getMemberRanges ? callee.getMemberRanges() : []\n\t\t\t\t);\n\t\t\t\tif (result1 === true) return;\n\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.call,\n\t\t\t\t\tcallee.identifier,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result2 === true) return;\n\t\t\t}\n\n\t\t\tif (expression.callee) {\n\t\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\t\t// because of call context we need to walk the call context as expression\n\t\t\t\t\tthis.walkExpression(expression.callee.object);\n\t\t\t\t\tif (expression.callee.computed === true)\n\t\t\t\t\t\tthis.walkExpression(expression.callee.property);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(expression.callee);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpression} expression member expression\n\t */\n\twalkMemberExpression(expression) {\n\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_ALL\n\t\t);\n\t\tif (exprInfo) {\n\t\t\tswitch (exprInfo.type) {\n\t\t\t\tcase \"expression\": {\n\t\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t\tif (result1 === true) return;\n\t\t\t\t\tconst members = exprInfo.getMembers();\n\t\t\t\t\tconst membersOptionals = exprInfo.getMembersOptionals();\n\t\t\t\t\tconst memberRanges = exprInfo.getMemberRanges();\n\t\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expressionMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\tmembers,\n\t\t\t\t\t\tmembersOptionals,\n\t\t\t\t\t\tmemberRanges\n\t\t\t\t\t);\n\t\t\t\t\tif (result2 === true) return;\n\t\t\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\tmembers.slice(),\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\t\t\tthis.hooks.unhandledExpressionMemberChain,\n\t\t\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\tmembers\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase \"call\": {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.memberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers(),\n\t\t\t\t\t\texprInfo.getMemberRanges()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t// Fast skip over the member chain as we already called memberChainOfCallMemberChain\n\t\t\t\t\t// and call computed property are literals anyway\n\t\t\t\t\tthis.walkExpression(exprInfo.call);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkMemberExpressionWithExpressionName(\n\t\texpression,\n\t\tname,\n\t\trootInfo,\n\t\tmembers,\n\t\tonUnhandled\n\t) {\n\t\tif (expression.object.type === \"MemberExpression\") {\n\t\t\t// optimize the case where expression.object is a MemberExpression too.\n\t\t\t// we can keep info here when calling walkMemberExpression directly\n\t\t\tconst property =\n\t\t\t\texpression.property.name || `${expression.property.value}`;\n\t\t\tname = name.slice(0, -property.length - 1);\n\t\t\tmembers.pop();\n\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\tthis.hooks.expression,\n\t\t\t\tname,\n\t\t\t\texpression.object\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\texpression.object,\n\t\t\t\tname,\n\t\t\t\trootInfo,\n\t\t\t\tmembers,\n\t\t\t\tonUnhandled\n\t\t\t);\n\t\t} else if (!onUnhandled || !onUnhandled()) {\n\t\t\tthis.walkExpression(expression.object);\n\t\t}\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\t/**\n\t * @param {ThisExpression} expression this expression\n\t */\n\twalkThisExpression(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, \"this\", expression);\n\t}\n\n\t/**\n\t * @param {Identifier} expression identifier\n\t */\n\twalkIdentifier(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, expression.name, expression);\n\t}\n\n\t/**\n\t * @param {MetaProperty} metaProperty meta property\n\t */\n\twalkMetaProperty(metaProperty) {\n\t\tthis.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n\t}\n\n\tcallHooksForExpression(hookMap, expr, ...args) {\n\t\treturn this.callHooksForExpressionWithFallback(\n\t\t\thookMap,\n\t\t\texpr,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {MemberExpression} expr expression info\n\t * @param {(function(string, string | ScopeInfo | VariableInfo, function(): string[]): any) | undefined} fallback callback when variable in not handled by hooks\n\t * @param {(function(string): any) | undefined} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForExpressionWithFallback(\n\t\thookMap,\n\t\texpr,\n\t\tfallback,\n\t\tdefined,\n\t\t...args\n\t) {\n\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\texpr,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t\tif (exprName !== undefined) {\n\t\t\tconst members = exprName.getMembers();\n\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\thookMap,\n\t\t\t\tmembers.length === 0 ? exprName.rootInfo : exprName.name,\n\t\t\t\tfallback &&\n\t\t\t\t\t(name => fallback(name, exprName.rootInfo, exprName.getMembers)),\n\t\t\t\tdefined && (() => defined(exprName.name)),\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForName(hookMap, name, ...args) {\n\t\treturn this.callHooksForNameWithFallback(\n\t\t\thookMap,\n\t\t\tname,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param  {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForInfo(hookMap, info, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tinfo,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n\t * @param {(function(): any) | undefined} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {\n\t\tlet name;\n\t\tif (typeof info === \"string\") {\n\t\t\tname = info;\n\t\t} else {\n\t\t\tif (!(info instanceof VariableInfo)) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tconst hook = hookMap.get(tagInfo.tag);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tthis.currentTagData = tagInfo.data;\n\t\t\t\t\tconst result = hook.call(...args);\n\t\t\t\t\tthis.currentTagData = undefined;\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t}\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t\tif (info.freeName === true) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = info.freeName;\n\t\t}\n\t\tconst hook = hookMap.get(name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(...args);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t\tif (fallback !== undefined) {\n\t\t\treturn fallback(name);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n\t * @param {(function(): any) | undefined} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tthis.getVariableInfo(name),\n\t\t\tfallback,\n\t\t\tdefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tthis.undefineVariable(\"this\");\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {boolean} hasThis true, when this is defined\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinClassScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {boolean} hasThis true, when this is defined\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {Array<Directive | Statement | ModuleDeclaration>} statements statements\n\t */\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (\n\t\t\tisLiteral &&\n\t\t\t/** @type {Literal} */\n\t\t\t(/** @type {ExpressionStatement} */ (statements[0]).expression).value ===\n\t\t\t\t\"use strict\"\n\t\t) {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (\n\t\t\tisLiteral &&\n\t\t\t/** @type {Literal} */\n\t\t\t(/** @type {ExpressionStatement} */ (statements[0]).expression).value ===\n\t\t\t\t\"use asm\"\n\t\t) {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tif (pattern.shorthand && pattern.value.type === \"Identifier\") {\n\t\t\t\t\tthis.scope.inShorthand = pattern.value.name;\n\t\t\t\t\tthis.enterIdentifier(pattern.value, onIdent);\n\t\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Identifier} pattern identifier pattern\n\t * @param {TODO} onIdent callback\n\t */\n\tenterIdentifier(pattern, onIdent) {\n\t\tif (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n\t\t\tonIdent(pattern.name, pattern);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectPattern} pattern object pattern\n\t * @param {TODO} onIdent callback\n\t */\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ArrayPattern} pattern object pattern\n\t * @param {TODO} onIdent callback\n\t */\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\t// TODO check on `null`?\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {RestElement} pattern object pattern\n\t * @param {TODO} onIdent callback\n\t */\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\t/**\n\t * @param {AssignmentPattern} pattern object pattern\n\t * @param {TODO} onIdent callback\n\t */\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\t/**\n\t * @param {TODO} expression expression node\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined && result !== null) {\n\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(/** @type {Range} */ (expression.range))\n\t\t\t.setExpression(expression);\n\t}\n\n\t/**\n\t * @param {Expression} expression expression\n\t * @returns {string} parsed string\n\t */\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | Buffer | PreparsedAst} source the source to parse\n\t * @param {ParserState} state the parser state\n\t * @returns {ParserState} the parser state\n\t */\n\tparse(source, state) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tconst semicolons = new Set();\n\t\tif (source === null) {\n\t\t\tthrow new Error(\"source must not be null\");\n\t\t}\n\t\tif (Buffer.isBuffer(source)) {\n\t\t\tsource = source.toString(\"utf-8\");\n\t\t}\n\t\tif (typeof source === \"object\") {\n\t\t\tast = /** @type {Program} */ (source);\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = JavascriptParser._parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments,\n\t\t\t\tonInsertedSemicolon: pos => semicolons.add(pos)\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tconst oldSemicolons = this.semicolons;\n\t\tconst oldStatementPath = this.statementPath;\n\t\tconst oldPrevStatement = this.prevStatement;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedMap()\n\t\t};\n\t\t/** @type {ParserState} */\n\t\tthis.state = state;\n\t\tthis.comments = comments;\n\t\tthis.semicolons = semicolons;\n\t\tthis.statementPath = [];\n\t\tthis.prevStatement = undefined;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.destructuringAssignmentProperties = new WeakMap();\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.preWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.blockPreWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.walkStatements(ast.body);\n\t\t\tthis.destructuringAssignmentProperties = undefined;\n\t\t}\n\t\tthis.hooks.finish.call(ast, comments);\n\t\tthis.scope = oldScope;\n\t\t/** @type {ParserState} */\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\tthis.semicolons = oldSemicolons;\n\t\tthis.statementPath = oldStatementPath;\n\t\tthis.prevStatement = oldPrevStatement;\n\t\treturn state;\n\t}\n\n\t/**\n\t * @param {string} source source code\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluate(source) {\n\t\tconst ast = JavascriptParser._parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\t/**\n\t * @param {Expression | Declaration | PrivateIdentifier | null | undefined} expr an expression\n\t * @param {number} commentsStartPos source position from which annotation comments are checked\n\t * @returns {boolean} true, when the expression is pure\n\t */\n\tisPure(expr, commentsStartPos) {\n\t\tif (!expr) return true;\n\t\tconst result = this.hooks.isPure\n\t\t\t.for(expr.type)\n\t\t\t.call(expr, commentsStartPos);\n\t\tif (typeof result === \"boolean\") return result;\n\t\tswitch (expr.type) {\n\t\t\t// TODO handle more cases\n\t\t\tcase \"ClassDeclaration\":\n\t\t\tcase \"ClassExpression\": {\n\t\t\t\tif (expr.body.type !== \"ClassBody\") return false;\n\t\t\t\tif (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst items =\n\t\t\t\t\t/** @type {TODO[]} */\n\t\t\t\t\t(expr.body.body);\n\t\t\t\treturn items.every(item => {\n\t\t\t\t\tif (\n\t\t\t\t\t\titem.computed &&\n\t\t\t\t\t\titem.key &&\n\t\t\t\t\t\t!this.isPure(item.key, item.range[0])\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\titem.static &&\n\t\t\t\t\t\titem.value &&\n\t\t\t\t\t\t!this.isPure(\n\t\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t\titem.key ? item.key.range[1] : item.range[0]\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.type === \"StaticBlock\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\tcase \"FunctionExpression\":\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\tcase \"ThisExpression\":\n\t\t\tcase \"Literal\":\n\t\t\tcase \"TemplateLiteral\":\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"PrivateIdentifier\":\n\t\t\t\treturn true;\n\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\treturn expr.declarations.every(decl =>\n\t\t\t\t\tthis.isPure(decl.init, /** @type {Range} */ (decl.range)[0])\n\t\t\t\t);\n\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.test, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\texpr.consequent,\n\t\t\t\t\t\t/** @type {Range} */ (expr.test.range)[1]\n\t\t\t\t\t) &&\n\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\texpr.alternate,\n\t\t\t\t\t\t/** @type {Range} */ (expr.consequent.range)[1]\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.left, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(expr.right, /** @type {Range} */ (expr.left.range)[1])\n\t\t\t\t);\n\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\treturn expr.expressions.every(expr => {\n\t\t\t\t\tconst pureFlag = this.isPure(expr, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = /** @type {Range} */ (expr.range)[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tconst pureFlag =\n\t\t\t\t\t/** @type {Range} */ (expr.range)[0] - commentsStartPos > 12 &&\n\t\t\t\t\tthis.getComments([\n\t\t\t\t\t\tcommentsStartPos,\n\t\t\t\t\t\t/** @type {Range} */ (expr.range)[0]\n\t\t\t\t\t]).some(\n\t\t\t\t\t\tcomment =>\n\t\t\t\t\t\t\tcomment.type === \"Block\" &&\n\t\t\t\t\t\t\t/^\\s*(#|@)__PURE__\\s*$/.test(comment.value)\n\t\t\t\t\t);\n\t\t\t\tif (!pureFlag) return false;\n\t\t\t\tcommentsStartPos = /** @type {Range} */ (expr.callee.range)[1];\n\t\t\t\treturn expr.arguments.every(arg => {\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return false;\n\t\t\t\t\tconst pureFlag = this.isPure(arg, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = /** @type {Range} */ (arg.range)[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst evaluated = this.evaluateExpression(expr);\n\t\treturn !evaluated.couldHaveSideEffects();\n\t}\n\n\t/**\n\t * @param {Range} range range\n\t * @returns {TODO[]} comments in the range\n\t */\n\tgetComments(range) {\n\t\tconst [rangeStart, rangeEnd] = range;\n\t\tconst compare = (comment, needle) => comment.range[0] - needle;\n\t\tlet idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n\t\tlet commentsInRange = [];\n\t\twhile (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n\t\t\tcommentsInRange.push(this.comments[idx]);\n\t\t\tidx++;\n\t\t}\n\n\t\treturn commentsInRange;\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n\t */\n\tisAsiPosition(pos) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (currentStatement === undefined) throw new Error(\"Not in statement\");\n\t\treturn (\n\t\t\t// Either asking directly for the end position of the current statement\n\t\t\t(currentStatement.range[1] === pos && this.semicolons.has(pos)) ||\n\t\t\t// Or asking for the start position of the current statement,\n\t\t\t// here we have to check multiple things\n\t\t\t(currentStatement.range[0] === pos &&\n\t\t\t\t// is there a previous statement which might be relevant?\n\t\t\t\tthis.prevStatement !== undefined &&\n\t\t\t\t// is the end position of the previous statement an ASI position?\n\t\t\t\tthis.semicolons.has(this.prevStatement.range[1]))\n\t\t);\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {void}\n\t */\n\tunsetAsiPosition(pos) {\n\t\tthis.semicolons.delete(pos);\n\t}\n\n\t/**\n\t * @param {Expression} expr expression\n\t * @returns {boolean} true, when the expression is a statement level expression\n\t */\n\tisStatementLevelExpression(expr) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\treturn (\n\t\t\texpr === currentStatement ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expr)\n\t\t);\n\t}\n\n\tgetTagData(name, tag) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info instanceof VariableInfo) {\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tif (tagInfo.tag === tag) return tagInfo.data;\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t}\n\t}\n\n\ttagVariable(name, tag, data) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t/** @type {VariableInfo} */\n\t\tlet newInfo;\n\t\tif (oldInfo === undefined) {\n\t\t\tnewInfo = new VariableInfo(this.scope, name, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t} else if (oldInfo instanceof VariableInfo) {\n\t\t\tnewInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: oldInfo.tagInfo\n\t\t\t});\n\t\t} else {\n\t\t\tnewInfo = new VariableInfo(oldInfo, true, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t}\n\t\tthis.scope.definitions.set(name, newInfo);\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t */\n\tdefineVariable(name) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t// Don't redefine variable in same scope to keep existing tags\n\t\tif (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope)\n\t\t\treturn;\n\t\tthis.scope.definitions.set(name, this.scope);\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t */\n\tundefineVariable(name) {\n\t\tthis.scope.definitions.delete(name);\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {boolean} true, when variable is defined\n\t */\n\tisVariableDefined(name) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info === undefined) return false;\n\t\tif (info instanceof VariableInfo) {\n\t\t\treturn info.freeName === true;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {ExportedVariableInfo} info for this variable\n\t */\n\tgetVariableInfo(name) {\n\t\tconst value = this.scope.definitions.get(name);\n\t\tif (value === undefined) {\n\t\t\treturn name;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @param {ExportedVariableInfo} variableInfo new info for this variable\n\t * @returns {void}\n\t */\n\tsetVariable(name, variableInfo) {\n\t\tif (typeof variableInfo === \"string\") {\n\t\t\tif (variableInfo === name) {\n\t\t\t\tthis.scope.definitions.delete(name);\n\t\t\t} else {\n\t\t\t\tthis.scope.definitions.set(\n\t\t\t\t\tname,\n\t\t\t\t\tnew VariableInfo(this.scope, variableInfo, undefined)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.scope.definitions.set(name, variableInfo);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TagInfo} tagInfo tag info\n\t * @returns {VariableInfo} variable info\n\t */\n\tevaluatedVariable(tagInfo) {\n\t\treturn new VariableInfo(this.scope, undefined, tagInfo);\n\t}\n\n\t/**\n\t * @param {Range} range range of the comment\n\t * @returns {TODO} TODO\n\t */\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\t/** @type {unknown[]} */\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tfor (let [key, val] of Object.entries(\n\t\t\t\t\t\tvm.runInNewContext(`(function(){return {${value}};})()`)\n\t\t\t\t\t)) {\n\t\t\t\t\t\tif (typeof val === \"object\" && val !== null) {\n\t\t\t\t\t\t\tif (val.constructor.name === \"RegExp\") val = new RegExp(val);\n\t\t\t\t\t\t\telse val = JSON.parse(JSON.stringify(val));\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions[key] = val;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconst newErr = new Error(String(e.message));\n\t\t\t\t\tnewErr.stack = String(e.stack);\n\t\t\t\t\tObject.assign(newErr, { comment });\n\t\t\t\t\terrors.push(newErr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\t/**\n\t * @param {MemberExpression} expression a member expression\n\t * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] }} member names (reverse order) and remaining object\n\t */\n\textractMemberExpressionChain(expression) {\n\t\t/** @type {AnyNode} */\n\t\tlet expr = expression;\n\t\tconst members = [];\n\t\tconst membersOptionals = [];\n\t\tconst memberRanges = [];\n\t\twhile (expr.type === \"MemberExpression\") {\n\t\t\tif (expr.computed) {\n\t\t\t\tif (expr.property.type !== \"Literal\") break;\n\t\t\t\tmembers.push(`${expr.property.value}`); // the literal\n\t\t\t\tmemberRanges.push(expr.object.range); // the range of the expression fragment before the literal\n\t\t\t} else {\n\t\t\t\tif (expr.property.type !== \"Identifier\") break;\n\t\t\t\tmembers.push(expr.property.name); // the identifier\n\t\t\t\tmemberRanges.push(expr.object.range); // the range of the expression fragment before the identifier\n\t\t\t}\n\t\t\tmembersOptionals.push(expr.optional);\n\t\t\texpr = expr.object;\n\t\t}\n\n\t\treturn {\n\t\t\tmembers,\n\t\t\tmembersOptionals,\n\t\t\tmemberRanges,\n\t\t\tobject: expr\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} varName variable name\n\t * @returns {{name: string, info: VariableInfo | string} | undefined} name of the free variable and variable info for that\n\t */\n\tgetFreeInfoFromVariable(varName) {\n\t\tconst info = this.getVariableInfo(varName);\n\t\tlet name;\n\t\tif (info instanceof VariableInfo) {\n\t\t\tname = info.freeName;\n\t\t\tif (typeof name !== \"string\") return undefined;\n\t\t} else if (typeof info !== \"string\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tname = info;\n\t\t}\n\t\treturn { info, name };\n\t}\n\n\t/** @typedef {{ type: \"call\", call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} CallExpressionInfo */\n\t/** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} ExpressionExpressionInfo */\n\n\t/**\n\t * @param {MemberExpression} expression a member expression\n\t * @param {number} allowedTypes which types should be returned, presented in bit mask\n\t * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n\t */\n\tgetMemberExpressionInfo(expression, allowedTypes) {\n\t\tconst { object, members, membersOptionals, memberRanges } =\n\t\t\tthis.extractMemberExpressionChain(expression);\n\t\tswitch (object.type) {\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tlet callee = object.callee;\n\t\t\t\tlet rootMembers = EMPTY_ARRAY;\n\t\t\t\tif (callee.type === \"MemberExpression\") {\n\t\t\t\t\t({ object: callee, members: rootMembers } =\n\t\t\t\t\t\tthis.extractMemberExpressionChain(callee));\n\t\t\t\t}\n\t\t\t\tconst rootName = getRootName(callee);\n\t\t\t\tif (!rootName) return undefined;\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\tconst calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"call\",\n\t\t\t\t\tcall: object,\n\t\t\t\t\tcalleeName,\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetCalleeMembers: memoize(() => rootMembers.reverse()),\n\t\t\t\t\tname: objectAndMembersToName(`${calleeName}()`, members),\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse()),\n\t\t\t\t\tgetMemberRanges: memoize(() => memberRanges.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"MetaProperty\":\n\t\t\tcase \"ThisExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tconst rootName = getRootName(object);\n\t\t\t\tif (!rootName) return undefined;\n\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"expression\",\n\t\t\t\t\tname: objectAndMembersToName(resolvedRoot, members),\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse()),\n\t\t\t\t\tgetMemberRanges: memoize(() => memberRanges.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpression} expression an expression\n\t * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]} | undefined} name info\n\t */\n\tgetNameForExpression(expression) {\n\t\treturn this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} code source code\n\t * @param {ParseOptions} options parsing options\n\t * @returns {Program} parsed ast\n\t */\n\tstatic _parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\t/** @type {AcornOptions} */\n\t\tconst parserOptions = {\n\t\t\t...defaultParserOptions,\n\t\t\tallowReturnOutsideFunction: type === \"script\",\n\t\t\t...options,\n\t\t\tsourceType: type === \"auto\" ? \"module\" : type\n\t\t};\n\n\t\t/** @type {AnyNode | undefined} */\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tif (!(\"allowReturnOutsideFunction\" in options)) {\n\t\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\t}\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\t// we use the error from first parse try\n\t\t\t\t// so nothing to do here\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn /** @type {Program} */ (ast);\n\t}\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION;\n"]},"metadata":{},"sourceType":"script"}