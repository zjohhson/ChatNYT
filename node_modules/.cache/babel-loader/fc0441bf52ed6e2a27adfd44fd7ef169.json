{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless.\nimport { AbstractPage } from \"./core.mjs\";\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\n\nexport class Page extends AbstractPage {\n  constructor(client, response, body, options) {\n    super(client, response, body, options);\n    this.data = body.data;\n    this.object = body.object;\n  }\n\n  getPaginatedItems() {\n    return this.data;\n  } // @deprecated Please use `nextPageInfo()` instead\n\n  /**\n   * This page represents a response that isn't actually paginated at the API level\n   * so there will never be any next page params.\n   */\n\n\n  nextPageParams() {\n    return null;\n  }\n\n  nextPageInfo() {\n    return null;\n  }\n\n}\nexport class CursorPage extends AbstractPage {\n  constructor(client, response, body, options) {\n    super(client, response, body, options);\n    this.data = body.data;\n  }\n\n  getPaginatedItems() {\n    return this.data;\n  } // @deprecated Please use `nextPageInfo()` instead\n\n\n  nextPageParams() {\n    const info = this.nextPageInfo();\n    if (!info) return null;\n    if ('params' in info) return info.params;\n    const params = Object.fromEntries(info.url.searchParams);\n    if (!Object.keys(params).length) return null;\n    return params;\n  }\n\n  nextPageInfo() {\n    if (!this.data?.length) {\n      return null;\n    }\n\n    const next = this.data[this.data.length - 1]?.id;\n    if (!next) return null;\n    return {\n      params: {\n        after: next\n      }\n    };\n  }\n\n}","map":{"version":3,"mappings":"AAAA;SAESA,oBAAkE;AAQ3E;;;;AAGA,OAAM,MAAOC,IAAP,SAA0BD,YAA1B,CAA4C;AAKhDE,cAAYC,MAAZ,EAA+BC,QAA/B,EAAmDC,IAAnD,EAA6EC,OAA7E,EAAyG;AACvG,UAAMH,MAAN,EAAcC,QAAd,EAAwBC,IAAxB,EAA8BC,OAA9B;AAEA,SAAKC,IAAL,GAAYF,IAAI,CAACE,IAAjB;AACA,SAAKC,MAAL,GAAcH,IAAI,CAACG,MAAnB;AACD;;AAEDC,mBAAiB;AACf,WAAO,KAAKF,IAAZ;AACD,GAd+C,CAgBhD;;AACA;;;;;;AAIAG,gBAAc;AACZ,WAAO,IAAP;AACD;;AAEDC,cAAY;AACV,WAAO,IAAP;AACD;;AA3B+C;AA8ClD,OAAM,MAAOC,UAAP,SACIZ,YADJ,CACsB;AAK1BE,cACEC,MADF,EAEEC,QAFF,EAGEC,IAHF,EAIEC,OAJF,EAI8B;AAE5B,UAAMH,MAAN,EAAcC,QAAd,EAAwBC,IAAxB,EAA8BC,OAA9B;AAEA,SAAKC,IAAL,GAAYF,IAAI,CAACE,IAAjB;AACD;;AAEDE,mBAAiB;AACf,WAAO,KAAKF,IAAZ;AACD,GAlByB,CAoB1B;;;AACAG,gBAAc;AACZ,UAAMG,IAAI,GAAG,KAAKF,YAAL,EAAb;AACA,QAAI,CAACE,IAAL,EAAW,OAAO,IAAP;AACX,QAAI,YAAYA,IAAhB,EAAsB,OAAOA,IAAI,CAACC,MAAZ;AACtB,UAAMA,MAAM,GAAGC,MAAM,CAACC,WAAP,CAAmBH,IAAI,CAACI,GAAL,CAASC,YAA5B,CAAf;AACA,QAAI,CAACH,MAAM,CAACI,IAAP,CAAYL,MAAZ,EAAoBM,MAAzB,EAAiC,OAAO,IAAP;AACjC,WAAON,MAAP;AACD;;AAEDH,cAAY;AACV,QAAI,CAAC,KAAKJ,IAAL,EAAWa,MAAhB,EAAwB;AACtB,aAAO,IAAP;AACD;;AAED,UAAMC,IAAI,GAAG,KAAKd,IAAL,CAAU,KAAKA,IAAL,CAAUa,MAAV,GAAmB,CAA7B,GAAiCE,EAA9C;AACA,QAAI,CAACD,IAAL,EAAW,OAAO,IAAP;AACX,WAAO;AAAEP,YAAM,EAAE;AAAES,aAAK,EAAEF;AAAT;AAAV,KAAP;AACD;;AAtCyB","names":["AbstractPage","Page","constructor","client","response","body","options","data","object","getPaginatedItems","nextPageParams","nextPageInfo","CursorPage","info","params","Object","fromEntries","url","searchParams","keys","length","next","id","after"],"sources":["/Users/zachjohnson/Desktop/React-Wordle-lesson-16/node_modules/openai/src/pagination.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless.\n\nimport { AbstractPage, Response, APIClient, FinalRequestOptions, PageInfo } from './core';\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n\n  object: string;\n}\n\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page<Item> extends AbstractPage<Item> implements PageResponse<Item> {\n  data: Array<Item>;\n\n  object: string;\n\n  constructor(client: APIClient, response: Response, body: PageResponse<Item>, options: FinalRequestOptions) {\n    super(client, response, body, options);\n\n    this.data = body.data;\n    this.object = body.object;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data;\n  }\n\n  // @deprecated Please use `nextPageInfo()` instead\n  /**\n   * This page represents a response that isn't actually paginated at the API level\n   * so there will never be any next page params.\n   */\n  nextPageParams(): null {\n    return null;\n  }\n\n  nextPageInfo(): null {\n    return null;\n  }\n}\n\nexport interface CursorPageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageParams {\n  /**\n   * Identifier for the last job from the previous pagination request.\n   */\n  after?: string;\n\n  /**\n   * Number of fine-tuning jobs to retrieve.\n   */\n  limit?: number;\n}\n\nexport class CursorPage<Item extends { id: string }>\n  extends AbstractPage<Item>\n  implements CursorPageResponse<Item>\n{\n  data: Array<Item>;\n\n  constructor(\n    client: APIClient,\n    response: Response,\n    body: CursorPageResponse<Item>,\n    options: FinalRequestOptions,\n  ) {\n    super(client, response, body, options);\n\n    this.data = body.data;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data;\n  }\n\n  // @deprecated Please use `nextPageInfo()` instead\n  nextPageParams(): Partial<CursorPageParams> | null {\n    const info = this.nextPageInfo();\n    if (!info) return null;\n    if ('params' in info) return info.params;\n    const params = Object.fromEntries(info.url.searchParams);\n    if (!Object.keys(params).length) return null;\n    return params;\n  }\n\n  nextPageInfo(): PageInfo | null {\n    if (!this.data?.length) {\n      return null;\n    }\n\n    const next = this.data[this.data.length - 1]?.id;\n    if (!next) return null;\n    return { params: { after: next } };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}