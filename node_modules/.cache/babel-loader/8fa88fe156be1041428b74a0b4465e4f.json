{"ast":null,"code":"import { FormData, File, getMultipartRequestOptions, isFsReadStream } from \"./_shims/index.mjs\";\nexport { fileFromPath } from \"./_shims/index.mjs\";\nexport const isResponseLike = value => value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';\nexport const isFileLike = value => value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && isBlobLike(value);\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\n\nexport const isBlobLike = value => value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';\nexport const isUploadable = value => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\n\nexport async function toFile(value, name) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // If it's a promise, resolve it.\n  value = await value;\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n    return new File([blob], name, options);\n  }\n\n  const bits = await getBytes(value);\n  name || (name = getName(value) ?? 'unknown_file');\n\n  if (!options.type) {\n    const type = bits[0]?.type;\n\n    if (typeof type === 'string') {\n      options = { ...options,\n        type\n      };\n    }\n  }\n\n  return new File(bits, name, options);\n}\n\nasync function getBytes(value) {\n  let parts = [];\n\n  if (typeof value === 'string' || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n  value instanceof ArrayBuffer) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);\n  }\n\n  return parts;\n}\n\nfunction propsForError(value) {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map(p => `\"${p}\"`).join(', ')}]`;\n}\n\nfunction getName(value) {\n  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream\n  getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop();\n}\n\nconst getStringFromMaybeBuffer = x => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\n\nconst isAsyncIterableIterator = value => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\nexport const isMultipartBody = body => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\n\nexport const maybeMultipartFormRequestOptions = async opts => {\n  if (!hasUploadableValue(opts.body)) return opts;\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\nexport const multipartFormRequestOptions = async opts => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\nexport const createForm = async body => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(_ref => {\n    let [key, value] = _ref;\n    return addFormValue(form, key, value);\n  }));\n  return form;\n};\n\nconst hasUploadableValue = value => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue(value[k])) return true;\n    }\n  }\n\n  return false;\n};\n\nconst addFormValue = async (form, key, value) => {\n  if (value === undefined) return;\n\n  if (value == null) {\n    throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n  } // TODO: make nested formats configurable\n\n\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map(entry => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(Object.entries(value).map(_ref2 => {\n      let [name, prop] = _ref2;\n      return addFormValue(form, `${key}[${name}]`, prop);\n    }));\n  } else {\n    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n  }\n};","map":{"version":3,"mappings":"SAEEA,UACAC,MAGAC,4BAEAC,sBACD;SAEQC,oBAAc;AAiDvB,OAAO,MAAMC,cAAc,GAAIC,KAAD,IAC5BA,KAAK,IAAI,IAAT,IACA,OAAOA,KAAP,KAAiB,QADjB,IAEA,OAAOA,KAAK,CAACC,GAAb,KAAqB,QAFrB,IAGA,OAAOD,KAAK,CAACE,IAAb,KAAsB,UAJjB;AAMP,OAAO,MAAMC,UAAU,GAAIH,KAAD,IACxBA,KAAK,IAAI,IAAT,IACA,OAAOA,KAAP,KAAiB,QADjB,IAEA,OAAOA,KAAK,CAACI,IAAb,KAAsB,QAFtB,IAGA,OAAOJ,KAAK,CAACK,YAAb,KAA8B,QAH9B,IAIAC,UAAU,CAACN,KAAD,CALL;AAOP;;;;;AAIA,OAAO,MAAMM,UAAU,GAAIN,KAAD,IACxBA,KAAK,IAAI,IAAT,IACA,OAAOA,KAAP,KAAiB,QADjB,IAEA,OAAOA,KAAK,CAACO,IAAb,KAAsB,QAFtB,IAGA,OAAOP,KAAK,CAACQ,IAAb,KAAsB,QAHtB,IAIA,OAAOR,KAAK,CAACS,IAAb,KAAsB,UAJtB,IAKA,OAAOT,KAAK,CAACU,KAAb,KAAuB,UALvB,IAMA,OAAOV,KAAK,CAACW,WAAb,KAA6B,UAPxB;AASP,OAAO,MAAMC,YAAY,GAAIZ,KAAD,IAAoC;AAC9D,SAAOG,UAAU,CAACH,KAAD,CAAV,IAAqBD,cAAc,CAACC,KAAD,CAAnC,IAA8CH,cAAc,CAACG,KAAD,CAAnE;AACD,CAFM;AAMP;;;;;;;;;;AASA,OAAO,eAAea,MAAf,CACLb,KADK,EAELI,IAFK,EAGoC;AAAA,MAAzCU,OAAyC,uEAAF,EAAE;AAEzC;AACAd,OAAK,GAAG,MAAMA,KAAd;;AAEA,MAAID,cAAc,CAACC,KAAD,CAAlB,EAA2B;AACzB,UAAME,IAAI,GAAG,MAAMF,KAAK,CAACE,IAAN,EAAnB;AACAE,QAAI,KAAJA,IAAI,GAAK,IAAIW,GAAJ,CAAQf,KAAK,CAACC,GAAd,EAAmBe,QAAnB,CAA4BC,KAA5B,CAAkC,OAAlC,EAA2CC,GAA3C,MAAoD,cAAzD,CAAJ;AAEA,WAAO,IAAIvB,IAAJ,CAAS,CAACO,IAAD,CAAT,EAAwBE,IAAxB,EAA8BU,OAA9B,CAAP;AACD;;AAED,QAAMK,IAAI,GAAG,MAAMC,QAAQ,CAACpB,KAAD,CAA3B;AAEAI,MAAI,KAAJA,IAAI,GAAKiB,OAAO,CAACrB,KAAD,CAAP,IAAkB,cAAvB,CAAJ;;AAEA,MAAI,CAACc,OAAO,CAACN,IAAb,EAAmB;AACjB,UAAMA,IAAI,GAAIW,IAAI,CAAC,CAAD,CAAJ,EAAiBX,IAA/B;;AACA,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BM,aAAO,GAAG,EAAE,GAAGA,OAAL;AAAcN;AAAd,OAAV;AACD;AACF;;AAED,SAAO,IAAIb,IAAJ,CAASwB,IAAT,EAAef,IAAf,EAAqBU,OAArB,CAAP;AACD;;AAED,eAAeM,QAAf,CAAwBpB,KAAxB,EAA0C;AACxC,MAAIsB,KAAK,GAAoB,EAA7B;;AACA,MACE,OAAOtB,KAAP,KAAiB,QAAjB,IACAuB,WAAW,CAACC,MAAZ,CAAmBxB,KAAnB,CADA,IAC6B;AAC7BA,OAAK,YAAYuB,WAHnB,EAIE;AACAD,SAAK,CAACG,IAAN,CAAWzB,KAAX;AACD,GAND,MAMO,IAAIM,UAAU,CAACN,KAAD,CAAd,EAAuB;AAC5BsB,SAAK,CAACG,IAAN,CAAW,MAAMzB,KAAK,CAACW,WAAN,EAAjB;AACD,GAFM,MAEA,IACLe,uBAAuB,CAAC1B,KAAD,CADlB,CAC0B;AAD1B,IAEL;AACA,eAAW,MAAM2B,KAAjB,IAA0B3B,KAA1B,EAAiC;AAC/BsB,WAAK,CAACG,IAAN,CAAWE,KAAX,EAD+B,CACA;AAChC;AACF,GANM,MAMA;AACL,UAAM,IAAIC,KAAJ,CACJ,yBAAyB,OAAO5B,KAAK,kBACnCA,KAAK,EAAE6B,WAAP,EAAoBzB,IACtB,YAAY0B,aAAa,CAAC9B,KAAD,CAAO,EAH5B,CAAN;AAKD;;AAED,SAAOsB,KAAP;AACD;;AAED,SAASQ,aAAT,CAAuB9B,KAAvB,EAAiC;AAC/B,QAAM+B,KAAK,GAAGC,MAAM,CAACC,mBAAP,CAA2BjC,KAA3B,CAAd;AACA,SAAO,IAAI+B,KAAK,CAACG,GAAN,CAAWC,CAAD,IAAO,IAAIA,CAAC,GAAtB,EAA2BC,IAA3B,CAAgC,IAAhC,CAAqC,GAAhD;AACD;;AAED,SAASf,OAAT,CAAiBrB,KAAjB,EAA2B;AACzB,SACEqC,wBAAwB,CAACrC,KAAK,CAACI,IAAP,CAAxB,IACAiC,wBAAwB,CAACrC,KAAK,CAACsC,QAAP,CADxB,IAEA;AACAD,0BAAwB,CAACrC,KAAK,CAACuC,IAAP,CAAxB,EAAsCtB,KAAtC,CAA4C,OAA5C,EAAqDC,GAArD,EAJF;AAMD;;AAED,MAAMmB,wBAAwB,GAAIG,CAAD,IAAqD;AACpF,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOA,CAAP;AAC3B,MAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCD,CAAC,YAAYC,MAAlD,EAA0D,OAAOC,MAAM,CAACF,CAAD,CAAb;AAC1D,SAAOG,SAAP;AACD,CAJD;;AAMA,MAAMjB,uBAAuB,GAAI1B,KAAD,IAC9BA,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAlC,IAA8C,OAAOA,KAAK,CAAC4C,MAAM,CAACC,aAAR,CAAZ,KAAuC,UADvF;;AAGA,OAAO,MAAMC,eAAe,GAAIC,IAAD,IAC7BA,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAAxB,IAAoCA,IAAI,CAACA,IAAzC,IAAiDA,IAAI,CAACH,MAAM,CAACI,WAAR,CAAJ,KAA6B,eADzE;AAGP;;;;;AAIA,OAAO,MAAMC,gCAAgC,GAAG,MAC9CC,IAD8C,IAEA;AAC9C,MAAI,CAACC,kBAAkB,CAACD,IAAI,CAACH,IAAN,CAAvB,EAAoC,OAAOG,IAAP;AAEpC,QAAME,IAAI,GAAG,MAAMC,UAAU,CAACH,IAAI,CAACH,IAAN,CAA7B;AACA,SAAOnD,0BAA0B,CAACwD,IAAD,EAAOF,IAAP,CAAjC;AACD,CAPM;AASP,OAAO,MAAMI,2BAA2B,GAAG,MACzCJ,IADyC,IAEK;AAC9C,QAAME,IAAI,GAAG,MAAMC,UAAU,CAACH,IAAI,CAACH,IAAN,CAA7B;AACA,SAAOnD,0BAA0B,CAACwD,IAAD,EAAOF,IAAP,CAAjC;AACD,CALM;AAOP,OAAO,MAAMG,UAAU,GAAG,MAAoCN,IAApC,IAA8E;AACtG,QAAMK,IAAI,GAAG,IAAI1D,QAAJ,EAAb;AACA,QAAM6D,OAAO,CAACC,GAAR,CAAYxB,MAAM,CAACyB,OAAP,CAAeV,IAAI,IAAI,EAAvB,EAA2Bb,GAA3B,CAA+B;AAAA,QAAC,CAACwB,GAAD,EAAM1D,KAAN,CAAD;AAAA,WAAkB2D,YAAY,CAACP,IAAD,EAAOM,GAAP,EAAY1D,KAAZ,CAA9B;AAAA,GAA/B,CAAZ,CAAN;AACA,SAAOoD,IAAP;AACD,CAJM;;AAMP,MAAMD,kBAAkB,GAAInD,KAAD,IAA4B;AACrD,MAAIY,YAAY,CAACZ,KAAD,CAAhB,EAAyB,OAAO,IAAP;AACzB,MAAI4D,KAAK,CAACC,OAAN,CAAc7D,KAAd,CAAJ,EAA0B,OAAOA,KAAK,CAAC8D,IAAN,CAAWX,kBAAX,CAAP;;AAC1B,MAAInD,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA9B,EAAwC;AACtC,SAAK,MAAM+D,CAAX,IAAgB/D,KAAhB,EAAuB;AACrB,UAAImD,kBAAkB,CAAEnD,KAAa,CAAC+D,CAAD,CAAf,CAAtB,EAA2C,OAAO,IAAP;AAC5C;AACF;;AACD,SAAO,KAAP;AACD,CATD;;AAWA,MAAMJ,YAAY,GAAG,OAAOP,IAAP,EAAuBM,GAAvB,EAAoC1D,KAApC,KAAqE;AACxF,MAAIA,KAAK,KAAK2C,SAAd,EAAyB;;AACzB,MAAI3C,KAAK,IAAI,IAAb,EAAmB;AACjB,UAAM,IAAIgE,SAAJ,CACJ,sBAAsBN,GAAG,6DADrB,CAAN;AAGD,GANuF,CAQxF;;;AACA,MAAI,OAAO1D,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAA9C,IAA0D,OAAOA,KAAP,KAAiB,SAA/E,EAA0F;AACxFoD,QAAI,CAACa,MAAL,CAAYP,GAAZ,EAAiBhB,MAAM,CAAC1C,KAAD,CAAvB;AACD,GAFD,MAEO,IAAIY,YAAY,CAACZ,KAAD,CAAhB,EAAyB;AAC9B,UAAMkE,IAAI,GAAG,MAAMrD,MAAM,CAACb,KAAD,CAAzB;AACAoD,QAAI,CAACa,MAAL,CAAYP,GAAZ,EAAiBQ,IAAjB;AACD,GAHM,MAGA,IAAIN,KAAK,CAACC,OAAN,CAAc7D,KAAd,CAAJ,EAA0B;AAC/B,UAAMuD,OAAO,CAACC,GAAR,CAAYxD,KAAK,CAACkC,GAAN,CAAWiC,KAAD,IAAWR,YAAY,CAACP,IAAD,EAAOM,GAAG,GAAG,IAAb,EAAmBS,KAAnB,CAAjC,CAAZ,CAAN;AACD,GAFM,MAEA,IAAI,OAAOnE,KAAP,KAAiB,QAArB,EAA+B;AACpC,UAAMuD,OAAO,CAACC,GAAR,CACJxB,MAAM,CAACyB,OAAP,CAAezD,KAAf,EAAsBkC,GAAtB,CAA0B;AAAA,UAAC,CAAC9B,IAAD,EAAOgE,IAAP,CAAD;AAAA,aAAkBT,YAAY,CAACP,IAAD,EAAO,GAAGM,GAAG,IAAItD,IAAI,GAArB,EAA0BgE,IAA1B,CAA9B;AAAA,KAA1B,CADI,CAAN;AAGD,GAJM,MAIA;AACL,UAAM,IAAIJ,SAAJ,CACJ,wGAAwGhE,KAAK,UADzG,CAAN;AAGD;AACF,CAzBD","names":["FormData","File","getMultipartRequestOptions","isFsReadStream","fileFromPath","isResponseLike","value","url","blob","isFileLike","name","lastModified","isBlobLike","size","type","text","slice","arrayBuffer","isUploadable","toFile","options","URL","pathname","split","pop","bits","getBytes","getName","parts","ArrayBuffer","isView","push","isAsyncIterableIterator","chunk","Error","constructor","propsForError","props","Object","getOwnPropertyNames","map","p","join","getStringFromMaybeBuffer","filename","path","x","Buffer","String","undefined","Symbol","asyncIterator","isMultipartBody","body","toStringTag","maybeMultipartFormRequestOptions","opts","hasUploadableValue","form","createForm","multipartFormRequestOptions","Promise","all","entries","key","addFormValue","Array","isArray","some","k","TypeError","append","file","entry","prop"],"sources":["/Users/zachjohnson/Desktop/React-Wordle-lesson-16/node_modules/openai/src/uploads.ts"],"sourcesContent":["import { type RequestOptions } from './core';\nimport {\n  FormData,\n  File,\n  type Blob,\n  type FilePropertyBag,\n  getMultipartRequestOptions,\n  type FsReadStream,\n  isFsReadStream,\n} from './_shims/index';\nimport { MultipartBody } from './_shims/MultipartBody';\nexport { fileFromPath } from './_shims/index';\n\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\n\n/**\n * Typically, this is a native \"File\" class.\n *\n * We provide the {@link toFile} utility to convert a variety of objects\n * into the File class.\n *\n * For convenience, you can also pass a fetch Response, or in Node,\n * the result of fs.createReadStream().\n */\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\n\n/**\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\n */\nexport interface BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\n  readonly size: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\n  readonly type: string;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\n  text(): Promise<string>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\n  slice(start?: number, end?: number): BlobLike;\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\n}\n\n/**\n * Intended to match web.File, node.File, node-fetch.File, etc.\n */\nexport interface FileLike extends BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\n  readonly lastModified: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\n  readonly name: string;\n}\n\n/**\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\n */\nexport interface ResponseLike {\n  url: string;\n  blob(): Promise<BlobLike>;\n}\n\nexport const isResponseLike = (value: any): value is ResponseLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.url === 'string' &&\n  typeof value.blob === 'function';\n\nexport const isFileLike = (value: any): value is FileLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.name === 'string' &&\n  typeof value.lastModified === 'number' &&\n  isBlobLike(value);\n\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.size === 'number' &&\n  typeof value.type === 'string' &&\n  typeof value.text === 'function' &&\n  typeof value.slice === 'function' &&\n  typeof value.arrayBuffer === 'function';\n\nexport const isUploadable = (value: any): value is Uploadable => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\n\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(\n  value: ToFileInput | PromiseLike<ToFileInput>,\n  name?: string | null | undefined,\n  options: FilePropertyBag | undefined = {},\n): Promise<FileLike> {\n  // If it's a promise, resolve it.\n  value = await value;\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\n\n    return new File([blob as any], name, options);\n  }\n\n  const bits = await getBytes(value);\n\n  name ||= getName(value) ?? 'unknown_file';\n\n  if (!options.type) {\n    const type = (bits[0] as any)?.type;\n    if (typeof type === 'string') {\n      options = { ...options, type };\n    }\n  }\n\n  return new File(bits, name, options);\n}\n\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\n  let parts: Array<BlobPart> = [];\n  if (\n    typeof value === 'string' ||\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer\n  ) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk as BlobPart); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(\n      `Unexpected data type: ${typeof value}; constructor: ${\n        value?.constructor?.name\n      }; props: ${propsForError(value)}`,\n    );\n  }\n\n  return parts;\n}\n\nfunction propsForError(value: any): string {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n\nfunction getName(value: any): string | undefined {\n  return (\n    getStringFromMaybeBuffer(value.name) ||\n    getStringFromMaybeBuffer(value.filename) ||\n    // For fs.ReadStream\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\n  );\n}\n\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\n\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\nexport const isMultipartBody = (body: any): body is MultipartBody =>\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async <T extends {} = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  if (!hasUploadableValue(opts.body)) return opts;\n\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const multipartFormRequestOptions = async <T extends {} = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n\nconst hasUploadableValue = (value: unknown): boolean => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue((value as any)[k])) return true;\n    }\n  }\n  return false;\n};\n\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\n    );\n  }\n\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file as File);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\n    );\n  } else {\n    throw new TypeError(\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\n    );\n  }\n};\n"]},"metadata":{},"sourceType":"module"}