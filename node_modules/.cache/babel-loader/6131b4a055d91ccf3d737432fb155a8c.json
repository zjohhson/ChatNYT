{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  pathToFileURL\n} = require(\"url\");\n\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\n\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\n\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\n\nconst EnableChunkLoadingPlugin = require(\"../javascript/EnableChunkLoadingPlugin\");\n\nconst {\n  equals\n} = require(\"../util/ArrayHelpers\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  contextify\n} = require(\"../util/identifier\");\n\nconst EnableWasmLoadingPlugin = require(\"../wasm/EnableWasmLoadingPlugin\");\n\nconst ConstDependency = require(\"./ConstDependency\");\n\nconst CreateScriptUrlDependency = require(\"./CreateScriptUrlDependency\");\n\nconst {\n  harmonySpecifierTag\n} = require(\"./HarmonyImportDependencyParserPlugin\");\n\nconst WorkerDependency = require(\"./WorkerDependency\");\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n\n/** @typedef {import(\"estree\").Expression} Expression */\n\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n\n/** @typedef {import(\"estree\").Pattern} Pattern */\n\n/** @typedef {import(\"estree\").Property} Property */\n\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").ChunkLoading} ChunkLoading */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OutputModule} OutputModule */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").WasmLoading} WasmLoading */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").WorkerPublicPath} WorkerPublicPath */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} Parser */\n\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/** @typedef {import(\"./HarmonyImportDependencyParserPlugin\").HarmonySettings} HarmonySettings */\n\n/**\n * @param {NormalModule} module module\n * @returns {string} url\n */\n\n\nconst getUrl = module => {\n  return pathToFileURL(module.resource).toString();\n};\n\nconst WorkerSpecifierTag = Symbol(\"worker specifier tag\");\nconst DEFAULT_SYNTAX = [\"Worker\", \"SharedWorker\", \"navigator.serviceWorker.register()\", \"Worker from worker_threads\"];\n/** @type {WeakMap<ParserState, number>} */\n\nconst workerIndexMap = new WeakMap();\nconst PLUGIN_NAME = \"WorkerPlugin\";\n\nclass WorkerPlugin {\n  /**\n   * @param {ChunkLoading} chunkLoading chunk loading\n   * @param {WasmLoading} wasmLoading wasm loading\n   * @param {OutputModule} module output module\n   * @param {WorkerPublicPath} workerPublicPath worker public path\n   */\n  constructor(chunkLoading, wasmLoading, module, workerPublicPath) {\n    this._chunkLoading = chunkLoading;\n    this._wasmLoading = wasmLoading;\n    this._module = module;\n    this._workerPublicPath = workerPublicPath;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    if (this._chunkLoading) {\n      new EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler);\n    }\n\n    if (this._wasmLoading) {\n      new EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);\n    }\n\n    const cachedContextify = contextify.bindContextCache(compiler.context, compiler.root);\n    compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyFactories.set(WorkerDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(WorkerDependency, new WorkerDependency.Template());\n      compilation.dependencyTemplates.set(CreateScriptUrlDependency, new CreateScriptUrlDependency.Template());\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {Expression} expr expression\n       * @returns {[BasicEvaluatedExpression, [number, number]] | void} parsed\n       */\n\n      const parseModuleUrl = (parser, expr) => {\n        if (expr.type !== \"NewExpression\" || expr.callee.type === \"Super\" || expr.arguments.length !== 2) return;\n        const [arg1, arg2] = expr.arguments;\n        if (arg1.type === \"SpreadElement\") return;\n        if (arg2.type === \"SpreadElement\") return;\n        const callee = parser.evaluateExpression(expr.callee);\n        if (!callee.isIdentifier() || callee.identifier !== \"URL\") return;\n        const arg2Value = parser.evaluateExpression(arg2);\n\n        if (!arg2Value.isString() || !\n        /** @type {string} */\n        arg2Value.string.startsWith(\"file://\") || arg2Value.string !== getUrl(parser.state.module)) {\n          return;\n        }\n\n        const arg1Value = parser.evaluateExpression(arg1);\n        return [arg1Value, [\n        /** @type {Range} */\n        arg1.range[0],\n        /** @type {Range} */\n        arg2.range[1]]];\n      };\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {ObjectExpression} expr expression\n       * @returns {{ expressions: Record<string, Expression | Pattern>, otherElements: (Property | SpreadElement)[], values: Record<string, any>, spread: boolean, insertType: \"comma\" | \"single\", insertLocation: number }} parsed object\n       */\n\n\n      const parseObjectExpression = (parser, expr) => {\n        /** @type {Record<string, any>} */\n        const values = {};\n        /** @type {Record<string, Expression | Pattern>} */\n\n        const expressions = {};\n        /** @type {(Property | SpreadElement)[]} */\n\n        const otherElements = [];\n        let spread = false;\n\n        for (const prop of expr.properties) {\n          if (prop.type === \"SpreadElement\") {\n            spread = true;\n          } else if (prop.type === \"Property\" && !prop.method && !prop.computed && prop.key.type === \"Identifier\") {\n            expressions[prop.key.name] = prop.value;\n\n            if (!prop.shorthand && !prop.value.type.endsWith(\"Pattern\")) {\n              const value = parser.evaluateExpression(\n              /** @type {Expression} */\n              prop.value);\n              if (value.isCompileTimeValue()) values[prop.key.name] = value.asCompileTimeValue();\n            }\n          } else {\n            otherElements.push(prop);\n          }\n        }\n\n        const insertType = expr.properties.length > 0 ? \"comma\" : \"single\";\n        const insertLocation = expr.properties[expr.properties.length - 1].range[1];\n        return {\n          expressions,\n          otherElements,\n          values,\n          spread,\n          insertType,\n          insertLocation\n        };\n      };\n      /**\n       * @param {Parser} parser parser parser\n       * @param {JavascriptParserOptions} parserOptions parserOptions\n       * @returns {void}\n       */\n\n\n      const parserPlugin = (parser, parserOptions) => {\n        if (parserOptions.worker === false) return;\n        const options = !Array.isArray(parserOptions.worker) ? [\"...\"] : parserOptions.worker;\n        /**\n         * @param {CallExpression} expr expression\n         * @returns {boolean | void} true when handled\n         */\n\n        const handleNewWorker = expr => {\n          if (expr.arguments.length === 0 || expr.arguments.length > 2) return;\n          const [arg1, arg2] = expr.arguments;\n          if (arg1.type === \"SpreadElement\") return;\n          if (arg2 && arg2.type === \"SpreadElement\") return;\n          const parsedUrl = parseModuleUrl(parser, arg1);\n          if (!parsedUrl) return;\n          const [url, range] = parsedUrl;\n          if (!url.isString()) return;\n          const {\n            expressions,\n            otherElements,\n            values: options,\n            spread: hasSpreadInOptions,\n            insertType,\n            insertLocation\n          } = arg2 && arg2.type === \"ObjectExpression\" ? parseObjectExpression(parser, arg2) : {\n            /** @type {Record<string, Expression | Pattern>} */\n            expressions: {},\n            otherElements: [],\n\n            /** @type {Record<string, any>} */\n            values: {},\n            spread: false,\n            insertType: arg2 ? \"spread\" : \"argument\",\n            insertLocation: arg2 ?\n            /** @type {Range} */\n            arg2.range :\n            /** @type {Range} */\n            arg1.range[1]\n          };\n          const {\n            options: importOptions,\n            errors: commentErrors\n          } = parser.parseCommentOptions(\n          /** @type {Range} */\n          expr.range);\n\n          if (commentErrors) {\n            for (const e of commentErrors) {\n              const {\n                comment\n              } = e;\n              parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));\n            }\n          }\n          /** @type {EntryOptions} */\n\n\n          let entryOptions = {};\n\n          if (importOptions) {\n            if (importOptions.webpackIgnore !== undefined) {\n              if (typeof importOptions.webpackIgnore !== \"boolean\") {\n                parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackIgnore\\` expected a boolean, but received: ${importOptions.webpackIgnore}.`,\n                /** @type {DependencyLocation} */\n                expr.loc));\n              } else {\n                if (importOptions.webpackIgnore) {\n                  return false;\n                }\n              }\n            }\n\n            if (importOptions.webpackEntryOptions !== undefined) {\n              if (typeof importOptions.webpackEntryOptions !== \"object\" || importOptions.webpackEntryOptions === null) {\n                parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackEntryOptions\\` expected a object, but received: ${importOptions.webpackEntryOptions}.`,\n                /** @type {DependencyLocation} */\n                expr.loc));\n              } else {\n                Object.assign(entryOptions, importOptions.webpackEntryOptions);\n              }\n            }\n\n            if (importOptions.webpackChunkName !== undefined) {\n              if (typeof importOptions.webpackChunkName !== \"string\") {\n                parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackChunkName\\` expected a string, but received: ${importOptions.webpackChunkName}.`,\n                /** @type {DependencyLocation} */\n                expr.loc));\n              } else {\n                entryOptions.name = importOptions.webpackChunkName;\n              }\n            }\n          }\n\n          if (!Object.prototype.hasOwnProperty.call(entryOptions, \"name\") && options && typeof options.name === \"string\") {\n            entryOptions.name = options.name;\n          }\n\n          if (entryOptions.runtime === undefined) {\n            let i = workerIndexMap.get(parser.state) || 0;\n            workerIndexMap.set(parser.state, i + 1);\n            let name = `${cachedContextify(parser.state.module.identifier())}|${i}`;\n            const hash = createHash(compilation.outputOptions.hashFunction);\n            hash.update(name);\n            const digest =\n            /** @type {string} */\n            hash.digest(compilation.outputOptions.hashDigest);\n            entryOptions.runtime = digest.slice(0, compilation.outputOptions.hashDigestLength);\n          }\n\n          const block = new AsyncDependenciesBlock({\n            name: entryOptions.name,\n            entryOptions: {\n              chunkLoading: this._chunkLoading,\n              wasmLoading: this._wasmLoading,\n              ...entryOptions\n            }\n          });\n          block.loc = expr.loc;\n          const dep = new WorkerDependency(\n          /** @type {string} */\n          url.string, range, {\n            publicPath: this._workerPublicPath\n          });\n          dep.loc =\n          /** @type {DependencyLocation} */\n          expr.loc;\n          block.addDependency(dep);\n          parser.state.module.addBlock(block);\n\n          if (compilation.outputOptions.trustedTypes) {\n            const dep = new CreateScriptUrlDependency(\n            /** @type {Range} */\n            expr.arguments[0].range);\n            dep.loc =\n            /** @type {DependencyLocation} */\n            expr.loc;\n            parser.state.module.addDependency(dep);\n          }\n\n          if (expressions.type) {\n            const expr = expressions.type;\n\n            if (options.type !== false) {\n              const dep = new ConstDependency(this._module ? '\"module\"' : \"undefined\",\n              /** @type {Range} */\n              expr.range);\n              dep.loc =\n              /** @type {DependencyLocation} */\n              expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n              expressions.type = undefined;\n            }\n          } else if (insertType === \"comma\") {\n            if (this._module || hasSpreadInOptions) {\n              const dep = new ConstDependency(`, type: ${this._module ? '\"module\"' : \"undefined\"}`, insertLocation);\n              dep.loc =\n              /** @type {DependencyLocation} */\n              expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            }\n          } else if (insertType === \"spread\") {\n            const dep1 = new ConstDependency(\"Object.assign({}, \",\n            /** @type {Range} */\n            insertLocation[0]);\n            const dep2 = new ConstDependency(`, { type: ${this._module ? '\"module\"' : \"undefined\"} })`,\n            /** @type {Range} */\n            insertLocation[1]);\n            dep1.loc =\n            /** @type {DependencyLocation} */\n            expr.loc;\n            dep2.loc =\n            /** @type {DependencyLocation} */\n            expr.loc;\n            parser.state.module.addPresentationalDependency(dep1);\n            parser.state.module.addPresentationalDependency(dep2);\n          } else if (insertType === \"argument\") {\n            if (this._module) {\n              const dep = new ConstDependency(', { type: \"module\" }', insertLocation);\n              dep.loc =\n              /** @type {DependencyLocation} */\n              expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            }\n          }\n\n          parser.walkExpression(expr.callee);\n\n          for (const key of Object.keys(expressions)) {\n            if (expressions[key]) parser.walkExpression(expressions[key]);\n          }\n\n          for (const prop of otherElements) {\n            parser.walkProperty(prop);\n          }\n\n          if (insertType === \"spread\") {\n            parser.walkExpression(arg2);\n          }\n\n          return true;\n        };\n        /**\n         * @param {string} item item\n         */\n\n\n        const processItem = item => {\n          if (item.startsWith(\"*\") && item.includes(\".\") && item.endsWith(\"()\")) {\n            const firstDot = item.indexOf(\".\");\n            const pattern = item.slice(1, firstDot);\n            const itemMembers = item.slice(firstDot + 1, -2);\n            parser.hooks.pattern.for(pattern).tap(PLUGIN_NAME, pattern => {\n              parser.tagVariable(pattern.name, WorkerSpecifierTag);\n              return true;\n            });\n            parser.hooks.callMemberChain.for(WorkerSpecifierTag).tap(PLUGIN_NAME, (expression, members) => {\n              if (itemMembers !== members.join(\".\")) {\n                return;\n              }\n\n              return handleNewWorker(expression);\n            });\n          } else if (item.endsWith(\"()\")) {\n            parser.hooks.call.for(item.slice(0, -2)).tap(PLUGIN_NAME, handleNewWorker);\n          } else {\n            const match = /^(.+?)(\\(\\))?\\s+from\\s+(.+)$/.exec(item);\n\n            if (match) {\n              const ids = match[1].split(\".\");\n              const call = match[2];\n              const source = match[3];\n              (call ? parser.hooks.call : parser.hooks.new).for(harmonySpecifierTag).tap(PLUGIN_NAME, expr => {\n                const settings =\n                /** @type {HarmonySettings} */\n                parser.currentTagData;\n\n                if (!settings || settings.source !== source || !equals(settings.ids, ids)) {\n                  return;\n                }\n\n                return handleNewWorker(expr);\n              });\n            } else {\n              parser.hooks.new.for(item).tap(PLUGIN_NAME, handleNewWorker);\n            }\n          }\n        };\n\n        for (const item of options) {\n          if (item === \"...\") {\n            DEFAULT_SYNTAX.forEach(processItem);\n          } else processItem(item);\n        }\n      };\n\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, parserPlugin);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, parserPlugin);\n    });\n  }\n\n}\n\nmodule.exports = WorkerPlugin;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/dependencies/WorkerPlugin.js"],"names":["pathToFileURL","require","AsyncDependenciesBlock","CommentCompilationWarning","JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","UnsupportedFeatureWarning","EnableChunkLoadingPlugin","equals","createHash","contextify","EnableWasmLoadingPlugin","ConstDependency","CreateScriptUrlDependency","harmonySpecifierTag","WorkerDependency","getUrl","module","resource","toString","WorkerSpecifierTag","Symbol","DEFAULT_SYNTAX","workerIndexMap","WeakMap","PLUGIN_NAME","WorkerPlugin","constructor","chunkLoading","wasmLoading","workerPublicPath","_chunkLoading","_wasmLoading","_module","_workerPublicPath","apply","compiler","cachedContextify","bindContextCache","context","root","hooks","thisCompilation","tap","compilation","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","parseModuleUrl","parser","expr","type","callee","arguments","length","arg1","arg2","evaluateExpression","isIdentifier","identifier","arg2Value","isString","string","startsWith","state","arg1Value","range","parseObjectExpression","values","expressions","otherElements","spread","prop","properties","method","computed","key","name","value","shorthand","endsWith","isCompileTimeValue","asCompileTimeValue","push","insertType","insertLocation","parserPlugin","parserOptions","worker","options","Array","isArray","handleNewWorker","parsedUrl","url","hasSpreadInOptions","importOptions","errors","commentErrors","parseCommentOptions","e","comment","addWarning","message","loc","entryOptions","webpackIgnore","undefined","webpackEntryOptions","Object","assign","webpackChunkName","prototype","hasOwnProperty","call","runtime","i","get","hash","outputOptions","hashFunction","update","digest","hashDigest","slice","hashDigestLength","block","dep","publicPath","addDependency","addBlock","trustedTypes","addPresentationalDependency","dep1","dep2","walkExpression","keys","walkProperty","processItem","item","includes","firstDot","indexOf","pattern","itemMembers","for","tagVariable","callMemberChain","expression","members","join","match","exec","ids","split","source","new","settings","currentTagData","forEach","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { pathToFileURL } = require(\"url\");\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst EnableChunkLoadingPlugin = require(\"../javascript/EnableChunkLoadingPlugin\");\nconst { equals } = require(\"../util/ArrayHelpers\");\nconst createHash = require(\"../util/createHash\");\nconst { contextify } = require(\"../util/identifier\");\nconst EnableWasmLoadingPlugin = require(\"../wasm/EnableWasmLoadingPlugin\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst CreateScriptUrlDependency = require(\"./CreateScriptUrlDependency\");\nconst {\n\tharmonySpecifierTag\n} = require(\"./HarmonyImportDependencyParserPlugin\");\nconst WorkerDependency = require(\"./WorkerDependency\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"../../declarations/WebpackOptions\").ChunkLoading} ChunkLoading */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OutputModule} OutputModule */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WasmLoading} WasmLoading */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WorkerPublicPath} WorkerPublicPath */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\")} Parser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./HarmonyImportDependencyParserPlugin\").HarmonySettings} HarmonySettings */\n\n/**\n * @param {NormalModule} module module\n * @returns {string} url\n */\nconst getUrl = module => {\n\treturn pathToFileURL(module.resource).toString();\n};\n\nconst WorkerSpecifierTag = Symbol(\"worker specifier tag\");\n\nconst DEFAULT_SYNTAX = [\n\t\"Worker\",\n\t\"SharedWorker\",\n\t\"navigator.serviceWorker.register()\",\n\t\"Worker from worker_threads\"\n];\n\n/** @type {WeakMap<ParserState, number>} */\nconst workerIndexMap = new WeakMap();\n\nconst PLUGIN_NAME = \"WorkerPlugin\";\n\nclass WorkerPlugin {\n\t/**\n\t * @param {ChunkLoading} chunkLoading chunk loading\n\t * @param {WasmLoading} wasmLoading wasm loading\n\t * @param {OutputModule} module output module\n\t * @param {WorkerPublicPath} workerPublicPath worker public path\n\t */\n\tconstructor(chunkLoading, wasmLoading, module, workerPublicPath) {\n\t\tthis._chunkLoading = chunkLoading;\n\t\tthis._wasmLoading = wasmLoading;\n\t\tthis._module = module;\n\t\tthis._workerPublicPath = workerPublicPath;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tif (this._chunkLoading) {\n\t\t\tnew EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler);\n\t\t}\n\t\tif (this._wasmLoading) {\n\t\t\tnew EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);\n\t\t}\n\t\tconst cachedContextify = contextify.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tWorkerDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tWorkerDependency,\n\t\t\t\t\tnew WorkerDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tCreateScriptUrlDependency,\n\t\t\t\t\tnew CreateScriptUrlDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {Expression} expr expression\n\t\t\t\t * @returns {[BasicEvaluatedExpression, [number, number]] | void} parsed\n\t\t\t\t */\n\t\t\t\tconst parseModuleUrl = (parser, expr) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\texpr.type !== \"NewExpression\" ||\n\t\t\t\t\t\texpr.callee.type === \"Super\" ||\n\t\t\t\t\t\texpr.arguments.length !== 2\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst callee = parser.evaluateExpression(expr.callee);\n\t\t\t\t\tif (!callee.isIdentifier() || callee.identifier !== \"URL\") return;\n\t\t\t\t\tconst arg2Value = parser.evaluateExpression(arg2);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!arg2Value.isString() ||\n\t\t\t\t\t\t!(/** @type {string} */ (arg2Value.string).startsWith(\"file://\")) ||\n\t\t\t\t\t\targ2Value.string !== getUrl(parser.state.module)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst arg1Value = parser.evaluateExpression(arg1);\n\t\t\t\t\treturn [\n\t\t\t\t\t\targ1Value,\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t/** @type {Range} */ (arg1.range)[0],\n\t\t\t\t\t\t\t/** @type {Range} */ (arg2.range)[1]\n\t\t\t\t\t\t]\n\t\t\t\t\t];\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {ObjectExpression} expr expression\n\t\t\t\t * @returns {{ expressions: Record<string, Expression | Pattern>, otherElements: (Property | SpreadElement)[], values: Record<string, any>, spread: boolean, insertType: \"comma\" | \"single\", insertLocation: number }} parsed object\n\t\t\t\t */\n\t\t\t\tconst parseObjectExpression = (parser, expr) => {\n\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\tconst values = {};\n\t\t\t\t\t/** @type {Record<string, Expression | Pattern>} */\n\t\t\t\t\tconst expressions = {};\n\t\t\t\t\t/** @type {(Property | SpreadElement)[]} */\n\t\t\t\t\tconst otherElements = [];\n\t\t\t\t\tlet spread = false;\n\t\t\t\t\tfor (const prop of expr.properties) {\n\t\t\t\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\t\t\t\tspread = true;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tprop.type === \"Property\" &&\n\t\t\t\t\t\t\t!prop.method &&\n\t\t\t\t\t\t\t!prop.computed &&\n\t\t\t\t\t\t\tprop.key.type === \"Identifier\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\texpressions[prop.key.name] = prop.value;\n\t\t\t\t\t\t\tif (!prop.shorthand && !prop.value.type.endsWith(\"Pattern\")) {\n\t\t\t\t\t\t\t\tconst value = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (value.isCompileTimeValue())\n\t\t\t\t\t\t\t\t\tvalues[prop.key.name] = value.asCompileTimeValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\totherElements.push(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst insertType = expr.properties.length > 0 ? \"comma\" : \"single\";\n\t\t\t\t\tconst insertLocation =\n\t\t\t\t\t\texpr.properties[expr.properties.length - 1].range[1];\n\t\t\t\t\treturn {\n\t\t\t\t\t\texpressions,\n\t\t\t\t\t\totherElements,\n\t\t\t\t\t\tvalues,\n\t\t\t\t\t\tspread,\n\t\t\t\t\t\tinsertType,\n\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Parser} parser parser parser\n\t\t\t\t * @param {JavascriptParserOptions} parserOptions parserOptions\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst parserPlugin = (parser, parserOptions) => {\n\t\t\t\t\tif (parserOptions.worker === false) return;\n\t\t\t\t\tconst options = !Array.isArray(parserOptions.worker)\n\t\t\t\t\t\t? [\"...\"]\n\t\t\t\t\t\t: parserOptions.worker;\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CallExpression} expr expression\n\t\t\t\t\t * @returns {boolean | void} true when handled\n\t\t\t\t\t */\n\t\t\t\t\tconst handleNewWorker = expr => {\n\t\t\t\t\t\tif (expr.arguments.length === 0 || expr.arguments.length > 2)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\t\t\tif (arg2 && arg2.type === \"SpreadElement\") return;\n\t\t\t\t\t\tconst parsedUrl = parseModuleUrl(parser, arg1);\n\t\t\t\t\t\tif (!parsedUrl) return;\n\t\t\t\t\t\tconst [url, range] = parsedUrl;\n\t\t\t\t\t\tif (!url.isString()) return;\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\texpressions,\n\t\t\t\t\t\t\totherElements,\n\t\t\t\t\t\t\tvalues: options,\n\t\t\t\t\t\t\tspread: hasSpreadInOptions,\n\t\t\t\t\t\t\tinsertType,\n\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t} = arg2 && arg2.type === \"ObjectExpression\"\n\t\t\t\t\t\t\t? parseObjectExpression(parser, arg2)\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, Expression | Pattern>} */\n\t\t\t\t\t\t\t\t\texpressions: {},\n\t\t\t\t\t\t\t\t\totherElements: [],\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\t\t\t\t\tvalues: {},\n\t\t\t\t\t\t\t\t\tspread: false,\n\t\t\t\t\t\t\t\t\tinsertType: arg2 ? \"spread\" : \"argument\",\n\t\t\t\t\t\t\t\t\tinsertLocation: arg2\n\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (arg2.range)\n\t\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (arg1.range)[1]\n\t\t\t\t\t\t\t  };\n\t\t\t\t\t\tconst { options: importOptions, errors: commentErrors } =\n\t\t\t\t\t\t\tparser.parseCommentOptions(/** @type {Range} */ (expr.range));\n\n\t\t\t\t\t\tif (commentErrors) {\n\t\t\t\t\t\t\tfor (const e of commentErrors) {\n\t\t\t\t\t\t\t\tconst { comment } = e;\n\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\tnew CommentCompilationWarning(\n\t\t\t\t\t\t\t\t\t\t`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,\n\t\t\t\t\t\t\t\t\t\tcomment.loc\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {EntryOptions} */\n\t\t\t\t\t\tlet entryOptions = {};\n\n\t\t\t\t\t\tif (importOptions) {\n\t\t\t\t\t\t\tif (importOptions.webpackIgnore !== undefined) {\n\t\t\t\t\t\t\t\tif (typeof importOptions.webpackIgnore !== \"boolean\") {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackIgnore\\` expected a boolean, but received: ${importOptions.webpackIgnore}.`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (importOptions.webpackIgnore) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (importOptions.webpackEntryOptions !== undefined) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\ttypeof importOptions.webpackEntryOptions !== \"object\" ||\n\t\t\t\t\t\t\t\t\timportOptions.webpackEntryOptions === null\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackEntryOptions\\` expected a object, but received: ${importOptions.webpackEntryOptions}.`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\t\t\t\t\timportOptions.webpackEntryOptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (importOptions.webpackChunkName !== undefined) {\n\t\t\t\t\t\t\t\tif (typeof importOptions.webpackChunkName !== \"string\") {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackChunkName\\` expected a string, but received: ${importOptions.webpackChunkName}.`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tentryOptions.name = importOptions.webpackChunkName;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!Object.prototype.hasOwnProperty.call(entryOptions, \"name\") &&\n\t\t\t\t\t\t\toptions &&\n\t\t\t\t\t\t\ttypeof options.name === \"string\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tentryOptions.name = options.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (entryOptions.runtime === undefined) {\n\t\t\t\t\t\t\tlet i = workerIndexMap.get(parser.state) || 0;\n\t\t\t\t\t\t\tworkerIndexMap.set(parser.state, i + 1);\n\t\t\t\t\t\t\tlet name = `${cachedContextify(\n\t\t\t\t\t\t\t\tparser.state.module.identifier()\n\t\t\t\t\t\t\t)}|${i}`;\n\t\t\t\t\t\t\tconst hash = createHash(compilation.outputOptions.hashFunction);\n\t\t\t\t\t\t\thash.update(name);\n\t\t\t\t\t\t\tconst digest = /** @type {string} */ (\n\t\t\t\t\t\t\t\thash.digest(compilation.outputOptions.hashDigest)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tentryOptions.runtime = digest.slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashDigestLength\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst block = new AsyncDependenciesBlock({\n\t\t\t\t\t\t\tname: entryOptions.name,\n\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\tchunkLoading: this._chunkLoading,\n\t\t\t\t\t\t\t\twasmLoading: this._wasmLoading,\n\t\t\t\t\t\t\t\t...entryOptions\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tblock.loc = expr.loc;\n\t\t\t\t\t\tconst dep = new WorkerDependency(\n\t\t\t\t\t\t\t/** @type {string} */ (url.string),\n\t\t\t\t\t\t\trange,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpublicPath: this._workerPublicPath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\tblock.addDependency(dep);\n\t\t\t\t\t\tparser.state.module.addBlock(block);\n\n\t\t\t\t\t\tif (compilation.outputOptions.trustedTypes) {\n\t\t\t\t\t\t\tconst dep = new CreateScriptUrlDependency(\n\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.arguments[0].range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expressions.type) {\n\t\t\t\t\t\t\tconst expr = expressions.type;\n\t\t\t\t\t\t\tif (options.type !== false) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\tthis._module ? '\"module\"' : \"undefined\",\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\texpressions.type = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (insertType === \"comma\") {\n\t\t\t\t\t\t\tif (this._module || hasSpreadInOptions) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t`, type: ${this._module ? '\"module\"' : \"undefined\"}`,\n\t\t\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (insertType === \"spread\") {\n\t\t\t\t\t\t\tconst dep1 = new ConstDependency(\n\t\t\t\t\t\t\t\t\"Object.assign({}, \",\n\t\t\t\t\t\t\t\t/** @type {Range} */ (insertLocation)[0]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst dep2 = new ConstDependency(\n\t\t\t\t\t\t\t\t`, { type: ${this._module ? '\"module\"' : \"undefined\"} })`,\n\t\t\t\t\t\t\t\t/** @type {Range} */ (insertLocation)[1]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep1.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\tdep2.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep1);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep2);\n\t\t\t\t\t\t} else if (insertType === \"argument\") {\n\t\t\t\t\t\t\tif (this._module) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t', { type: \"module\" }',\n\t\t\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparser.walkExpression(expr.callee);\n\t\t\t\t\t\tfor (const key of Object.keys(expressions)) {\n\t\t\t\t\t\t\tif (expressions[key]) parser.walkExpression(expressions[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const prop of otherElements) {\n\t\t\t\t\t\t\tparser.walkProperty(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insertType === \"spread\") {\n\t\t\t\t\t\t\tparser.walkExpression(arg2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} item item\n\t\t\t\t\t */\n\t\t\t\t\tconst processItem = item => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\titem.startsWith(\"*\") &&\n\t\t\t\t\t\t\titem.includes(\".\") &&\n\t\t\t\t\t\t\titem.endsWith(\"()\")\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst firstDot = item.indexOf(\".\");\n\t\t\t\t\t\t\tconst pattern = item.slice(1, firstDot);\n\t\t\t\t\t\t\tconst itemMembers = item.slice(firstDot + 1, -2);\n\n\t\t\t\t\t\t\tparser.hooks.pattern.for(pattern).tap(PLUGIN_NAME, pattern => {\n\t\t\t\t\t\t\t\tparser.tagVariable(pattern.name, WorkerSpecifierTag);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.callMemberChain\n\t\t\t\t\t\t\t\t.for(WorkerSpecifierTag)\n\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, (expression, members) => {\n\t\t\t\t\t\t\t\t\tif (itemMembers !== members.join(\".\")) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn handleNewWorker(expression);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (item.endsWith(\"()\")) {\n\t\t\t\t\t\t\tparser.hooks.call\n\t\t\t\t\t\t\t\t.for(item.slice(0, -2))\n\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, handleNewWorker);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst match = /^(.+?)(\\(\\))?\\s+from\\s+(.+)$/.exec(item);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\tconst ids = match[1].split(\".\");\n\t\t\t\t\t\t\t\tconst call = match[2];\n\t\t\t\t\t\t\t\tconst source = match[3];\n\t\t\t\t\t\t\t\t(call ? parser.hooks.call : parser.hooks.new)\n\t\t\t\t\t\t\t\t\t.for(harmonySpecifierTag)\n\t\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t\t\t\tconst settings = /** @type {HarmonySettings} */ (\n\t\t\t\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!settings ||\n\t\t\t\t\t\t\t\t\t\t\tsettings.source !== source ||\n\t\t\t\t\t\t\t\t\t\t\t!equals(settings.ids, ids)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn handleNewWorker(expr);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.hooks.new.for(item).tap(PLUGIN_NAME, handleNewWorker);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tfor (const item of options) {\n\t\t\t\t\t\tif (item === \"...\") {\n\t\t\t\t\t\t\tDEFAULT_SYNTAX.forEach(processItem);\n\t\t\t\t\t\t} else processItem(item);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, parserPlugin);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, parserPlugin);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = WorkerPlugin;\n"]},"metadata":{},"sourceType":"script"}