{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  fileURLToPath\n} = require(\"url\");\n\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst BasicEvaluatedExpression = require(\"../javascript/BasicEvaluatedExpression\");\n\nconst {\n  evaluateToIdentifier,\n  evaluateToString,\n  expressionIsUnsupported,\n  toConstantDependency\n} = require(\"../javascript/JavascriptParserHelpers\");\n\nconst CommonJsFullRequireDependency = require(\"./CommonJsFullRequireDependency\");\n\nconst CommonJsRequireContextDependency = require(\"./CommonJsRequireContextDependency\");\n\nconst CommonJsRequireDependency = require(\"./CommonJsRequireDependency\");\n\nconst ConstDependency = require(\"./ConstDependency\");\n\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\n\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\n\nconst {\n  getLocalModule\n} = require(\"./LocalModulesHelpers\");\n\nconst RequireHeaderDependency = require(\"./RequireHeaderDependency\");\n\nconst RequireResolveContextDependency = require(\"./RequireResolveContextDependency\");\n\nconst RequireResolveDependency = require(\"./RequireResolveDependency\");\n\nconst RequireResolveHeaderDependency = require(\"./RequireResolveHeaderDependency\");\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n\n/** @typedef {import(\"estree\").Expression} Expression */\n\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"../javascript/JavascriptParser\").ImportSource} ImportSource */\n\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n\nconst createRequireSpecifierTag = Symbol(\"createRequire\");\nconst createdRequireIdentifierTag = Symbol(\"createRequire()\");\n\nclass CommonJsImportsParserPlugin {\n  /**\n   * @param {JavascriptParserOptions} options parser options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n\n\n  apply(parser) {\n    const options = this.options;\n\n    const getContext = () => {\n      if (parser.currentTagData) {\n        const {\n          context\n        } = parser.currentTagData;\n        return context;\n      }\n    }; //#region metadata\n\n    /**\n     * @param {TODO} expression expression\n     * @param {() => string[]} getMembers get members\n     */\n\n\n    const tapRequireExpression = (expression, getMembers) => {\n      parser.hooks.typeof.for(expression).tap(\"CommonJsImportsParserPlugin\", toConstantDependency(parser, JSON.stringify(\"function\")));\n      parser.hooks.evaluateTypeof.for(expression).tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n      parser.hooks.evaluateIdentifier.for(expression).tap(\"CommonJsImportsParserPlugin\", evaluateToIdentifier(expression, \"require\", getMembers, true));\n    };\n    /**\n     * @param {string | symbol} tag tag\n     */\n\n\n    const tapRequireExpressionTag = tag => {\n      parser.hooks.typeof.for(tag).tap(\"CommonJsImportsParserPlugin\", toConstantDependency(parser, JSON.stringify(\"function\")));\n      parser.hooks.evaluateTypeof.for(tag).tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n    };\n\n    tapRequireExpression(\"require\", () => []);\n    tapRequireExpression(\"require.resolve\", () => [\"resolve\"]);\n    tapRequireExpression(\"require.resolveWeak\", () => [\"resolveWeak\"]); //#endregion\n    // Weird stuff //\n\n    parser.hooks.assign.for(\"require\").tap(\"CommonJsImportsParserPlugin\", expr => {\n      // to not leak to global \"require\", we need to define a local require here.\n      const dep = new ConstDependency(\"var require;\", 0);\n      dep.loc =\n      /** @type {DependencyLocation} */\n      expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }); //#region Unsupported\n\n    parser.hooks.expression.for(\"require.main\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"require.main is not supported by webpack.\"));\n    parser.hooks.call.for(\"require.main.require\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"require.main.require is not supported by webpack.\"));\n    parser.hooks.expression.for(\"module.parent.require\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"module.parent.require is not supported by webpack.\"));\n    parser.hooks.call.for(\"module.parent.require\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"module.parent.require is not supported by webpack.\")); //#endregion\n    //#region Renaming\n\n    /**\n     * @param {Expression} expr expression\n     * @returns {boolean} true when set undefined\n     */\n\n    const defineUndefined = expr => {\n      // To avoid \"not defined\" error, replace the value with undefined\n      const dep = new ConstDependency(\"undefined\",\n      /** @type {Range} */\n      expr.range);\n      dep.loc =\n      /** @type {DependencyLocation} */\n      expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return false;\n    };\n\n    parser.hooks.canRename.for(\"require\").tap(\"CommonJsImportsParserPlugin\", () => true);\n    parser.hooks.rename.for(\"require\").tap(\"CommonJsImportsParserPlugin\", defineUndefined); //#endregion\n    //#region Inspection\n\n    const requireCache = toConstantDependency(parser, RuntimeGlobals.moduleCache, [RuntimeGlobals.moduleCache, RuntimeGlobals.moduleId, RuntimeGlobals.moduleLoaded]);\n    parser.hooks.expression.for(\"require.cache\").tap(\"CommonJsImportsParserPlugin\", requireCache); //#endregion\n    //#region Require as expression\n\n    /**\n     * @param {Expression} expr expression\n     * @returns {boolean} true when handled\n     */\n\n    const requireAsExpressionHandler = expr => {\n      const dep = new CommonJsRequireContextDependency({\n        request: options.unknownContextRequest,\n        recursive: options.unknownContextRecursive,\n        regExp: options.unknownContextRegExp,\n        mode: \"sync\"\n      },\n      /** @type {Range} */\n      expr.range, undefined, parser.scope.inShorthand, getContext());\n      dep.critical = options.unknownContextCritical && \"require function is used in a way in which dependencies cannot be statically extracted\";\n      dep.loc =\n      /** @type {DependencyLocation} */\n      expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    };\n\n    parser.hooks.expression.for(\"require\").tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler); //#endregion\n    //#region Require\n\n    /**\n     * @param {CallExpression | NewExpression} expr expression\n     * @param {BasicEvaluatedExpression} param param\n     * @returns {boolean | void} true when handled\n     */\n\n    const processRequireItem = (expr, param) => {\n      if (param.isString()) {\n        const dep = new CommonJsRequireDependency(\n        /** @type {string} */\n        param.string,\n        /** @type {Range} */\n        param.range, getContext());\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression | NewExpression} expr expression\n     * @param {BasicEvaluatedExpression} param param\n     * @returns {boolean | void} true when handled\n     */\n\n\n    const processRequireContext = (expr, param) => {\n      const dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency,\n      /** @type {Range} */\n      expr.range, param, expr, options, {\n        category: \"commonjs\"\n      }, parser, undefined, getContext());\n      if (!dep) return;\n      dep.loc =\n      /** @type {DependencyLocation} */\n      expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    };\n    /**\n     * @param {boolean} callNew true, when require is called with new\n     * @returns {(expr: CallExpression | NewExpression) => (boolean | void)} handler\n     */\n\n\n    const createRequireHandler = callNew => expr => {\n      if (options.commonjsMagicComments) {\n        const {\n          options: requireOptions,\n          errors: commentErrors\n        } = parser.parseCommentOptions(\n        /** @type {Range} */\n        expr.range);\n\n        if (commentErrors) {\n          for (const e of commentErrors) {\n            const {\n              comment\n            } = e;\n            parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));\n          }\n        }\n\n        if (requireOptions) {\n          if (requireOptions.webpackIgnore !== undefined) {\n            if (typeof requireOptions.webpackIgnore !== \"boolean\") {\n              parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackIgnore\\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`,\n              /** @type {DependencyLocation} */\n              expr.loc));\n            } else {\n              // Do not instrument `require()` if `webpackIgnore` is `true`\n              if (requireOptions.webpackIgnore) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      if (expr.arguments.length !== 1) return;\n      let localModule;\n      const param = parser.evaluateExpression(expr.arguments[0]);\n\n      if (param.isConditional()) {\n        let isExpression = false;\n\n        for (const p of\n        /** @type {BasicEvaluatedExpression[]} */\n        param.options) {\n          const result = processRequireItem(expr, p);\n\n          if (result === undefined) {\n            isExpression = true;\n          }\n        }\n\n        if (!isExpression) {\n          const dep = new RequireHeaderDependency(\n          /** @type {Range} */\n          expr.callee.range);\n          dep.loc =\n          /** @type {DependencyLocation} */\n          expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n          return true;\n        }\n      }\n\n      if (param.isString() && (localModule = getLocalModule(parser.state,\n      /** @type {string} */\n      param.string))) {\n        localModule.flagUsed();\n        const dep = new LocalModuleDependency(localModule,\n        /** @type {Range} */\n        expr.range, callNew);\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      } else {\n        const result = processRequireItem(expr, param);\n\n        if (result === undefined) {\n          processRequireContext(expr, param);\n        } else {\n          const dep = new RequireHeaderDependency(\n          /** @type {Range} */\n          expr.callee.range);\n          dep.loc =\n          /** @type {DependencyLocation} */\n          expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n        }\n\n        return true;\n      }\n    };\n\n    parser.hooks.call.for(\"require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n    parser.hooks.new.for(\"require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n    parser.hooks.call.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n    parser.hooks.new.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true)); //#endregion\n    //#region Require with property access\n\n    /**\n     * @param {Expression} expr expression\n     * @param {string[]} calleeMembers callee members\n     * @param {CallExpression} callExpr call expression\n     * @param {string[]} members members\n     * @param {Range[]} memberRanges member ranges\n     * @returns {boolean | void} true when handled\n     */\n\n    const chainHandler = (expr, calleeMembers, callExpr, members, memberRanges) => {\n      if (callExpr.arguments.length !== 1) return;\n      const param = parser.evaluateExpression(callExpr.arguments[0]);\n\n      if (param.isString() && !getLocalModule(parser.state,\n      /** @type {string} */\n      param.string)) {\n        const dep = new CommonJsFullRequireDependency(\n        /** @type {string} */\n        param.string,\n        /** @type {Range} */\n        expr.range, members,\n        /** @type {Range[]} */\n        memberRanges);\n        dep.asiSafe = !parser.isAsiPosition(\n        /** @type {Range} */\n        expr.range[0]);\n        dep.optional = !!parser.scope.inTry;\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression} expr expression\n     * @param {string[]} calleeMembers callee members\n     * @param {CallExpression} callExpr call expression\n     * @param {string[]} members members\n     * @param {Range[]} memberRanges member ranges\n     * @returns {boolean | void} true when handled\n     */\n\n\n    const callChainHandler = (expr, calleeMembers, callExpr, members, memberRanges) => {\n      if (callExpr.arguments.length !== 1) return;\n      const param = parser.evaluateExpression(callExpr.arguments[0]);\n\n      if (param.isString() && !getLocalModule(parser.state,\n      /** @type {string} */\n      param.string)) {\n        const dep = new CommonJsFullRequireDependency(\n        /** @type {string} */\n        param.string,\n        /** @type {Range} */\n        expr.callee.range, members,\n        /** @type {Range[]} */\n        memberRanges);\n        dep.call = true;\n        dep.asiSafe = !parser.isAsiPosition(\n        /** @type {Range} */\n        expr.range[0]);\n        dep.optional = !!parser.scope.inTry;\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.callee.loc;\n        parser.state.current.addDependency(dep);\n        parser.walkExpressions(expr.arguments);\n        return true;\n      }\n    };\n\n    parser.hooks.memberChainOfCallMemberChain.for(\"require\").tap(\"CommonJsImportsParserPlugin\", chainHandler);\n    parser.hooks.memberChainOfCallMemberChain.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", chainHandler);\n    parser.hooks.callMemberChainOfCallMemberChain.for(\"require\").tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n    parser.hooks.callMemberChainOfCallMemberChain.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", callChainHandler); //#endregion\n    //#region Require.resolve\n\n    /**\n     * @param {CallExpression} expr call expression\n     * @param {boolean} weak weak\n     * @returns {boolean | void} true when handled\n     */\n\n    const processResolve = (expr, weak) => {\n      if (expr.arguments.length !== 1) return;\n      const param = parser.evaluateExpression(expr.arguments[0]);\n\n      if (param.isConditional()) {\n        for (const option of\n        /** @type {BasicEvaluatedExpression[]} */\n        param.options) {\n          const result = processResolveItem(expr, option, weak);\n\n          if (result === undefined) {\n            processResolveContext(expr, option, weak);\n          }\n        }\n\n        const dep = new RequireResolveHeaderDependency(\n        /** @type {Range} */\n        expr.callee.range);\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      } else {\n        const result = processResolveItem(expr, param, weak);\n\n        if (result === undefined) {\n          processResolveContext(expr, param, weak);\n        }\n\n        const dep = new RequireResolveHeaderDependency(\n        /** @type {Range} */\n        expr.callee.range);\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression} expr call expression\n     * @param {BasicEvaluatedExpression} param param\n     * @param {boolean} weak weak\n     * @returns {boolean | void} true when handled\n     */\n\n\n    const processResolveItem = (expr, param, weak) => {\n      if (param.isString()) {\n        const dep = new RequireResolveDependency(\n        /** @type {string} */\n        param.string,\n        /** @type {Range} */\n        param.range, getContext());\n        dep.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        dep.weak = weak;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression} expr call expression\n     * @param {BasicEvaluatedExpression} param param\n     * @param {boolean} weak weak\n     * @returns {boolean | void} true when handled\n     */\n\n\n    const processResolveContext = (expr, param, weak) => {\n      const dep = ContextDependencyHelpers.create(RequireResolveContextDependency,\n      /** @type {Range} */\n      param.range, param, expr, options, {\n        category: \"commonjs\",\n        mode: weak ? \"weak\" : \"sync\"\n      }, parser, getContext());\n      if (!dep) return;\n      dep.loc =\n      /** @type {DependencyLocation} */\n      expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    };\n\n    parser.hooks.call.for(\"require.resolve\").tap(\"CommonJsImportsParserPlugin\", expr => {\n      return processResolve(expr, false);\n    });\n    parser.hooks.call.for(\"require.resolveWeak\").tap(\"CommonJsImportsParserPlugin\", expr => {\n      return processResolve(expr, true);\n    }); //#endregion\n    //#region Create require\n\n    if (!options.createRequire) return;\n    /** @type {ImportSource[]} */\n\n    let moduleName = [];\n    /** @type {string | undefined} */\n\n    let specifierName;\n\n    if (options.createRequire === true) {\n      moduleName = [\"module\", \"node:module\"];\n      specifierName = \"createRequire\";\n    } else {\n      let moduleName;\n      const match = /^(.*) from (.*)$/.exec(options.createRequire);\n\n      if (match) {\n        [, specifierName, moduleName] = match;\n      }\n\n      if (!specifierName || !moduleName) {\n        const err = new WebpackError(`Parsing javascript parser option \"createRequire\" failed, got ${JSON.stringify(options.createRequire)}`);\n        err.details = 'Expected string in format \"createRequire from module\", where \"createRequire\" is specifier name and \"module\" name of the module';\n        throw err;\n      }\n    }\n\n    tapRequireExpressionTag(createdRequireIdentifierTag);\n    tapRequireExpressionTag(createRequireSpecifierTag);\n    parser.hooks.evaluateCallExpression.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", expr => {\n      const context = parseCreateRequireArguments(expr);\n      if (context === undefined) return;\n      const ident = parser.evaluatedVariable({\n        tag: createdRequireIdentifierTag,\n        data: {\n          context\n        },\n        next: undefined\n      });\n      return new BasicEvaluatedExpression().setIdentifier(\n      /** @type {TODO} */\n      ident,\n      /** @type {TODO} */\n      ident, () => []).setSideEffects(false).setRange(\n      /** @type {Range} */\n      expr.range);\n    });\n    parser.hooks.unhandledExpressionMemberChain.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n      return expressionIsUnsupported(parser, `createRequire().${members.join(\".\")} is not supported by webpack.`)(expr);\n    });\n    parser.hooks.canRename.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", () => true);\n    parser.hooks.canRename.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", () => true);\n    parser.hooks.rename.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n    parser.hooks.expression.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n    parser.hooks.call.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n    /**\n     * @param {CallExpression} expr call expression\n     * @returns {string | void} context\n     */\n\n    const parseCreateRequireArguments = expr => {\n      const args = expr.arguments;\n\n      if (args.length !== 1) {\n        const err = new WebpackError(\"module.createRequire supports only one argument.\");\n        err.loc =\n        /** @type {DependencyLocation} */\n        expr.loc;\n        parser.state.module.addWarning(err);\n        return;\n      }\n\n      const arg = args[0];\n      const evaluated = parser.evaluateExpression(arg);\n\n      if (!evaluated.isString()) {\n        const err = new WebpackError(\"module.createRequire failed parsing argument.\");\n        err.loc =\n        /** @type {DependencyLocation} */\n        arg.loc;\n        parser.state.module.addWarning(err);\n        return;\n      }\n\n      const ctx =\n      /** @type {string} */\n      evaluated.string.startsWith(\"file://\") ? fileURLToPath(\n      /** @type {string} */\n      evaluated.string) :\n      /** @type {string} */\n      evaluated.string; // argument always should be a filename\n\n      return ctx.slice(0, ctx.lastIndexOf(ctx.startsWith(\"/\") ? \"/\" : \"\\\\\"));\n    };\n\n    parser.hooks.import.tap({\n      name: \"CommonJsImportsParserPlugin\",\n      stage: -10\n    }, (statement, source) => {\n      if (!moduleName.includes(source) || statement.specifiers.length !== 1 || statement.specifiers[0].type !== \"ImportSpecifier\" || statement.specifiers[0].imported.type !== \"Identifier\" || statement.specifiers[0].imported.name !== specifierName) return; // clear for 'import { createRequire as x } from \"module\"'\n      // if any other specifier was used import module\n\n      const clearDep = new ConstDependency(parser.isAsiPosition(\n      /** @type {Range} */\n      statement.range[0]) ? \";\" : \"\",\n      /** @type {Range} */\n      statement.range);\n      clearDep.loc =\n      /** @type {DependencyLocation} */\n      statement.loc;\n      parser.state.module.addPresentationalDependency(clearDep);\n      parser.unsetAsiPosition(\n      /** @type {Range} */\n      statement.range[1]);\n      return true;\n    });\n    parser.hooks.importSpecifier.tap({\n      name: \"CommonJsImportsParserPlugin\",\n      stage: -10\n    }, (statement, source, id, name) => {\n      if (!moduleName.includes(source) || id !== specifierName) return;\n      parser.tagVariable(name, createRequireSpecifierTag);\n      return true;\n    });\n    parser.hooks.preDeclarator.tap(\"CommonJsImportsParserPlugin\", declarator => {\n      if (declarator.id.type !== \"Identifier\" || !declarator.init || declarator.init.type !== \"CallExpression\" || declarator.init.callee.type !== \"Identifier\") return;\n      const variableInfo =\n      /** @type {TODO} */\n      parser.getVariableInfo(declarator.init.callee.name);\n\n      if (variableInfo && variableInfo.tagInfo && variableInfo.tagInfo.tag === createRequireSpecifierTag) {\n        const context = parseCreateRequireArguments(declarator.init);\n        if (context === undefined) return;\n        parser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {\n          name: declarator.id.name,\n          context\n        });\n        return true;\n      }\n    });\n    parser.hooks.memberChainOfCallMemberChain.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, calleeMembers, callExpr, members) => {\n      if (calleeMembers.length !== 0 || members.length !== 1 || members[0] !== \"cache\") return; // createRequire().cache\n\n      const context = parseCreateRequireArguments(callExpr);\n      if (context === undefined) return;\n      return requireCache(expr);\n    });\n    parser.hooks.callMemberChainOfCallMemberChain.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, calleeMembers, innerCallExpression, members) => {\n      if (calleeMembers.length !== 0 || members.length !== 1 || members[0] !== \"resolve\") return; // createRequire().resolve()\n\n      return processResolve(expr, false);\n    });\n    parser.hooks.expressionMemberChain.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n      // require.cache\n      if (members.length === 1 && members[0] === \"cache\") {\n        return requireCache(expr);\n      }\n    });\n    parser.hooks.callMemberChain.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n      // require.resolve()\n      if (members.length === 1 && members[0] === \"resolve\") {\n        return processResolve(expr, false);\n      }\n    });\n    parser.hooks.call.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", expr => {\n      const clearDep = new ConstDependency(\"/* createRequire() */ undefined\",\n      /** @type {Range} */\n      expr.range);\n      clearDep.loc =\n      /** @type {DependencyLocation} */\n      expr.loc;\n      parser.state.module.addPresentationalDependency(clearDep);\n      return true;\n    }); //#endregion\n  }\n\n}\n\nmodule.exports = CommonJsImportsParserPlugin;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/dependencies/CommonJsImportsParserPlugin.js"],"names":["fileURLToPath","require","CommentCompilationWarning","RuntimeGlobals","UnsupportedFeatureWarning","WebpackError","BasicEvaluatedExpression","evaluateToIdentifier","evaluateToString","expressionIsUnsupported","toConstantDependency","CommonJsFullRequireDependency","CommonJsRequireContextDependency","CommonJsRequireDependency","ConstDependency","ContextDependencyHelpers","LocalModuleDependency","getLocalModule","RequireHeaderDependency","RequireResolveContextDependency","RequireResolveDependency","RequireResolveHeaderDependency","createRequireSpecifierTag","Symbol","createdRequireIdentifierTag","CommonJsImportsParserPlugin","constructor","options","apply","parser","getContext","currentTagData","context","tapRequireExpression","expression","getMembers","hooks","typeof","for","tap","JSON","stringify","evaluateTypeof","evaluateIdentifier","tapRequireExpressionTag","tag","assign","expr","dep","loc","state","module","addPresentationalDependency","call","defineUndefined","range","canRename","rename","requireCache","moduleCache","moduleId","moduleLoaded","requireAsExpressionHandler","request","unknownContextRequest","recursive","unknownContextRecursive","regExp","unknownContextRegExp","mode","undefined","scope","inShorthand","critical","unknownContextCritical","optional","inTry","current","addDependency","processRequireItem","param","isString","string","processRequireContext","create","category","createRequireHandler","callNew","commonjsMagicComments","requireOptions","errors","commentErrors","parseCommentOptions","e","comment","addWarning","value","message","webpackIgnore","arguments","length","localModule","evaluateExpression","isConditional","isExpression","p","result","callee","flagUsed","new","chainHandler","calleeMembers","callExpr","members","memberRanges","asiSafe","isAsiPosition","callChainHandler","walkExpressions","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","processResolve","weak","option","processResolveItem","processResolveContext","createRequire","moduleName","specifierName","match","exec","err","details","evaluateCallExpression","parseCreateRequireArguments","ident","evaluatedVariable","data","next","setIdentifier","setSideEffects","setRange","unhandledExpressionMemberChain","join","args","arg","evaluated","ctx","startsWith","slice","lastIndexOf","import","name","stage","statement","source","includes","specifiers","type","imported","clearDep","unsetAsiPosition","importSpecifier","id","tagVariable","preDeclarator","declarator","init","variableInfo","getVariableInfo","tagInfo","innerCallExpression","expressionMemberChain","callMemberChain","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { fileURLToPath } = require(\"url\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst WebpackError = require(\"../WebpackError\");\nconst BasicEvaluatedExpression = require(\"../javascript/BasicEvaluatedExpression\");\nconst {\n\tevaluateToIdentifier,\n\tevaluateToString,\n\texpressionIsUnsupported,\n\ttoConstantDependency\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst CommonJsFullRequireDependency = require(\"./CommonJsFullRequireDependency\");\nconst CommonJsRequireContextDependency = require(\"./CommonJsRequireContextDependency\");\nconst CommonJsRequireDependency = require(\"./CommonJsRequireDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst { getLocalModule } = require(\"./LocalModulesHelpers\");\nconst RequireHeaderDependency = require(\"./RequireHeaderDependency\");\nconst RequireResolveContextDependency = require(\"./RequireResolveContextDependency\");\nconst RequireResolveDependency = require(\"./RequireResolveDependency\");\nconst RequireResolveHeaderDependency = require(\"./RequireResolveHeaderDependency\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").ImportSource} ImportSource */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\nconst createRequireSpecifierTag = Symbol(\"createRequire\");\nconst createdRequireIdentifierTag = Symbol(\"createRequire()\");\n\nclass CommonJsImportsParserPlugin {\n\t/**\n\t * @param {JavascriptParserOptions} options parser options\n\t */\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tconst options = this.options;\n\n\t\tconst getContext = () => {\n\t\t\tif (parser.currentTagData) {\n\t\t\t\tconst { context } = parser.currentTagData;\n\t\t\t\treturn context;\n\t\t\t}\n\t\t};\n\n\t\t//#region metadata\n\t\t/**\n\t\t * @param {TODO} expression expression\n\t\t * @param {() => string[]} getMembers get members\n\t\t */\n\t\tconst tapRequireExpression = (expression, getMembers) => {\n\t\t\tparser.hooks.typeof\n\t\t\t\t.for(expression)\n\t\t\t\t.tap(\n\t\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"function\"))\n\t\t\t\t);\n\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t.for(expression)\n\t\t\t\t.tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t.for(expression)\n\t\t\t\t.tap(\n\t\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t\tevaluateToIdentifier(expression, \"require\", getMembers, true)\n\t\t\t\t);\n\t\t};\n\t\t/**\n\t\t * @param {string | symbol} tag tag\n\t\t */\n\t\tconst tapRequireExpressionTag = tag => {\n\t\t\tparser.hooks.typeof\n\t\t\t\t.for(tag)\n\t\t\t\t.tap(\n\t\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"function\"))\n\t\t\t\t);\n\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t.for(tag)\n\t\t\t\t.tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n\t\t};\n\t\ttapRequireExpression(\"require\", () => []);\n\t\ttapRequireExpression(\"require.resolve\", () => [\"resolve\"]);\n\t\ttapRequireExpression(\"require.resolveWeak\", () => [\"resolveWeak\"]);\n\t\t//#endregion\n\n\t\t// Weird stuff //\n\t\tparser.hooks.assign\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\t// to not leak to global \"require\", we need to define a local require here.\n\t\t\t\tconst dep = new ConstDependency(\"var require;\", 0);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t//#region Unsupported\n\t\tparser.hooks.expression\n\t\t\t.for(\"require.main\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"require.main is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\tparser.hooks.call\n\t\t\t.for(\"require.main.require\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"require.main.require is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\tparser.hooks.expression\n\t\t\t.for(\"module.parent.require\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"module.parent.require is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\tparser.hooks.call\n\t\t\t.for(\"module.parent.require\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"module.parent.require is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\t//#endregion\n\n\t\t//#region Renaming\n\t\t/**\n\t\t * @param {Expression} expr expression\n\t\t * @returns {boolean} true when set undefined\n\t\t */\n\t\tconst defineUndefined = expr => {\n\t\t\t// To avoid \"not defined\" error, replace the value with undefined\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\"undefined\",\n\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t);\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn false;\n\t\t};\n\t\tparser.hooks.canRename\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", () => true);\n\t\tparser.hooks.rename\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n\t\t//#endregion\n\n\t\t//#region Inspection\n\t\tconst requireCache = toConstantDependency(\n\t\t\tparser,\n\t\t\tRuntimeGlobals.moduleCache,\n\t\t\t[\n\t\t\t\tRuntimeGlobals.moduleCache,\n\t\t\t\tRuntimeGlobals.moduleId,\n\t\t\t\tRuntimeGlobals.moduleLoaded\n\t\t\t]\n\t\t);\n\n\t\tparser.hooks.expression\n\t\t\t.for(\"require.cache\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", requireCache);\n\t\t//#endregion\n\n\t\t//#region Require as expression\n\t\t/**\n\t\t * @param {Expression} expr expression\n\t\t * @returns {boolean} true when handled\n\t\t */\n\t\tconst requireAsExpressionHandler = expr => {\n\t\t\tconst dep = new CommonJsRequireContextDependency(\n\t\t\t\t{\n\t\t\t\t\trequest: options.unknownContextRequest,\n\t\t\t\t\trecursive: options.unknownContextRecursive,\n\t\t\t\t\tregExp: options.unknownContextRegExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\tundefined,\n\t\t\t\tparser.scope.inShorthand,\n\t\t\t\tgetContext()\n\t\t\t);\n\t\t\tdep.critical =\n\t\t\t\toptions.unknownContextCritical &&\n\t\t\t\t\"require function is used in a way in which dependencies cannot be statically extracted\";\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.expression\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n\t\t//#endregion\n\n\t\t//#region Require\n\t\t/**\n\t\t * @param {CallExpression | NewExpression} expr expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processRequireItem = (expr, param) => {\n\t\t\tif (param.isString()) {\n\t\t\t\tconst dep = new CommonJsRequireDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (param.range),\n\t\t\t\t\tgetContext()\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression | NewExpression} expr expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processRequireContext = (expr, param) => {\n\t\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\t\tCommonJsRequireContextDependency,\n\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\tparam,\n\t\t\t\texpr,\n\t\t\t\toptions,\n\t\t\t\t{\n\t\t\t\t\tcategory: \"commonjs\"\n\t\t\t\t},\n\t\t\t\tparser,\n\t\t\t\tundefined,\n\t\t\t\tgetContext()\n\t\t\t);\n\t\t\tif (!dep) return;\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {boolean} callNew true, when require is called with new\n\t\t * @returns {(expr: CallExpression | NewExpression) => (boolean | void)} handler\n\t\t */\n\t\tconst createRequireHandler = callNew => expr => {\n\t\t\tif (options.commonjsMagicComments) {\n\t\t\t\tconst { options: requireOptions, errors: commentErrors } =\n\t\t\t\t\tparser.parseCommentOptions(/** @type {Range} */ (expr.range));\n\n\t\t\t\tif (commentErrors) {\n\t\t\t\t\tfor (const e of commentErrors) {\n\t\t\t\t\t\tconst { comment } = e;\n\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\tnew CommentCompilationWarning(\n\t\t\t\t\t\t\t\t`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,\n\t\t\t\t\t\t\t\tcomment.loc\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (requireOptions) {\n\t\t\t\t\tif (requireOptions.webpackIgnore !== undefined) {\n\t\t\t\t\t\tif (typeof requireOptions.webpackIgnore !== \"boolean\") {\n\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t`\\`webpackIgnore\\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`,\n\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Do not instrument `require()` if `webpackIgnore` is `true`\n\t\t\t\t\t\t\tif (requireOptions.webpackIgnore) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\tlet localModule;\n\t\t\tconst param = parser.evaluateExpression(expr.arguments[0]);\n\t\t\tif (param.isConditional()) {\n\t\t\t\tlet isExpression = false;\n\t\t\t\tfor (const p of /** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\t\tparam.options\n\t\t\t\t)) {\n\t\t\t\t\tconst result = processRequireItem(expr, p);\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tisExpression = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isExpression) {\n\t\t\t\t\tconst dep = new RequireHeaderDependency(\n\t\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t\t);\n\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\n\t\t\t\tparam.isString() &&\n\t\t\t\t(localModule = getLocalModule(\n\t\t\t\t\tparser.state,\n\t\t\t\t\t/** @type {string} */ (param.string)\n\t\t\t\t))\n\t\t\t) {\n\t\t\t\tlocalModule.flagUsed();\n\t\t\t\tconst dep = new LocalModuleDependency(\n\t\t\t\t\tlocalModule,\n\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\tcallNew\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst result = processRequireItem(expr, param);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tprocessRequireContext(expr, param);\n\t\t\t\t} else {\n\t\t\t\t\tconst dep = new RequireHeaderDependency(\n\t\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t\t);\n\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tparser.hooks.call\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n\t\tparser.hooks.new\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n\t\tparser.hooks.call\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n\t\tparser.hooks.new\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n\t\t//#endregion\n\n\t\t//#region Require with property access\n\t\t/**\n\t\t * @param {Expression} expr expression\n\t\t * @param {string[]} calleeMembers callee members\n\t\t * @param {CallExpression} callExpr call expression\n\t\t * @param {string[]} members members\n\t\t * @param {Range[]} memberRanges member ranges\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst chainHandler = (\n\t\t\texpr,\n\t\t\tcalleeMembers,\n\t\t\tcallExpr,\n\t\t\tmembers,\n\t\t\tmemberRanges\n\t\t) => {\n\t\t\tif (callExpr.arguments.length !== 1) return;\n\t\t\tconst param = parser.evaluateExpression(callExpr.arguments[0]);\n\t\t\tif (\n\t\t\t\tparam.isString() &&\n\t\t\t\t!getLocalModule(parser.state, /** @type {string} */ (param.string))\n\t\t\t) {\n\t\t\t\tconst dep = new CommonJsFullRequireDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\tmembers,\n\t\t\t\t\t/** @type {Range[]} */ memberRanges\n\t\t\t\t);\n\t\t\t\tdep.asiSafe = !parser.isAsiPosition(\n\t\t\t\t\t/** @type {Range} */ (expr.range)[0]\n\t\t\t\t);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression} expr expression\n\t\t * @param {string[]} calleeMembers callee members\n\t\t * @param {CallExpression} callExpr call expression\n\t\t * @param {string[]} members members\n\t\t * @param {Range[]} memberRanges member ranges\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst callChainHandler = (\n\t\t\texpr,\n\t\t\tcalleeMembers,\n\t\t\tcallExpr,\n\t\t\tmembers,\n\t\t\tmemberRanges\n\t\t) => {\n\t\t\tif (callExpr.arguments.length !== 1) return;\n\t\t\tconst param = parser.evaluateExpression(callExpr.arguments[0]);\n\t\t\tif (\n\t\t\t\tparam.isString() &&\n\t\t\t\t!getLocalModule(parser.state, /** @type {string} */ (param.string))\n\t\t\t) {\n\t\t\t\tconst dep = new CommonJsFullRequireDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range),\n\t\t\t\t\tmembers,\n\t\t\t\t\t/** @type {Range[]} */ memberRanges\n\t\t\t\t);\n\t\t\t\tdep.call = true;\n\t\t\t\tdep.asiSafe = !parser.isAsiPosition(\n\t\t\t\t\t/** @type {Range} */ (expr.range)[0]\n\t\t\t\t);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.callee.loc);\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\tparser.walkExpressions(expr.arguments);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tparser.hooks.memberChainOfCallMemberChain\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", chainHandler);\n\t\tparser.hooks.memberChainOfCallMemberChain\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", chainHandler);\n\t\tparser.hooks.callMemberChainOfCallMemberChain\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n\t\tparser.hooks.callMemberChainOfCallMemberChain\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n\t\t//#endregion\n\n\t\t//#region Require.resolve\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @param {boolean} weak weak\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processResolve = (expr, weak) => {\n\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\tconst param = parser.evaluateExpression(expr.arguments[0]);\n\t\t\tif (param.isConditional()) {\n\t\t\t\tfor (const option of /** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\t\tparam.options\n\t\t\t\t)) {\n\t\t\t\t\tconst result = processResolveItem(expr, option, weak);\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tprocessResolveContext(expr, option, weak);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst dep = new RequireResolveHeaderDependency(\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst result = processResolveItem(expr, param, weak);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tprocessResolveContext(expr, param, weak);\n\t\t\t\t}\n\t\t\t\tconst dep = new RequireResolveHeaderDependency(\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @param {boolean} weak weak\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processResolveItem = (expr, param, weak) => {\n\t\t\tif (param.isString()) {\n\t\t\t\tconst dep = new RequireResolveDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (param.range),\n\t\t\t\t\tgetContext()\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tdep.weak = weak;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @param {boolean} weak weak\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processResolveContext = (expr, param, weak) => {\n\t\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\t\tRequireResolveContextDependency,\n\t\t\t\t/** @type {Range} */ (param.range),\n\t\t\t\tparam,\n\t\t\t\texpr,\n\t\t\t\toptions,\n\t\t\t\t{\n\t\t\t\t\tcategory: \"commonjs\",\n\t\t\t\t\tmode: weak ? \"weak\" : \"sync\"\n\t\t\t\t},\n\t\t\t\tparser,\n\t\t\t\tgetContext()\n\t\t\t);\n\t\t\tif (!dep) return;\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t};\n\n\t\tparser.hooks.call\n\t\t\t.for(\"require.resolve\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\treturn processResolve(expr, false);\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"require.resolveWeak\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\treturn processResolve(expr, true);\n\t\t\t});\n\t\t//#endregion\n\n\t\t//#region Create require\n\n\t\tif (!options.createRequire) return;\n\n\t\t/** @type {ImportSource[]} */\n\t\tlet moduleName = [];\n\t\t/** @type {string | undefined} */\n\t\tlet specifierName;\n\n\t\tif (options.createRequire === true) {\n\t\t\tmoduleName = [\"module\", \"node:module\"];\n\t\t\tspecifierName = \"createRequire\";\n\t\t} else {\n\t\t\tlet moduleName;\n\t\t\tconst match = /^(.*) from (.*)$/.exec(options.createRequire);\n\t\t\tif (match) {\n\t\t\t\t[, specifierName, moduleName] = match;\n\t\t\t}\n\t\t\tif (!specifierName || !moduleName) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t`Parsing javascript parser option \"createRequire\" failed, got ${JSON.stringify(\n\t\t\t\t\t\toptions.createRequire\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t\terr.details =\n\t\t\t\t\t'Expected string in format \"createRequire from module\", where \"createRequire\" is specifier name and \"module\" name of the module';\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\n\t\ttapRequireExpressionTag(createdRequireIdentifierTag);\n\t\ttapRequireExpressionTag(createRequireSpecifierTag);\n\t\tparser.hooks.evaluateCallExpression\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\tconst context = parseCreateRequireArguments(expr);\n\t\t\t\tif (context === undefined) return;\n\t\t\t\tconst ident = parser.evaluatedVariable({\n\t\t\t\t\ttag: createdRequireIdentifierTag,\n\t\t\t\t\tdata: { context },\n\t\t\t\t\tnext: undefined\n\t\t\t\t});\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(\n\t\t\t\t\t\t/** @type {TODO} */ (ident),\n\t\t\t\t\t\t/** @type {TODO} */ (ident),\n\t\t\t\t\t\t() => []\n\t\t\t\t\t)\n\t\t\t\t\t.setSideEffects(false)\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tparser.hooks.unhandledExpressionMemberChain\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn expressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t`createRequire().${members.join(\".\")} is not supported by webpack.`\n\t\t\t\t)(expr);\n\t\t\t});\n\t\tparser.hooks.canRename\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", () => true);\n\t\tparser.hooks.canRename\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", () => true);\n\t\tparser.hooks.rename\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n\t\tparser.hooks.expression\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n\t\tparser.hooks.call\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @returns {string | void} context\n\t\t */\n\t\tconst parseCreateRequireArguments = expr => {\n\t\t\tconst args = expr.arguments;\n\t\t\tif (args.length !== 1) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t\"module.createRequire supports only one argument.\"\n\t\t\t\t);\n\t\t\t\terr.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addWarning(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst arg = args[0];\n\t\t\tconst evaluated = parser.evaluateExpression(arg);\n\t\t\tif (!evaluated.isString()) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t\"module.createRequire failed parsing argument.\"\n\t\t\t\t);\n\t\t\t\terr.loc = /** @type {DependencyLocation} */ (arg.loc);\n\t\t\t\tparser.state.module.addWarning(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst ctx = /** @type {string} */ (evaluated.string).startsWith(\"file://\")\n\t\t\t\t? fileURLToPath(/** @type {string} */ (evaluated.string))\n\t\t\t\t: /** @type {string} */ (evaluated.string);\n\t\t\t// argument always should be a filename\n\t\t\treturn ctx.slice(0, ctx.lastIndexOf(ctx.startsWith(\"/\") ? \"/\" : \"\\\\\"));\n\t\t};\n\n\t\tparser.hooks.import.tap(\n\t\t\t{\n\t\t\t\tname: \"CommonJsImportsParserPlugin\",\n\t\t\t\tstage: -10\n\t\t\t},\n\t\t\t(statement, source) => {\n\t\t\t\tif (\n\t\t\t\t\t!moduleName.includes(source) ||\n\t\t\t\t\tstatement.specifiers.length !== 1 ||\n\t\t\t\t\tstatement.specifiers[0].type !== \"ImportSpecifier\" ||\n\t\t\t\t\tstatement.specifiers[0].imported.type !== \"Identifier\" ||\n\t\t\t\t\tstatement.specifiers[0].imported.name !== specifierName\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\t// clear for 'import { createRequire as x } from \"module\"'\n\t\t\t\t// if any other specifier was used import module\n\t\t\t\tconst clearDep = new ConstDependency(\n\t\t\t\t\tparser.isAsiPosition(/** @type {Range} */ (statement.range)[0])\n\t\t\t\t\t\t? \";\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\t\t/** @type {Range} */ (statement.range)\n\t\t\t\t);\n\t\t\t\tclearDep.loc = /** @type {DependencyLocation} */ (statement.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(clearDep);\n\t\t\t\tparser.unsetAsiPosition(/** @type {Range} */ (statement.range)[1]);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t);\n\t\tparser.hooks.importSpecifier.tap(\n\t\t\t{\n\t\t\t\tname: \"CommonJsImportsParserPlugin\",\n\t\t\t\tstage: -10\n\t\t\t},\n\t\t\t(statement, source, id, name) => {\n\t\t\t\tif (!moduleName.includes(source) || id !== specifierName) return;\n\t\t\t\tparser.tagVariable(name, createRequireSpecifierTag);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t);\n\t\tparser.hooks.preDeclarator.tap(\n\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\tdeclarator => {\n\t\t\t\tif (\n\t\t\t\t\tdeclarator.id.type !== \"Identifier\" ||\n\t\t\t\t\t!declarator.init ||\n\t\t\t\t\tdeclarator.init.type !== \"CallExpression\" ||\n\t\t\t\t\tdeclarator.init.callee.type !== \"Identifier\"\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\tconst variableInfo =\n\t\t\t\t\t/** @type {TODO} */\n\t\t\t\t\t(parser.getVariableInfo(declarator.init.callee.name));\n\t\t\t\tif (\n\t\t\t\t\tvariableInfo &&\n\t\t\t\t\tvariableInfo.tagInfo &&\n\t\t\t\t\tvariableInfo.tagInfo.tag === createRequireSpecifierTag\n\t\t\t\t) {\n\t\t\t\t\tconst context = parseCreateRequireArguments(declarator.init);\n\t\t\t\t\tif (context === undefined) return;\n\t\t\t\t\tparser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {\n\t\t\t\t\t\tname: declarator.id.name,\n\t\t\t\t\t\tcontext\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tparser.hooks.memberChainOfCallMemberChain\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t(expr, calleeMembers, callExpr, members) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcalleeMembers.length !== 0 ||\n\t\t\t\t\t\tmembers.length !== 1 ||\n\t\t\t\t\t\tmembers[0] !== \"cache\"\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// createRequire().cache\n\t\t\t\t\tconst context = parseCreateRequireArguments(callExpr);\n\t\t\t\t\tif (context === undefined) return;\n\t\t\t\t\treturn requireCache(expr);\n\t\t\t\t}\n\t\t\t);\n\t\tparser.hooks.callMemberChainOfCallMemberChain\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t(expr, calleeMembers, innerCallExpression, members) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcalleeMembers.length !== 0 ||\n\t\t\t\t\t\tmembers.length !== 1 ||\n\t\t\t\t\t\tmembers[0] !== \"resolve\"\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// createRequire().resolve()\n\t\t\t\t\treturn processResolve(expr, false);\n\t\t\t\t}\n\t\t\t);\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n\t\t\t\t// require.cache\n\t\t\t\tif (members.length === 1 && members[0] === \"cache\") {\n\t\t\t\t\treturn requireCache(expr);\n\t\t\t\t}\n\t\t\t});\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n\t\t\t\t// require.resolve()\n\t\t\t\tif (members.length === 1 && members[0] === \"resolve\") {\n\t\t\t\t\treturn processResolve(expr, false);\n\t\t\t\t}\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\tconst clearDep = new ConstDependency(\n\t\t\t\t\t\"/* createRequire() */ undefined\",\n\t\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t\t);\n\t\t\t\tclearDep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(clearDep);\n\t\t\t\treturn true;\n\t\t\t});\n\t\t//#endregion\n\t}\n}\nmodule.exports = CommonJsImportsParserPlugin;\n"]},"metadata":{},"sourceType":"script"}