{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/**\n * StringXor class provides methods for performing\n * [XOR operations](https://en.wikipedia.org/wiki/Exclusive_or) on strings. In this context\n * we operating on the character codes of two strings, which are represented as\n * [Buffer](https://nodejs.org/api/buffer.html) objects.\n *\n * We use [StringXor in webpack](https://github.com/webpack/webpack/commit/41a8e2ea483a544c4ccd3e6217bdfb80daffca39)\n * to create a hash of the current state of the compilation. By XOR'ing the Module hashes, it\n * doesn't matter if the Module hashes are sorted or not. This is useful because it allows us to avoid sorting the\n * Module hashes.\n *\n * @example\n * ```js\n * const xor = new StringXor();\n * xor.add('hello');\n * xor.add('world');\n * console.log(xor.toString());\n * ```\n *\n * @example\n * ```js\n * const xor = new StringXor();\n * xor.add('foo');\n * xor.add('bar');\n * const hash = createHash('sha256');\n * hash.update(xor.toString());\n * console.log(hash.digest('hex'));\n * ```\n */\n\nclass StringXor {\n  constructor() {\n    /** @type {Buffer|undefined} */\n    this._value = undefined;\n  }\n  /**\n   * Adds a string to the current StringXor object.\n   *\n   * @param {string} str string\n   * @returns {void}\n   */\n\n\n  add(str) {\n    const len = str.length;\n    const value = this._value;\n\n    if (value === undefined) {\n      /**\n       * We are choosing to use Buffer.allocUnsafe() because it is often faster than Buffer.alloc() because\n       * it allocates a new buffer of the specified size without initializing the memory.\n       */\n      const newValue = this._value = Buffer.allocUnsafe(len);\n\n      for (let i = 0; i < len; i++) {\n        newValue[i] = str.charCodeAt(i);\n      }\n\n      return;\n    }\n\n    const valueLen = value.length;\n\n    if (valueLen < len) {\n      const newValue = this._value = Buffer.allocUnsafe(len);\n      let i;\n\n      for (i = 0; i < valueLen; i++) {\n        newValue[i] = value[i] ^ str.charCodeAt(i);\n      }\n\n      for (; i < len; i++) {\n        newValue[i] = str.charCodeAt(i);\n      }\n    } else {\n      for (let i = 0; i < len; i++) {\n        value[i] = value[i] ^ str.charCodeAt(i);\n      }\n    }\n  }\n  /**\n   * Returns a string that represents the current state of the StringXor object. We chose to use \"latin1\" encoding\n   * here because \"latin1\" encoding is a single-byte encoding that can represent all characters in the\n   * [ISO-8859-1 character set](https://en.wikipedia.org/wiki/ISO/IEC_8859-1). This is useful when working\n   * with binary data that needs to be represented as a string.\n   *\n   * @returns {string} Returns a string that represents the current state of the StringXor object.\n   */\n\n\n  toString() {\n    const value = this._value;\n    return value === undefined ? \"\" : value.toString(\"latin1\");\n  }\n  /**\n   * Updates the hash with the current state of the StringXor object.\n   *\n   * @param {Hash} hash Hash instance\n   */\n\n\n  updateHash(hash) {\n    const value = this._value;\n    if (value !== undefined) hash.update(value);\n  }\n\n}\n\nmodule.exports = StringXor;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/util/StringXor.js"],"names":["StringXor","constructor","_value","undefined","add","str","len","length","value","newValue","Buffer","allocUnsafe","i","charCodeAt","valueLen","toString","updateHash","hash","update","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMA,SAAN,CAAgB;AACfC,EAAAA,WAAW,GAAG;AACb;AACA,SAAKC,MAAL,GAAcC,SAAd;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,GAAG,CAACC,GAAD,EAAM;AACR,UAAMC,GAAG,GAAGD,GAAG,CAACE,MAAhB;AACA,UAAMC,KAAK,GAAG,KAAKN,MAAnB;;AACA,QAAIM,KAAK,KAAKL,SAAd,EAAyB;AACxB;AACH;AACA;AACA;AACG,YAAMM,QAAQ,GAAI,KAAKP,MAAL,GAAcQ,MAAM,CAACC,WAAP,CAAmBL,GAAnB,CAAhC;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,GAApB,EAAyBM,CAAC,EAA1B,EAA8B;AAC7BH,QAAAA,QAAQ,CAACG,CAAD,CAAR,GAAcP,GAAG,CAACQ,UAAJ,CAAeD,CAAf,CAAd;AACA;;AACD;AACA;;AACD,UAAME,QAAQ,GAAGN,KAAK,CAACD,MAAvB;;AACA,QAAIO,QAAQ,GAAGR,GAAf,EAAoB;AACnB,YAAMG,QAAQ,GAAI,KAAKP,MAAL,GAAcQ,MAAM,CAACC,WAAP,CAAmBL,GAAnB,CAAhC;AACA,UAAIM,CAAJ;;AACA,WAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,QAAhB,EAA0BF,CAAC,EAA3B,EAA+B;AAC9BH,QAAAA,QAAQ,CAACG,CAAD,CAAR,GAAcJ,KAAK,CAACI,CAAD,CAAL,GAAWP,GAAG,CAACQ,UAAJ,CAAeD,CAAf,CAAzB;AACA;;AACD,aAAOA,CAAC,GAAGN,GAAX,EAAgBM,CAAC,EAAjB,EAAqB;AACpBH,QAAAA,QAAQ,CAACG,CAAD,CAAR,GAAcP,GAAG,CAACQ,UAAJ,CAAeD,CAAf,CAAd;AACA;AACD,KATD,MASO;AACN,WAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,GAApB,EAAyBM,CAAC,EAA1B,EAA8B;AAC7BJ,QAAAA,KAAK,CAACI,CAAD,CAAL,GAAWJ,KAAK,CAACI,CAAD,CAAL,GAAWP,GAAG,CAACQ,UAAJ,CAAeD,CAAf,CAAtB;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,QAAQ,GAAG;AACV,UAAMP,KAAK,GAAG,KAAKN,MAAnB;AACA,WAAOM,KAAK,KAAKL,SAAV,GAAsB,EAAtB,GAA2BK,KAAK,CAACO,QAAN,CAAe,QAAf,CAAlC;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,UAAU,CAACC,IAAD,EAAO;AAChB,UAAMT,KAAK,GAAG,KAAKN,MAAnB;AACA,QAAIM,KAAK,KAAKL,SAAd,EAAyBc,IAAI,CAACC,MAAL,CAAYV,KAAZ;AACzB;;AAhEc;;AAmEhBW,MAAM,CAACC,OAAP,GAAiBpB,SAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/**\n * StringXor class provides methods for performing\n * [XOR operations](https://en.wikipedia.org/wiki/Exclusive_or) on strings. In this context\n * we operating on the character codes of two strings, which are represented as\n * [Buffer](https://nodejs.org/api/buffer.html) objects.\n *\n * We use [StringXor in webpack](https://github.com/webpack/webpack/commit/41a8e2ea483a544c4ccd3e6217bdfb80daffca39)\n * to create a hash of the current state of the compilation. By XOR'ing the Module hashes, it\n * doesn't matter if the Module hashes are sorted or not. This is useful because it allows us to avoid sorting the\n * Module hashes.\n *\n * @example\n * ```js\n * const xor = new StringXor();\n * xor.add('hello');\n * xor.add('world');\n * console.log(xor.toString());\n * ```\n *\n * @example\n * ```js\n * const xor = new StringXor();\n * xor.add('foo');\n * xor.add('bar');\n * const hash = createHash('sha256');\n * hash.update(xor.toString());\n * console.log(hash.digest('hex'));\n * ```\n */\nclass StringXor {\n\tconstructor() {\n\t\t/** @type {Buffer|undefined} */\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Adds a string to the current StringXor object.\n\t *\n\t * @param {string} str string\n\t * @returns {void}\n\t */\n\tadd(str) {\n\t\tconst len = str.length;\n\t\tconst value = this._value;\n\t\tif (value === undefined) {\n\t\t\t/**\n\t\t\t * We are choosing to use Buffer.allocUnsafe() because it is often faster than Buffer.alloc() because\n\t\t\t * it allocates a new buffer of the specified size without initializing the memory.\n\t\t\t */\n\t\t\tconst newValue = (this._value = Buffer.allocUnsafe(len));\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tnewValue[i] = str.charCodeAt(i);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst valueLen = value.length;\n\t\tif (valueLen < len) {\n\t\t\tconst newValue = (this._value = Buffer.allocUnsafe(len));\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < valueLen; i++) {\n\t\t\t\tnewValue[i] = value[i] ^ str.charCodeAt(i);\n\t\t\t}\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tnewValue[i] = str.charCodeAt(i);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tvalue[i] = value[i] ^ str.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a string that represents the current state of the StringXor object. We chose to use \"latin1\" encoding\n\t * here because \"latin1\" encoding is a single-byte encoding that can represent all characters in the\n\t * [ISO-8859-1 character set](https://en.wikipedia.org/wiki/ISO/IEC_8859-1). This is useful when working\n\t * with binary data that needs to be represented as a string.\n\t *\n\t * @returns {string} Returns a string that represents the current state of the StringXor object.\n\t */\n\ttoString() {\n\t\tconst value = this._value;\n\t\treturn value === undefined ? \"\" : value.toString(\"latin1\");\n\t}\n\n\t/**\n\t * Updates the hash with the current state of the StringXor object.\n\t *\n\t * @param {Hash} hash Hash instance\n\t */\n\tupdateHash(hash) {\n\t\tconst value = this._value;\n\t\tif (value !== undefined) hash.update(value);\n\t}\n}\n\nmodule.exports = StringXor;\n"]},"metadata":{},"sourceType":"script"}