{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourceMap = {}));\n})(this, function (exports) {\n  'use strict';\n\n  const comma = ','.charCodeAt(0);\n  const semicolon = ';'.charCodeAt(0);\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  const intToChar = new Uint8Array(64); // 64 possible chars.\n\n  const charToInteger = new Uint8Array(128); // z is 122 in ASCII\n\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    charToInteger[c] = i;\n    intToChar[i] = c;\n  } // Provide a fallback for older environments.\n\n\n  const td = typeof TextDecoder !== 'undefined' ? new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode(buf) {\n      const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n\n  } : {\n    decode(buf) {\n      let out = '';\n\n      for (let i = 0; i < buf.length; i++) {\n        out += String.fromCharCode(buf[i]);\n      }\n\n      return out;\n    }\n\n  };\n\n  function decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let line = [];\n    let sorted = true;\n    let lastCol = 0;\n\n    for (let i = 0; i < mappings.length;) {\n      const c = mappings.charCodeAt(i);\n\n      if (c === comma) {\n        i++;\n      } else if (c === semicolon) {\n        state[0] = lastCol = 0;\n        if (!sorted) sort(line);\n        sorted = true;\n        decoded.push(line);\n        line = [];\n        i++;\n      } else {\n        i = decodeInteger(mappings, i, state, 0); // generatedCodeColumn\n\n        const col = state[0];\n        if (col < lastCol) sorted = false;\n        lastCol = col;\n\n        if (!hasMoreSegments(mappings, i)) {\n          line.push([col]);\n          continue;\n        }\n\n        i = decodeInteger(mappings, i, state, 1); // sourceFileIndex\n\n        i = decodeInteger(mappings, i, state, 2); // sourceCodeLine\n\n        i = decodeInteger(mappings, i, state, 3); // sourceCodeColumn\n\n        if (!hasMoreSegments(mappings, i)) {\n          line.push([col, state[1], state[2], state[3]]);\n          continue;\n        }\n\n        i = decodeInteger(mappings, i, state, 4); // nameIndex\n\n        line.push([col, state[1], state[2], state[3], state[4]]);\n      }\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    return decoded;\n  }\n\n  function decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n\n    do {\n      const c = mappings.charCodeAt(pos++);\n      integer = charToInteger[c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n\n    const shouldNegate = value & 1;\n    value >>>= 1;\n\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n\n    state[j] += value;\n    return pos;\n  }\n\n  function hasMoreSegments(mappings, i) {\n    if (i >= mappings.length) return false;\n    const c = mappings.charCodeAt(i);\n    if (c === comma || c === semicolon) return false;\n    return true;\n  }\n\n  function sort(line) {\n    line.sort(sortComparator$1);\n  }\n\n  function sortComparator$1(a, b) {\n    return a[0] - b[0];\n  }\n\n  function encode(decoded) {\n    const state = new Int32Array(5);\n    let buf = new Uint8Array(1024);\n    let pos = 0;\n\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n\n      if (i > 0) {\n        buf = reserve(buf, pos, 1);\n        buf[pos++] = semicolon;\n      }\n\n      if (line.length === 0) continue;\n      state[0] = 0;\n\n      for (let j = 0; j < line.length; j++) {\n        const segment = line[j]; // We can push up to 5 ints, each int can take at most 7 chars, and we\n        // may push a comma.\n\n        buf = reserve(buf, pos, 36);\n        if (j > 0) buf[pos++] = comma;\n        pos = encodeInteger(buf, pos, state, segment, 0); // generatedCodeColumn\n\n        if (segment.length === 1) continue;\n        pos = encodeInteger(buf, pos, state, segment, 1); // sourceFileIndex\n\n        pos = encodeInteger(buf, pos, state, segment, 2); // sourceCodeLine\n\n        pos = encodeInteger(buf, pos, state, segment, 3); // sourceCodeColumn\n\n        if (segment.length === 4) continue;\n        pos = encodeInteger(buf, pos, state, segment, 4); // nameIndex\n      }\n    }\n\n    return td.decode(buf.subarray(0, pos));\n  }\n\n  function reserve(buf, pos, count) {\n    if (buf.length > pos + count) return buf;\n    const swap = new Uint8Array(buf.length * 2);\n    swap.set(buf);\n    return swap;\n  }\n\n  function encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n\n    do {\n      let clamped = num & 0b011111;\n      num >>>= 5;\n      if (num > 0) clamped |= 0b100000;\n      buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n\n    return pos;\n  } // Matches the scheme of a URL, eg \"http://\"\n\n\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   */\n\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may inclue \"/\", guaranteed.\n   */\n\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/]*)?)?(\\/?.*)/i;\n\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');\n  }\n\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);\n  }\n\n  function makeUrl(scheme, user, host, port, path) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      relativePath: false\n    };\n  }\n\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      return url;\n    }\n\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      return url;\n    }\n\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.relativePath = true;\n    return url;\n  }\n\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  function mergePaths(url, base) {\n    // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n    if (!url.relativePath) return;\n    normalizePath(base); // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    } // If the base path is absolute, then our path is now absolute too.\n\n\n    url.relativePath = base.relativePath;\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n\n\n  function normalizePath(url) {\n    const {\n      relativePath\n    } = url;\n    const pieces = url.path.split('/'); // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n\n    let pointer = 1; // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n\n    let positive = 0; // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n\n    let addTrailingSlash = false;\n\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i]; // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      } // If we encounter a real directory, then we don't need to append anymore.\n\n\n      addTrailingSlash = false; // A current directory, which we can always drop.\n\n      if (piece === '.') continue; // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (relativePath) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n\n        continue;\n      } // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n\n\n      pieces[pointer++] = piece;\n      positive++;\n    }\n\n    let path = '';\n\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n\n\n  function resolve$1(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input); // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n\n    if (base && !url.scheme) {\n      const baseUrl = parseUrl(base);\n      url.scheme = baseUrl.scheme; // If there's no host, then we were just a path.\n\n      if (!url.host) {\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      }\n\n      mergePaths(url, baseUrl);\n    }\n\n    normalizePath(url); // If the input (and base, if there was one) are both relative, then we need to output a relative.\n\n    if (url.relativePath) {\n      // The first char is always a \"/\".\n      const path = url.path.slice(1);\n      if (!path) return '.'; // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n      // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n      // with a \"..\", though, so check before prepending.\n\n      const keepRelative = (base || input).startsWith('.');\n      return !keepRelative || path.startsWith('.') ? path : './' + path;\n    } // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n\n\n    if (!url.scheme && !url.host) return url.path; // We're outputting either an absolute URL, or a protocol relative one.\n\n    return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n  }\n\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolve$1(input, base);\n  }\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n\n\n  function stripFilename(path) {\n    if (!path) return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  const COLUMN$1 = 0;\n  const SOURCES_INDEX$1 = 1;\n  const SOURCE_LINE$1 = 2;\n  const SOURCE_COLUMN$1 = 3;\n  const NAMES_INDEX$1 = 4;\n\n  function maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings; // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n\n    if (!owned) mappings = mappings.slice();\n\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n      mappings[i] = sortSegments(mappings[i], owned);\n    }\n\n    return mappings;\n  }\n\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n      if (!isSorted(mappings[i])) return i;\n    }\n\n    return mappings.length;\n  }\n\n  function isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n      if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n\n  function sortComparator(a, b) {\n    return a[COLUMN$1] - b[COLUMN$1];\n  }\n\n  let found = false;\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      const mid = low + (high - low >> 1);\n      const cmp = haystack[mid][COLUMN$1] - needle;\n\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n\n    found = false;\n    return low - 1;\n  }\n\n  function upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; i++, index++) {\n      if (haystack[i][COLUMN$1] !== needle) break;\n    }\n\n    return index;\n  }\n\n  function lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; i--, index--) {\n      if (haystack[i][COLUMN$1] !== needle) break;\n    }\n\n    return index;\n  }\n\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n\n\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    const {\n      lastKey,\n      lastNeedle,\n      lastIndex\n    } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;\n        return lastIndex;\n      }\n\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n      } else {\n        high = lastIndex;\n      }\n    }\n\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  }\n\n  const AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const {\n      sections\n    } = parsed;\n    let i = 0;\n\n    for (; i < sections.length - 1; i++) {\n      const no = sections[i + 1].offset;\n      addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);\n    }\n\n    if (sections.length > 0) {\n      addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);\n    }\n\n    const joined = {\n      version: 3,\n      file: parsed.file,\n      names,\n      sources,\n      sourcesContent,\n      mappings\n    };\n    return presortedDecodedMap(joined);\n  };\n\n  function addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {\n    const map = AnyMap(section.map, mapUrl);\n    const {\n      line: lineOffset,\n      column: columnOffset\n    } = section.offset;\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const {\n      resolvedSources\n    } = map;\n    append(sources, resolvedSources);\n    append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));\n    append(names, map.names); // If this section jumps forwards several lines, we need to add lines to the output mappings catch up.\n\n    for (let i = mappings.length; i <= lineOffset; i++) mappings.push([]); // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range.\n\n\n    const stopI = stopLine - lineOffset;\n    const len = Math.min(decoded.length, stopI + 1);\n\n    for (let i = 0; i < len; i++) {\n      const line = decoded[i]; // On the 0th loop, the line will already exist due to a previous section, or the line catch up\n      // loop above.\n\n      const out = i === 0 ? mappings[lineOffset] : mappings[lineOffset + i] = []; // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n      // map can be multiple lines), it doesn't.\n\n      const cOffset = i === 0 ? columnOffset : 0;\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const column = cOffset + seg[COLUMN$1]; // If this segment steps into the column range that the next section's map controls, we need\n        // to stop early.\n\n        if (i === stopI && column >= stopColumn) break;\n\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n\n        const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX$1];\n        const sourceLine = seg[SOURCE_LINE$1];\n        const sourceColumn = seg[SOURCE_COLUMN$1];\n\n        if (seg.length === 4) {\n          out.push([column, sourcesIndex, sourceLine, sourceColumn]);\n          continue;\n        }\n\n        out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX$1]]);\n      }\n    }\n  }\n\n  function append(arr, other) {\n    for (let i = 0; i < other.length; i++) arr.push(other[i]);\n  } // Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of\n  // equal length to the sources. This is because the sources and sourcesContent are paired arrays,\n  // where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined\n  // sourcemap would desynchronize the sources/contents.\n\n\n  function fillSourcesContent(len) {\n    const sourcesContent = [];\n\n    for (let i = 0; i < len; i++) sourcesContent[i] = null;\n\n    return sourcesContent;\n  }\n\n  const INVALID_ORIGINAL_MAPPING = Object.freeze({\n    source: null,\n    line: null,\n    column: null,\n    name: null\n  });\n  Object.freeze({\n    line: null,\n    column: null\n  });\n  const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n  const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n  const LEAST_UPPER_BOUND = -1;\n  const GREATEST_LOWER_BOUND = 1;\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n\n  let decodedMappings;\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n\n  let originalPositionFor;\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n\n  let presortedDecodedMap;\n\n  class TraceMap {\n    constructor(map, mapUrl) {\n      this._decodedMemo = memoizedState();\n      this._bySources = undefined;\n      this._bySourceMemos = undefined;\n      const isString = typeof map === 'string';\n      if (!isString && map.constructor === TraceMap) return map;\n      const parsed = isString ? JSON.parse(map) : map;\n      const {\n        version,\n        file,\n        names,\n        sourceRoot,\n        sources,\n        sourcesContent\n      } = parsed;\n      this.version = version;\n      this.file = file;\n      this.names = names;\n      this.sourceRoot = sourceRoot;\n      this.sources = sources;\n      this.sourcesContent = sourcesContent;\n\n      if (sourceRoot || mapUrl) {\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map(s => resolve(s || '', from));\n      } else {\n        this.resolvedSources = sources.map(s => s || '');\n      }\n\n      const {\n        mappings\n      } = parsed;\n\n      if (typeof mappings === 'string') {\n        this._encoded = mappings;\n        this._decoded = undefined;\n      } else {\n        this._encoded = undefined;\n        this._decoded = maybeSort(mappings, isString);\n      }\n    }\n\n  }\n\n  (() => {\n    decodedMappings = map => {\n      return map._decoded || (map._decoded = decode(map._encoded));\n    };\n\n    originalPositionFor = (map, _ref) => {\n      let {\n        line,\n        column,\n        bias\n      } = _ref;\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      const decoded = decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n      if (line >= decoded.length) return INVALID_ORIGINAL_MAPPING;\n      const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n      if (segment == null) return INVALID_ORIGINAL_MAPPING;\n      if (segment.length == 1) return INVALID_ORIGINAL_MAPPING;\n      const {\n        names,\n        resolvedSources\n      } = map;\n      return {\n        source: resolvedSources[segment[SOURCES_INDEX$1]],\n        line: segment[SOURCE_LINE$1] + 1,\n        column: segment[SOURCE_COLUMN$1],\n        name: segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null\n      };\n    };\n\n    presortedDecodedMap = (map, mapUrl) => {\n      const clone = Object.assign({}, map);\n      clone.mappings = [];\n      const tracer = new TraceMap(clone, mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n  })();\n\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n\n    if (found) {\n      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    } else if (bias === LEAST_UPPER_BOUND) index++;\n\n    if (index === -1 || index === segments.length) return null;\n    return segments[index];\n  }\n  /**\n   * Gets the index associated with `key` in the backing array, if it is already present.\n   */\n\n\n  let get;\n  /**\n   * Puts `key` into the backing array, if it is not already present. Returns\n   * the index of the `key` in the backing array.\n   */\n\n  let put;\n  /**\n   * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n   * index of the `key` in the backing array.\n   *\n   * This is designed to allow synchronizing a second array with the contents of the backing array,\n   * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n   * and there are never duplicates.\n   */\n\n  class SetArray {\n    constructor() {\n      this._indexes = {\n        __proto__: null\n      };\n      this.array = [];\n    }\n\n  }\n\n  (() => {\n    get = (strarr, key) => strarr._indexes[key];\n\n    put = (strarr, key) => {\n      // The key may or may not be present. If it is present, it's a number.\n      const index = get(strarr, key);\n      if (index !== undefined) return index;\n      const {\n        array,\n        _indexes: indexes\n      } = strarr;\n      return indexes[key] = array.push(key) - 1;\n    };\n  })();\n\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const NO_NAME = -1;\n  /**\n   * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n   * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n   * not add a mapping with a lower generated line/column than one that came before.\n   */\n\n  let maybeAddMapping;\n  /**\n   * Adds/removes the content of the source file to the source map.\n   */\n\n  let setSourceContent;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n\n  let toDecodedMap;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n\n  let toEncodedMap; // This split declaration is only so that terser can elminiate the static initialization block.\n\n  let addSegmentInternal;\n  /**\n   * Provides the state to generate a sourcemap.\n   */\n\n  class GenMapping {\n    constructor() {\n      let {\n        file,\n        sourceRoot\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._names = new SetArray();\n      this._sources = new SetArray();\n      this._sourcesContent = [];\n      this._mappings = [];\n      this.file = file;\n      this.sourceRoot = sourceRoot;\n    }\n\n  }\n\n  (() => {\n    maybeAddMapping = (map, mapping) => {\n      return addMappingInternal(true, map, mapping);\n    };\n\n    setSourceContent = (map, source, content) => {\n      const {\n        _sources: sources,\n        _sourcesContent: sourcesContent\n      } = map;\n      sourcesContent[put(sources, source)] = content;\n    };\n\n    toDecodedMap = map => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names\n      } = map;\n      removeEmptyFinalLines(mappings);\n      return {\n        version: 3,\n        file: file || undefined,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings\n      };\n    };\n\n    toEncodedMap = map => {\n      const decoded = toDecodedMap(map);\n      return Object.assign(Object.assign({}, decoded), {\n        mappings: encode(decoded.mappings)\n      });\n    }; // Internal helpers\n\n\n    addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names\n      } = map;\n      const line = getLine(mappings, genLine);\n      const index = getColumnIndex(line, genColumn);\n\n      if (!source) {\n        if (skipable && skipSourceless(line, index)) return;\n        return insert(line, index, [genColumn]);\n      }\n\n      const sourcesIndex = put(sources, source);\n      const namesIndex = name ? put(names, name) : NO_NAME;\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;\n\n      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n      }\n\n      return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    };\n  })();\n\n  function getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n      mappings[i] = [];\n    }\n\n    return mappings[index];\n  }\n\n  function getColumnIndex(line, genColumn) {\n    let index = line.length;\n\n    for (let i = index - 1; i >= 0; index = i--) {\n      const current = line[i];\n      if (genColumn >= current[COLUMN]) break;\n    }\n\n    return index;\n  }\n\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n\n    array[index] = value;\n  }\n\n  function removeEmptyFinalLines(mappings) {\n    const {\n      length\n    } = mappings;\n    let len = length;\n\n    for (let i = len - 1; i >= 0; len = i, i--) {\n      if (mappings[i].length > 0) break;\n    }\n\n    if (len < length) mappings.length = len;\n  }\n\n  function skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0) return true;\n    const prev = line[index - 1]; // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n\n    return prev.length === 1;\n  }\n\n  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0) return false;\n    const prev = line[index - 1]; // If the previous segment is sourceless, then we're transitioning to a source.\n\n    if (prev.length === 1) return false; // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n  }\n\n  function addMappingInternal(skipable, map, mapping) {\n    const {\n      generated,\n      source,\n      original,\n      name\n    } = mapping;\n\n    if (!source) {\n      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null);\n    }\n\n    const s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name);\n  }\n\n  class SourceMapConsumer {\n    constructor(map, mapUrl) {\n      const trace = this._map = new AnyMap(map, mapUrl);\n      this.file = trace.file;\n      this.names = trace.names;\n      this.sourceRoot = trace.sourceRoot;\n      this.sources = trace.resolvedSources;\n      this.sourcesContent = trace.sourcesContent;\n    }\n\n    originalPositionFor(needle) {\n      return originalPositionFor(this._map, needle);\n    }\n\n    destroy() {// noop.\n    }\n\n  }\n\n  class SourceMapGenerator {\n    constructor(opts) {\n      this._map = new GenMapping(opts);\n    }\n\n    addMapping(mapping) {\n      maybeAddMapping(this._map, mapping);\n    }\n\n    setSourceContent(source, content) {\n      setSourceContent(this._map, source, content);\n    }\n\n    toJSON() {\n      return toEncodedMap(this._map);\n    }\n\n    toDecodedMap() {\n      return toDecodedMap(this._map);\n    }\n\n  }\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n  exports.SourceMapGenerator = SourceMapGenerator;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInteger","i","length","c","td","TextDecoder","Buffer","decode","buf","out","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","mappings","state","Int32Array","decoded","line","sorted","lastCol","sort","push","decodeInteger","col","hasMoreSegments","pos","j","value","shift","integer","shouldNegate","sortComparator","a","b","encode","reserve","segment","encodeInteger","subarray","count","swap","set","next","num","clamped","schemeRegex","urlRegex","fileRegex","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","relativePath","parseUrl","url","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","pieces","split","pointer","positive","addTrailingSlash","piece","resolve","baseUrl","keepRelative","resolveUri","stripFilename","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","maybeSort","owned","unsortedIndex","nextUnsortedSegmentLine","sortSegments","start","isSorted","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","key","AnyMap","map","mapUrl","parsed","JSON","parse","TraceMap","sources","sourcesContent","names","sections","no","offset","addSection","column","Infinity","joined","version","file","presortedDecodedMap","section","stopLine","stopColumn","lineOffset","columnOffset","sourcesOffset","namesOffset","decodedMappings","resolvedSources","append","fillSourcesContent","stopI","len","Math","min","cOffset","seg","sourcesIndex","sourceLine","sourceColumn","arr","other","INVALID_ORIGINAL_MAPPING","Object","freeze","source","name","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","originalPositionFor","constructor","_decodedMemo","_bySources","undefined","_bySourceMemos","isString","sourceRoot","s","_encoded","_decoded","bias","Error","traceSegmentInternal","clone","assign","tracer","segments","memo","get","put","SetArray","_indexes","__proto__","array","strarr","indexes","NO_NAME","maybeAddMapping","setSourceContent","toDecodedMap","toEncodedMap","addSegmentInternal","GenMapping","_names","_sources","_sourcesContent","_mappings","mapping","addMappingInternal","content","removeEmptyFinalLines","skipable","genLine","genColumn","getLine","getColumnIndex","skipSourceless","insert","namesIndex","skipSource","current","prev","generated","original","SourceMapConsumer","trace","_map","destroy","SourceMapGenerator","opts","addMapping","toJSON"],"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/source-map/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs","/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/source-map/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs","/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/source-map/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs","/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/source-map/node_modules/@jridgewell/set-array/dist/set-array.mjs","/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/source-map/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs","/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/src/source-map.ts"],"sourcesContent":["const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInteger = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    charToInteger[c] = i;\n    intToChar[i] = c;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let line = [];\n    let sorted = true;\n    let lastCol = 0;\n    for (let i = 0; i < mappings.length;) {\n        const c = mappings.charCodeAt(i);\n        if (c === comma) {\n            i++;\n        }\n        else if (c === semicolon) {\n            state[0] = lastCol = 0;\n            if (!sorted)\n                sort(line);\n            sorted = true;\n            decoded.push(line);\n            line = [];\n            i++;\n        }\n        else {\n            i = decodeInteger(mappings, i, state, 0); // generatedCodeColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (!hasMoreSegments(mappings, i)) {\n                line.push([col]);\n                continue;\n            }\n            i = decodeInteger(mappings, i, state, 1); // sourceFileIndex\n            i = decodeInteger(mappings, i, state, 2); // sourceCodeLine\n            i = decodeInteger(mappings, i, state, 3); // sourceCodeColumn\n            if (!hasMoreSegments(mappings, i)) {\n                line.push([col, state[1], state[2], state[3]]);\n                continue;\n            }\n            i = decodeInteger(mappings, i, state, 4); // nameIndex\n            line.push([col, state[1], state[2], state[3], state[4]]);\n        }\n    }\n    if (!sorted)\n        sort(line);\n    decoded.push(line);\n    return decoded;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInteger[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreSegments(mappings, i) {\n    if (i >= mappings.length)\n        return false;\n    const c = mappings.charCodeAt(i);\n    if (c === comma || c === semicolon)\n        return false;\n    return true;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    let buf = new Uint8Array(1024);\n    let pos = 0;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            buf = reserve(buf, pos, 1);\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            buf = reserve(buf, pos, 36);\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // generatedCodeColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourceFileIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceCodeLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceCodeColumn\n            if (segment.length === 4)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // nameIndex\n        }\n    }\n    return td.decode(buf.subarray(0, pos));\n}\nfunction reserve(buf, pos, count) {\n    if (buf.length > pos + count)\n        return buf;\n    const swap = new Uint8Array(buf.length * 2);\n    swap.set(buf);\n    return swap;\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        let clamped = num & 0b011111;\n        num >>>= 5;\n        if (num > 0)\n            clamped |= 0b100000;\n        buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.mjs.map\n","// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may inclue \"/\", guaranteed.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/]*)?)?(\\/?.*)/i;\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);\n}\nfunction makeUrl(scheme, user, host, port, path) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        relativePath: false,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.relativePath = true;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n    if (!url.relativePath)\n        return;\n    normalizePath(base);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n    // If the base path is absolute, then our path is now absolute too.\n    url.relativePath = base.relativePath;\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url) {\n    const { relativePath } = url;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (relativePath) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n    if (base && !url.scheme) {\n        const baseUrl = parseUrl(base);\n        url.scheme = baseUrl.scheme;\n        // If there's no host, then we were just a path.\n        if (!url.host) {\n            // The host, user, and port are joined, you can't copy one without the others.\n            url.user = baseUrl.user;\n            url.host = baseUrl.host;\n            url.port = baseUrl.port;\n        }\n        mergePaths(url, baseUrl);\n    }\n    normalizePath(url);\n    // If the input (and base, if there was one) are both relative, then we need to output a relative.\n    if (url.relativePath) {\n        // The first char is always a \"/\".\n        const path = url.path.slice(1);\n        if (!path)\n            return '.';\n        // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n        // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n        // with a \"..\", though, so check before prepending.\n        const keepRelative = (base || input).startsWith('.');\n        return !keepRelative || path.startsWith('.') ? path : './' + path;\n    }\n    // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n    if (!url.scheme && !url.host)\n        return url.path;\n    // We're outputting either an absolute URL, or a protocol relative one.\n    return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n}\n\nexport { resolve as default };\n//# sourceMappingURL=resolve-uri.mjs.map\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; i++, index++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; i--, index--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed))\n        return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const { sections } = parsed;\n    let i = 0;\n    for (; i < sections.length - 1; i++) {\n        const no = sections[i + 1].offset;\n        addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);\n    }\n    if (sections.length > 0) {\n        addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);\n    }\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {\n    const map = AnyMap(section.map, mapUrl);\n    const { line: lineOffset, column: columnOffset } = section.offset;\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources } = map;\n    append(sources, resolvedSources);\n    append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));\n    append(names, map.names);\n    // If this section jumps forwards several lines, we need to add lines to the output mappings catch up.\n    for (let i = mappings.length; i <= lineOffset; i++)\n        mappings.push([]);\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range.\n    const stopI = stopLine - lineOffset;\n    const len = Math.min(decoded.length, stopI + 1);\n    for (let i = 0; i < len; i++) {\n        const line = decoded[i];\n        // On the 0th loop, the line will already exist due to a previous section, or the line catch up\n        // loop above.\n        const out = i === 0 ? mappings[lineOffset] : (mappings[lineOffset + i] = []);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (i === stopI && column >= stopColumn)\n                break;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            if (seg.length === 4) {\n                out.push([column, sourcesIndex, sourceLine, sourceColumn]);\n                continue;\n            }\n            out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\n// Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of\n// equal length to the sources. This is because the sources and sourcesContent are paired arrays,\n// where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined\n// sourcemap would desynchronize the sources/contents.\nfunction fillSourcesContent(len) {\n    const sourcesContent = [];\n    for (let i = 0; i < len; i++)\n        sourcesContent[i] = null;\n    return sourcesContent;\n}\n\nconst INVALID_ORIGINAL_MAPPING = Object.freeze({\n    source: null,\n    line: null,\n    column: null,\n    name: null,\n});\nconst INVALID_GENERATED_MAPPING = Object.freeze({\n    line: null,\n    column: null,\n});\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nlet encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nlet traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\n/**\n * Finds the source/line/column directly after the mapping returned by originalPositionFor, provided\n * the found mapping is from the same source and line as the originalPositionFor mapping.\n *\n * Eg, in the code `let id = 1`, `originalPositionAfter` could find the mapping associated with `1`\n * using the same needle that would return `id` when calling `originalPositionFor`.\n */\nlet generatedPositionFor;\n/**\n * Iterates each mapping in generated position order.\n */\nlet eachMapping;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nlet presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet encodedMap;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n        const isString = typeof map === 'string';\n        if (!isString && map.constructor === TraceMap)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names;\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        if (sourceRoot || mapUrl) {\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        }\n        else {\n            this.resolvedSources = sources.map((s) => s || '');\n        }\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n    }\n}\n(() => {\n    encodedMappings = (map) => {\n        var _a;\n        return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = encode(map._decoded)));\n    };\n    decodedMappings = (map) => {\n        return (map._decoded || (map._decoded = decode(map._encoded)));\n    };\n    traceSegment = (map, line, column) => {\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return null;\n        return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    };\n    originalPositionFor = (map, { line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return INVALID_ORIGINAL_MAPPING;\n        const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (segment == null)\n            return INVALID_ORIGINAL_MAPPING;\n        if (segment.length == 1)\n            return INVALID_ORIGINAL_MAPPING;\n        const { names, resolvedSources } = map;\n        return {\n            source: resolvedSources[segment[SOURCES_INDEX]],\n            line: segment[SOURCE_LINE] + 1,\n            column: segment[SOURCE_COLUMN],\n            name: segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n        };\n    };\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return INVALID_GENERATED_MAPPING;\n        const generated = (map._bySources || (map._bySources = buildBySources(decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n        const memos = map._bySourceMemos;\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return INVALID_GENERATED_MAPPING;\n        const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);\n        if (segment == null)\n            return INVALID_GENERATED_MAPPING;\n        return {\n            line: segment[REV_GENERATED_LINE] + 1,\n            column: segment[REV_GENERATED_COLUMN],\n        };\n    };\n    eachMapping = (map, cb) => {\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5)\n                    name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name,\n                });\n            }\n        }\n    };\n    presortedDecodedMap = (map, mapUrl) => {\n        const clone = Object.assign({}, map);\n        clone.mappings = [];\n        const tracer = new TraceMap(clone, mapUrl);\n        tracer._decoded = map.mappings;\n        return tracer;\n    };\n    decodedMap = (map) => {\n        return {\n            version: 3,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings: decodedMappings(map),\n        };\n    };\n    encodedMap = (map) => {\n        return {\n            version: 3,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings: encodedMappings(map),\n        };\n    };\n})();\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return null;\n    return segments[index];\n}\n\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, traceSegment };\n//# sourceMappingURL=trace-mapping.mjs.map\n","/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nlet get;\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nlet put;\n/**\n * Pops the last added item out of the SetArray.\n */\nlet pop;\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nclass SetArray {\n    constructor() {\n        this._indexes = { __proto__: null };\n        this.array = [];\n    }\n}\n(() => {\n    get = (strarr, key) => strarr._indexes[key];\n    put = (strarr, key) => {\n        // The key may or may not be present. If it is present, it's a number.\n        const index = get(strarr, key);\n        if (index !== undefined)\n            return index;\n        const { array, _indexes: indexes } = strarr;\n        return (indexes[key] = array.push(key) - 1);\n    };\n    pop = (strarr) => {\n        const { array, _indexes: indexes } = strarr;\n        if (array.length === 0)\n            return;\n        const last = array.pop();\n        indexes[last] = undefined;\n    };\n})();\n\nexport { SetArray, get, pop, put };\n//# sourceMappingURL=set-array.mjs.map\n","import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\n\nconst NO_NAME = -1;\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nlet addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nlet addMapping;\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nlet maybeAddSegment;\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nlet maybeAddMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */\nlet setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet toDecodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet toEncodedMap;\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nlet fromMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nlet allMappings;\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal;\n/**\n * Provides the state to generate a sourcemap.\n */\nclass GenMapping {\n    constructor({ file, sourceRoot } = {}) {\n        this._names = new SetArray();\n        this._sources = new SetArray();\n        this._sourcesContent = [];\n        this._mappings = [];\n        this.file = file;\n        this.sourceRoot = sourceRoot;\n    }\n}\n(() => {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name);\n    };\n    maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name);\n    };\n    addMapping = (map, mapping) => {\n        return addMappingInternal(false, map, mapping);\n    };\n    maybeAddMapping = (map, mapping) => {\n        return addMappingInternal(true, map, mapping);\n    };\n    setSourceContent = (map, source, content) => {\n        const { _sources: sources, _sourcesContent: sourcesContent } = map;\n        sourcesContent[put(sources, source)] = content;\n    };\n    toDecodedMap = (map) => {\n        const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n        removeEmptyFinalLines(mappings);\n        return {\n            version: 3,\n            file: file || undefined,\n            names: names.array,\n            sourceRoot: sourceRoot || undefined,\n            sources: sources.array,\n            sourcesContent,\n            mappings,\n        };\n    };\n    toEncodedMap = (map) => {\n        const decoded = toDecodedMap(map);\n        return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });\n    };\n    allMappings = (map) => {\n        const out = [];\n        const { _mappings: mappings, _sources: sources, _names: names } = map;\n        for (let i = 0; i < mappings.length; i++) {\n            const line = mappings[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generated = { line: i + 1, column: seg[COLUMN] };\n                let source = undefined;\n                let original = undefined;\n                let name = undefined;\n                if (seg.length !== 1) {\n                    source = sources.array[seg[SOURCES_INDEX]];\n                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                    if (seg.length === 5)\n                        name = names.array[seg[NAMES_INDEX]];\n                }\n                out.push({ generated, source, original, name });\n            }\n        }\n        return out;\n    };\n    fromMap = (input) => {\n        const map = new TraceMap(input);\n        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n        putAll(gen._names, map.names);\n        putAll(gen._sources, map.sources);\n        gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n        gen._mappings = decodedMappings(map);\n        return gen;\n    };\n    // Internal helpers\n    addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n        const line = getLine(mappings, genLine);\n        const index = getColumnIndex(line, genColumn);\n        if (!source) {\n            if (skipable && skipSourceless(line, index))\n                return;\n            return insert(line, index, [genColumn]);\n        }\n        const sourcesIndex = put(sources, source);\n        const namesIndex = name ? put(names, name) : NO_NAME;\n        if (sourcesIndex === sourcesContent.length)\n            sourcesContent[sourcesIndex] = null;\n        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n            return;\n        }\n        return insert(line, index, name\n            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    };\n})();\nfunction getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n        mappings[i] = [];\n    }\n    return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n        const current = line[i];\n        if (genColumn >= current[COLUMN])\n            break;\n    }\n    return index;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n    const { length } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n        if (mappings[i].length > 0)\n            break;\n    }\n    if (len < length)\n        mappings.length = len;\n}\nfunction putAll(strarr, array) {\n    for (let i = 0; i < array.length; i++)\n        put(strarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0)\n        return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0)\n        return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1)\n        return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return (sourcesIndex === prev[SOURCES_INDEX] &&\n        sourceLine === prev[SOURCE_LINE] &&\n        sourceColumn === prev[SOURCE_COLUMN] &&\n        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n}\nfunction addMappingInternal(skipable, map, mapping) {\n    const { generated, source, original, name } = mapping;\n    if (!source) {\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null);\n    }\n    const s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name);\n}\n\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setSourceContent, toDecodedMap, toEncodedMap };\n//# sourceMappingURL=gen-mapping.mjs.map\n","import { AnyMap, originalPositionFor } from '@jridgewell/trace-mapping';\nimport {\n  GenMapping,\n  maybeAddMapping,\n  toDecodedMap,\n  toEncodedMap,\n  setSourceContent,\n} from '@jridgewell/gen-mapping';\n\nimport type { TraceMap, SectionedSourceMapInput } from '@jridgewell/trace-mapping';\nexport type { TraceMap, SectionedSourceMapInput };\n\nimport type { Mapping, EncodedSourceMap, DecodedSourceMap } from '@jridgewell/gen-mapping';\nexport type { Mapping, EncodedSourceMap, DecodedSourceMap };\n\nexport class SourceMapConsumer {\n  private declare _map: TraceMap;\n  declare file: TraceMap['file'];\n  declare names: TraceMap['names'];\n  declare sourceRoot: TraceMap['sourceRoot'];\n  declare sources: TraceMap['sources'];\n  declare sourcesContent: TraceMap['sourcesContent'];\n\n  constructor(map: ConstructorParameters<typeof AnyMap>[0], mapUrl: Parameters<typeof AnyMap>[1]) {\n    const trace = (this._map = new AnyMap(map, mapUrl));\n\n    this.file = trace.file;\n    this.names = trace.names;\n    this.sourceRoot = trace.sourceRoot;\n    this.sources = trace.resolvedSources;\n    this.sourcesContent = trace.sourcesContent;\n  }\n\n  originalPositionFor(\n    needle: Parameters<typeof originalPositionFor>[1],\n  ): ReturnType<typeof originalPositionFor> {\n    return originalPositionFor(this._map, needle);\n  }\n\n  destroy() {\n    // noop.\n  }\n}\n\nexport class SourceMapGenerator {\n  private declare _map: GenMapping;\n\n  constructor(opts: ConstructorParameters<typeof GenMapping>[0]) {\n    this._map = new GenMapping(opts);\n  }\n\n  addMapping(mapping: Parameters<typeof maybeAddMapping>[1]): ReturnType<typeof maybeAddMapping> {\n    maybeAddMapping(this._map, mapping);\n  }\n\n  setSourceContent(\n    source: Parameters<typeof setSourceContent>[1],\n    content: Parameters<typeof setSourceContent>[2],\n  ): ReturnType<typeof setSourceContent> {\n    setSourceContent(this._map, source, content);\n  }\n\n  toJSON(): ReturnType<typeof toEncodedMap> {\n    return toEncodedMap(this._map);\n  }\n\n  toDecodedMap(): ReturnType<typeof toDecodedMap> {\n    return toDecodedMap(this._map);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}