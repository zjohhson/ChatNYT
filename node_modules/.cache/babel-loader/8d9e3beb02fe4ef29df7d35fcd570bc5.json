{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"estree\").Node} Node */\n\n/** @typedef {import(\"./JavascriptParser\").Range} Range */\n\n/** @typedef {import(\"./JavascriptParser\").VariableInfoInterface} VariableInfoInterface */\n\nconst TypeUnknown = 0;\nconst TypeUndefined = 1;\nconst TypeNull = 2;\nconst TypeString = 3;\nconst TypeNumber = 4;\nconst TypeBoolean = 5;\nconst TypeRegExp = 6;\nconst TypeConditional = 7;\nconst TypeArray = 8;\nconst TypeConstArray = 9;\nconst TypeIdentifier = 10;\nconst TypeWrapped = 11;\nconst TypeTemplateString = 12;\nconst TypeBigInt = 13;\n\nclass BasicEvaluatedExpression {\n  constructor() {\n    this.type = TypeUnknown;\n    /** @type {[number, number] | undefined} */\n\n    this.range = undefined;\n    /** @type {boolean} */\n\n    this.falsy = false;\n    /** @type {boolean} */\n\n    this.truthy = false;\n    /** @type {boolean | undefined} */\n\n    this.nullish = undefined;\n    /** @type {boolean} */\n\n    this.sideEffects = true;\n    /** @type {boolean | undefined} */\n\n    this.bool = undefined;\n    /** @type {number | undefined} */\n\n    this.number = undefined;\n    /** @type {bigint | undefined} */\n\n    this.bigint = undefined;\n    /** @type {RegExp | undefined} */\n\n    this.regExp = undefined;\n    /** @type {string | undefined} */\n\n    this.string = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n\n    this.quasis = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n\n    this.parts = undefined;\n    /** @type {any[] | undefined} */\n\n    this.array = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n\n    this.items = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n\n    this.options = undefined;\n    /** @type {BasicEvaluatedExpression | undefined | null} */\n\n    this.prefix = undefined;\n    /** @type {BasicEvaluatedExpression | undefined | null} */\n\n    this.postfix = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n\n    this.wrappedInnerExpressions = undefined;\n    /** @type {string | VariableInfoInterface | undefined} */\n\n    this.identifier = undefined;\n    /** @type {string | VariableInfoInterface | undefined} */\n\n    this.rootInfo = undefined;\n    /** @type {(() => string[]) | undefined} */\n\n    this.getMembers = undefined;\n    /** @type {(() => boolean[]) | undefined} */\n\n    this.getMembersOptionals = undefined;\n    /** @type {(() => Range[]) | undefined} */\n\n    this.getMemberRanges = undefined;\n    /** @type {Node | undefined} */\n\n    this.expression = undefined;\n  }\n\n  isUnknown() {\n    return this.type === TypeUnknown;\n  }\n\n  isNull() {\n    return this.type === TypeNull;\n  }\n\n  isUndefined() {\n    return this.type === TypeUndefined;\n  }\n\n  isString() {\n    return this.type === TypeString;\n  }\n\n  isNumber() {\n    return this.type === TypeNumber;\n  }\n\n  isBigInt() {\n    return this.type === TypeBigInt;\n  }\n\n  isBoolean() {\n    return this.type === TypeBoolean;\n  }\n\n  isRegExp() {\n    return this.type === TypeRegExp;\n  }\n\n  isConditional() {\n    return this.type === TypeConditional;\n  }\n\n  isArray() {\n    return this.type === TypeArray;\n  }\n\n  isConstArray() {\n    return this.type === TypeConstArray;\n  }\n\n  isIdentifier() {\n    return this.type === TypeIdentifier;\n  }\n\n  isWrapped() {\n    return this.type === TypeWrapped;\n  }\n\n  isTemplateString() {\n    return this.type === TypeTemplateString;\n  }\n  /**\n   * Is expression a primitive or an object type value?\n   * @returns {boolean | undefined} true: primitive type, false: object type, undefined: unknown/runtime-defined\n   */\n\n\n  isPrimitiveType() {\n    switch (this.type) {\n      case TypeUndefined:\n      case TypeNull:\n      case TypeString:\n      case TypeNumber:\n      case TypeBoolean:\n      case TypeBigInt:\n      case TypeWrapped:\n      case TypeTemplateString:\n        return true;\n\n      case TypeRegExp:\n      case TypeArray:\n      case TypeConstArray:\n        return false;\n\n      default:\n        return undefined;\n    }\n  }\n  /**\n   * Is expression a runtime or compile-time value?\n   * @returns {boolean} true: compile time value, false: runtime value\n   */\n\n\n  isCompileTimeValue() {\n    switch (this.type) {\n      case TypeUndefined:\n      case TypeNull:\n      case TypeString:\n      case TypeNumber:\n      case TypeBoolean:\n      case TypeRegExp:\n      case TypeConstArray:\n      case TypeBigInt:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * Gets the compile-time value of the expression\n   * @returns {any} the javascript value\n   */\n\n\n  asCompileTimeValue() {\n    switch (this.type) {\n      case TypeUndefined:\n        return undefined;\n\n      case TypeNull:\n        return null;\n\n      case TypeString:\n        return this.string;\n\n      case TypeNumber:\n        return this.number;\n\n      case TypeBoolean:\n        return this.bool;\n\n      case TypeRegExp:\n        return this.regExp;\n\n      case TypeConstArray:\n        return this.array;\n\n      case TypeBigInt:\n        return this.bigint;\n\n      default:\n        throw new Error(\"asCompileTimeValue must only be called for compile-time values\");\n    }\n  }\n\n  isTruthy() {\n    return this.truthy;\n  }\n\n  isFalsy() {\n    return this.falsy;\n  }\n\n  isNullish() {\n    return this.nullish;\n  }\n  /**\n   * Can this expression have side effects?\n   * @returns {boolean} false: never has side effects\n   */\n\n\n  couldHaveSideEffects() {\n    return this.sideEffects;\n  }\n  /**\n   * Creates a boolean representation of this evaluated expression.\n   * @returns {boolean | undefined} true: truthy, false: falsy, undefined: unknown\n   */\n\n\n  asBool() {\n    if (this.truthy) return true;\n    if (this.falsy || this.nullish) return false;\n    if (this.isBoolean()) return this.bool;\n    if (this.isNull()) return false;\n    if (this.isUndefined()) return false;\n    if (this.isString()) return this.string !== \"\";\n    if (this.isNumber()) return this.number !== 0;\n    if (this.isBigInt()) return this.bigint !== BigInt(0);\n    if (this.isRegExp()) return true;\n    if (this.isArray()) return true;\n    if (this.isConstArray()) return true;\n\n    if (this.isWrapped()) {\n      return this.prefix && this.prefix.asBool() || this.postfix && this.postfix.asBool() ? true : undefined;\n    }\n\n    if (this.isTemplateString()) {\n      const str = this.asString();\n      if (typeof str === \"string\") return str !== \"\";\n    }\n\n    return undefined;\n  }\n  /**\n   * Creates a nullish coalescing representation of this evaluated expression.\n   * @returns {boolean | undefined} true: nullish, false: not nullish, undefined: unknown\n   */\n\n\n  asNullish() {\n    const nullish = this.isNullish();\n    if (nullish === true || this.isNull() || this.isUndefined()) return true;\n    if (nullish === false) return false;\n    if (this.isTruthy()) return false;\n    if (this.isBoolean()) return false;\n    if (this.isString()) return false;\n    if (this.isNumber()) return false;\n    if (this.isBigInt()) return false;\n    if (this.isRegExp()) return false;\n    if (this.isArray()) return false;\n    if (this.isConstArray()) return false;\n    if (this.isTemplateString()) return false;\n    if (this.isRegExp()) return false;\n    return undefined;\n  }\n  /**\n   * Creates a string representation of this evaluated expression.\n   * @returns {string | undefined} the string representation or undefined if not possible\n   */\n\n\n  asString() {\n    if (this.isBoolean()) return `${this.bool}`;\n    if (this.isNull()) return \"null\";\n    if (this.isUndefined()) return \"undefined\";\n    if (this.isString()) return this.string;\n    if (this.isNumber()) return `${this.number}`;\n    if (this.isBigInt()) return `${this.bigint}`;\n    if (this.isRegExp()) return `${this.regExp}`;\n\n    if (this.isArray()) {\n      let array = [];\n\n      for (const item of\n      /** @type {BasicEvaluatedExpression[]} */\n      this.items) {\n        const itemStr = item.asString();\n        if (itemStr === undefined) return undefined;\n        array.push(itemStr);\n      }\n\n      return `${array}`;\n    }\n\n    if (this.isConstArray()) return `${this.array}`;\n\n    if (this.isTemplateString()) {\n      let str = \"\";\n\n      for (const part of\n      /** @type {BasicEvaluatedExpression[]} */\n      this.parts) {\n        const partStr = part.asString();\n        if (partStr === undefined) return undefined;\n        str += partStr;\n      }\n\n      return str;\n    }\n\n    return undefined;\n  }\n  /**\n   * @param {string} string value\n   * @returns {BasicEvaluatedExpression} basic evaluated expression\n   */\n\n\n  setString(string) {\n    this.type = TypeString;\n    this.string = string;\n    this.sideEffects = false;\n    return this;\n  }\n\n  setUndefined() {\n    this.type = TypeUndefined;\n    this.sideEffects = false;\n    return this;\n  }\n\n  setNull() {\n    this.type = TypeNull;\n    this.sideEffects = false;\n    return this;\n  }\n  /**\n   * Set's the value of this expression to a number\n   * @param {number} number number to set\n   * @returns {this} this\n   */\n\n\n  setNumber(number) {\n    this.type = TypeNumber;\n    this.number = number;\n    this.sideEffects = false;\n    return this;\n  }\n  /**\n   * Set's the value of this expression to a BigInt\n   * @param {bigint} bigint bigint to set\n   * @returns {this} this\n   */\n\n\n  setBigInt(bigint) {\n    this.type = TypeBigInt;\n    this.bigint = bigint;\n    this.sideEffects = false;\n    return this;\n  }\n  /**\n   * Set's the value of this expression to a boolean\n   * @param {boolean} bool boolean to set\n   * @returns {this} this\n   */\n\n\n  setBoolean(bool) {\n    this.type = TypeBoolean;\n    this.bool = bool;\n    this.sideEffects = false;\n    return this;\n  }\n  /**\n   * Set's the value of this expression to a regular expression\n   * @param {RegExp} regExp regular expression to set\n   * @returns {this} this\n   */\n\n\n  setRegExp(regExp) {\n    this.type = TypeRegExp;\n    this.regExp = regExp;\n    this.sideEffects = false;\n    return this;\n  }\n  /**\n   * Set's the value of this expression to a particular identifier and its members.\n   *\n   * @param {string | VariableInfoInterface} identifier identifier to set\n   * @param {string | VariableInfoInterface} rootInfo root info\n   * @param {() => string[]} getMembers members\n   * @param {() => boolean[]=} getMembersOptionals optional members\n   * @param {() => Range[]=} getMemberRanges ranges of progressively increasing sub-expressions\n   * @returns {this} this\n   */\n\n\n  setIdentifier(identifier, rootInfo, getMembers, getMembersOptionals, getMemberRanges) {\n    this.type = TypeIdentifier;\n    this.identifier = identifier;\n    this.rootInfo = rootInfo;\n    this.getMembers = getMembers;\n    this.getMembersOptionals = getMembersOptionals;\n    this.getMemberRanges = getMemberRanges;\n    this.sideEffects = true;\n    return this;\n  }\n  /**\n   * Wraps an array of expressions with a prefix and postfix expression.\n   *\n   * @param {BasicEvaluatedExpression | null | undefined} prefix Expression to be added before the innerExpressions\n   * @param {BasicEvaluatedExpression | null | undefined} postfix Expression to be added after the innerExpressions\n   * @param {BasicEvaluatedExpression[]} innerExpressions Expressions to be wrapped\n   * @returns {this} this\n   */\n\n\n  setWrapped(prefix, postfix, innerExpressions) {\n    this.type = TypeWrapped;\n    this.prefix = prefix;\n    this.postfix = postfix;\n    this.wrappedInnerExpressions = innerExpressions;\n    this.sideEffects = true;\n    return this;\n  }\n  /**\n   * Stores the options of a conditional expression.\n   *\n   * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be set\n   * @returns {this} this\n   */\n\n\n  setOptions(options) {\n    this.type = TypeConditional;\n    this.options = options;\n    this.sideEffects = true;\n    return this;\n  }\n  /**\n   * Adds options to a conditional expression.\n   *\n   * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be added\n   * @returns {this} this\n   */\n\n\n  addOptions(options) {\n    if (!this.options) {\n      this.type = TypeConditional;\n      this.options = [];\n      this.sideEffects = true;\n    }\n\n    for (const item of options) {\n      this.options.push(item);\n    }\n\n    return this;\n  }\n  /**\n   * Set's the value of this expression to an array of expressions.\n   *\n   * @param {BasicEvaluatedExpression[]} items expressions to set\n   * @returns {this} this\n   */\n\n\n  setItems(items) {\n    this.type = TypeArray;\n    this.items = items;\n    this.sideEffects = items.some(i => i.couldHaveSideEffects());\n    return this;\n  }\n  /**\n   * Set's the value of this expression to an array of strings.\n   *\n   * @param {string[]} array array to set\n   * @returns {this} this\n   */\n\n\n  setArray(array) {\n    this.type = TypeConstArray;\n    this.array = array;\n    this.sideEffects = false;\n    return this;\n  }\n  /**\n   * Set's the value of this expression to a processed/unprocessed template string. Used\n   * for evaluating TemplateLiteral expressions in the JavaScript Parser.\n   *\n   * @param {BasicEvaluatedExpression[]} quasis template string quasis\n   * @param {BasicEvaluatedExpression[]} parts template string parts\n   * @param {\"cooked\" | \"raw\"} kind template string kind\n   * @returns {this} this\n   */\n\n\n  setTemplateString(quasis, parts, kind) {\n    this.type = TypeTemplateString;\n    this.quasis = quasis;\n    this.parts = parts;\n    this.templateStringKind = kind;\n    this.sideEffects = parts.some(p => p.sideEffects);\n    return this;\n  }\n\n  setTruthy() {\n    this.falsy = false;\n    this.truthy = true;\n    this.nullish = false;\n    return this;\n  }\n\n  setFalsy() {\n    this.falsy = true;\n    this.truthy = false;\n    return this;\n  }\n  /**\n   * Set's the value of the expression to nullish.\n   *\n   * @param {boolean} value true, if the expression is nullish\n   * @returns {this} this\n   */\n\n\n  setNullish(value) {\n    this.nullish = value;\n    if (value) return this.setFalsy();\n    return this;\n  }\n  /**\n   * Set's the range for the expression.\n   *\n   * @param {[number, number]} range range to set\n   * @returns {this} this\n   */\n\n\n  setRange(range) {\n    this.range = range;\n    return this;\n  }\n  /**\n   * Set whether or not the expression has side effects.\n   *\n   * @param {boolean} sideEffects true, if the expression has side effects\n   * @returns {this} this\n   */\n\n\n  setSideEffects() {\n    let sideEffects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.sideEffects = sideEffects;\n    return this;\n  }\n  /**\n   * Set the expression node for the expression.\n   *\n   * @param {Node | undefined} expression expression\n   * @returns {this} this\n   */\n\n\n  setExpression(expression) {\n    this.expression = expression;\n    return this;\n  }\n\n}\n/**\n * @param {string} flags regexp flags\n * @returns {boolean} is valid flags\n */\n\n\nBasicEvaluatedExpression.isValidRegExpFlags = flags => {\n  const len = flags.length;\n  if (len === 0) return true;\n  if (len > 4) return false; // cspell:word gimy\n\n  let remaining = 0b0000; // bit per RegExp flag: gimy\n\n  for (let i = 0; i < len; i++) switch (flags.charCodeAt(i)) {\n    case 103\n    /* g */\n    :\n      if (remaining & 0b1000) return false;\n      remaining |= 0b1000;\n      break;\n\n    case 105\n    /* i */\n    :\n      if (remaining & 0b0100) return false;\n      remaining |= 0b0100;\n      break;\n\n    case 109\n    /* m */\n    :\n      if (remaining & 0b0010) return false;\n      remaining |= 0b0010;\n      break;\n\n    case 121\n    /* y */\n    :\n      if (remaining & 0b0001) return false;\n      remaining |= 0b0001;\n      break;\n\n    default:\n      return false;\n  }\n\n  return true;\n};\n\nmodule.exports = BasicEvaluatedExpression;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/javascript/BasicEvaluatedExpression.js"],"names":["TypeUnknown","TypeUndefined","TypeNull","TypeString","TypeNumber","TypeBoolean","TypeRegExp","TypeConditional","TypeArray","TypeConstArray","TypeIdentifier","TypeWrapped","TypeTemplateString","TypeBigInt","BasicEvaluatedExpression","constructor","type","range","undefined","falsy","truthy","nullish","sideEffects","bool","number","bigint","regExp","string","quasis","parts","array","items","options","prefix","postfix","wrappedInnerExpressions","identifier","rootInfo","getMembers","getMembersOptionals","getMemberRanges","expression","isUnknown","isNull","isUndefined","isString","isNumber","isBigInt","isBoolean","isRegExp","isConditional","isArray","isConstArray","isIdentifier","isWrapped","isTemplateString","isPrimitiveType","isCompileTimeValue","asCompileTimeValue","Error","isTruthy","isFalsy","isNullish","couldHaveSideEffects","asBool","BigInt","str","asString","asNullish","item","itemStr","push","part","partStr","setString","setUndefined","setNull","setNumber","setBigInt","setBoolean","setRegExp","setIdentifier","setWrapped","innerExpressions","setOptions","addOptions","setItems","some","i","setArray","setTemplateString","kind","templateStringKind","p","setTruthy","setFalsy","setNullish","value","setRange","setSideEffects","setExpression","isValidRegExpFlags","flags","len","length","remaining","charCodeAt","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AACA;;AAEA,MAAMA,WAAW,GAAG,CAApB;AACA,MAAMC,aAAa,GAAG,CAAtB;AACA,MAAMC,QAAQ,GAAG,CAAjB;AACA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,eAAe,GAAG,CAAxB;AACA,MAAMC,SAAS,GAAG,CAAlB;AACA,MAAMC,cAAc,GAAG,CAAvB;AACA,MAAMC,cAAc,GAAG,EAAvB;AACA,MAAMC,WAAW,GAAG,EAApB;AACA,MAAMC,kBAAkB,GAAG,EAA3B;AACA,MAAMC,UAAU,GAAG,EAAnB;;AAEA,MAAMC,wBAAN,CAA+B;AAC9BC,EAAAA,WAAW,GAAG;AACb,SAAKC,IAAL,GAAYhB,WAAZ;AACA;;AACA,SAAKiB,KAAL,GAAaC,SAAb;AACA;;AACA,SAAKC,KAAL,GAAa,KAAb;AACA;;AACA,SAAKC,MAAL,GAAc,KAAd;AACA;;AACA,SAAKC,OAAL,GAAeH,SAAf;AACA;;AACA,SAAKI,WAAL,GAAmB,IAAnB;AACA;;AACA,SAAKC,IAAL,GAAYL,SAAZ;AACA;;AACA,SAAKM,MAAL,GAAcN,SAAd;AACA;;AACA,SAAKO,MAAL,GAAcP,SAAd;AACA;;AACA,SAAKQ,MAAL,GAAcR,SAAd;AACA;;AACA,SAAKS,MAAL,GAAcT,SAAd;AACA;;AACA,SAAKU,MAAL,GAAcV,SAAd;AACA;;AACA,SAAKW,KAAL,GAAaX,SAAb;AACA;;AACA,SAAKY,KAAL,GAAaZ,SAAb;AACA;;AACA,SAAKa,KAAL,GAAab,SAAb;AACA;;AACA,SAAKc,OAAL,GAAed,SAAf;AACA;;AACA,SAAKe,MAAL,GAAcf,SAAd;AACA;;AACA,SAAKgB,OAAL,GAAehB,SAAf;AACA;;AACA,SAAKiB,uBAAL,GAA+BjB,SAA/B;AACA;;AACA,SAAKkB,UAAL,GAAkBlB,SAAlB;AACA;;AACA,SAAKmB,QAAL,GAAgBnB,SAAhB;AACA;;AACA,SAAKoB,UAAL,GAAkBpB,SAAlB;AACA;;AACA,SAAKqB,mBAAL,GAA2BrB,SAA3B;AACA;;AACA,SAAKsB,eAAL,GAAuBtB,SAAvB;AACA;;AACA,SAAKuB,UAAL,GAAkBvB,SAAlB;AACA;;AAEDwB,EAAAA,SAAS,GAAG;AACX,WAAO,KAAK1B,IAAL,KAAchB,WAArB;AACA;;AAED2C,EAAAA,MAAM,GAAG;AACR,WAAO,KAAK3B,IAAL,KAAcd,QAArB;AACA;;AAED0C,EAAAA,WAAW,GAAG;AACb,WAAO,KAAK5B,IAAL,KAAcf,aAArB;AACA;;AAED4C,EAAAA,QAAQ,GAAG;AACV,WAAO,KAAK7B,IAAL,KAAcb,UAArB;AACA;;AAED2C,EAAAA,QAAQ,GAAG;AACV,WAAO,KAAK9B,IAAL,KAAcZ,UAArB;AACA;;AAED2C,EAAAA,QAAQ,GAAG;AACV,WAAO,KAAK/B,IAAL,KAAcH,UAArB;AACA;;AAEDmC,EAAAA,SAAS,GAAG;AACX,WAAO,KAAKhC,IAAL,KAAcX,WAArB;AACA;;AAED4C,EAAAA,QAAQ,GAAG;AACV,WAAO,KAAKjC,IAAL,KAAcV,UAArB;AACA;;AAED4C,EAAAA,aAAa,GAAG;AACf,WAAO,KAAKlC,IAAL,KAAcT,eAArB;AACA;;AAED4C,EAAAA,OAAO,GAAG;AACT,WAAO,KAAKnC,IAAL,KAAcR,SAArB;AACA;;AAED4C,EAAAA,YAAY,GAAG;AACd,WAAO,KAAKpC,IAAL,KAAcP,cAArB;AACA;;AAED4C,EAAAA,YAAY,GAAG;AACd,WAAO,KAAKrC,IAAL,KAAcN,cAArB;AACA;;AAED4C,EAAAA,SAAS,GAAG;AACX,WAAO,KAAKtC,IAAL,KAAcL,WAArB;AACA;;AAED4C,EAAAA,gBAAgB,GAAG;AAClB,WAAO,KAAKvC,IAAL,KAAcJ,kBAArB;AACA;AAED;AACD;AACA;AACA;;;AACC4C,EAAAA,eAAe,GAAG;AACjB,YAAQ,KAAKxC,IAAb;AACC,WAAKf,aAAL;AACA,WAAKC,QAAL;AACA,WAAKC,UAAL;AACA,WAAKC,UAAL;AACA,WAAKC,WAAL;AACA,WAAKQ,UAAL;AACA,WAAKF,WAAL;AACA,WAAKC,kBAAL;AACC,eAAO,IAAP;;AACD,WAAKN,UAAL;AACA,WAAKE,SAAL;AACA,WAAKC,cAAL;AACC,eAAO,KAAP;;AACD;AACC,eAAOS,SAAP;AAfF;AAiBA;AAED;AACD;AACA;AACA;;;AACCuC,EAAAA,kBAAkB,GAAG;AACpB,YAAQ,KAAKzC,IAAb;AACC,WAAKf,aAAL;AACA,WAAKC,QAAL;AACA,WAAKC,UAAL;AACA,WAAKC,UAAL;AACA,WAAKC,WAAL;AACA,WAAKC,UAAL;AACA,WAAKG,cAAL;AACA,WAAKI,UAAL;AACC,eAAO,IAAP;;AACD;AACC,eAAO,KAAP;AAXF;AAaA;AAED;AACD;AACA;AACA;;;AACC6C,EAAAA,kBAAkB,GAAG;AACpB,YAAQ,KAAK1C,IAAb;AACC,WAAKf,aAAL;AACC,eAAOiB,SAAP;;AACD,WAAKhB,QAAL;AACC,eAAO,IAAP;;AACD,WAAKC,UAAL;AACC,eAAO,KAAKwB,MAAZ;;AACD,WAAKvB,UAAL;AACC,eAAO,KAAKoB,MAAZ;;AACD,WAAKnB,WAAL;AACC,eAAO,KAAKkB,IAAZ;;AACD,WAAKjB,UAAL;AACC,eAAO,KAAKoB,MAAZ;;AACD,WAAKjB,cAAL;AACC,eAAO,KAAKqB,KAAZ;;AACD,WAAKjB,UAAL;AACC,eAAO,KAAKY,MAAZ;;AACD;AACC,cAAM,IAAIkC,KAAJ,CACL,gEADK,CAAN;AAlBF;AAsBA;;AAEDC,EAAAA,QAAQ,GAAG;AACV,WAAO,KAAKxC,MAAZ;AACA;;AAEDyC,EAAAA,OAAO,GAAG;AACT,WAAO,KAAK1C,KAAZ;AACA;;AAED2C,EAAAA,SAAS,GAAG;AACX,WAAO,KAAKzC,OAAZ;AACA;AAED;AACD;AACA;AACA;;;AACC0C,EAAAA,oBAAoB,GAAG;AACtB,WAAO,KAAKzC,WAAZ;AACA;AAED;AACD;AACA;AACA;;;AACC0C,EAAAA,MAAM,GAAG;AACR,QAAI,KAAK5C,MAAT,EAAiB,OAAO,IAAP;AACjB,QAAI,KAAKD,KAAL,IAAc,KAAKE,OAAvB,EAAgC,OAAO,KAAP;AAChC,QAAI,KAAK2B,SAAL,EAAJ,EAAsB,OAAO,KAAKzB,IAAZ;AACtB,QAAI,KAAKoB,MAAL,EAAJ,EAAmB,OAAO,KAAP;AACnB,QAAI,KAAKC,WAAL,EAAJ,EAAwB,OAAO,KAAP;AACxB,QAAI,KAAKC,QAAL,EAAJ,EAAqB,OAAO,KAAKlB,MAAL,KAAgB,EAAvB;AACrB,QAAI,KAAKmB,QAAL,EAAJ,EAAqB,OAAO,KAAKtB,MAAL,KAAgB,CAAvB;AACrB,QAAI,KAAKuB,QAAL,EAAJ,EAAqB,OAAO,KAAKtB,MAAL,KAAgBwC,MAAM,CAAC,CAAD,CAA7B;AACrB,QAAI,KAAKhB,QAAL,EAAJ,EAAqB,OAAO,IAAP;AACrB,QAAI,KAAKE,OAAL,EAAJ,EAAoB,OAAO,IAAP;AACpB,QAAI,KAAKC,YAAL,EAAJ,EAAyB,OAAO,IAAP;;AACzB,QAAI,KAAKE,SAAL,EAAJ,EAAsB;AACrB,aAAQ,KAAKrB,MAAL,IAAe,KAAKA,MAAL,CAAY+B,MAAZ,EAAhB,IACL,KAAK9B,OAAL,IAAgB,KAAKA,OAAL,CAAa8B,MAAb,EADX,GAEJ,IAFI,GAGJ9C,SAHH;AAIA;;AACD,QAAI,KAAKqC,gBAAL,EAAJ,EAA6B;AAC5B,YAAMW,GAAG,GAAG,KAAKC,QAAL,EAAZ;AACA,UAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B,OAAOA,GAAG,KAAK,EAAf;AAC7B;;AACD,WAAOhD,SAAP;AACA;AAED;AACD;AACA;AACA;;;AACCkD,EAAAA,SAAS,GAAG;AACX,UAAM/C,OAAO,GAAG,KAAKyC,SAAL,EAAhB;AAEA,QAAIzC,OAAO,KAAK,IAAZ,IAAoB,KAAKsB,MAAL,EAApB,IAAqC,KAAKC,WAAL,EAAzC,EAA6D,OAAO,IAAP;AAE7D,QAAIvB,OAAO,KAAK,KAAhB,EAAuB,OAAO,KAAP;AACvB,QAAI,KAAKuC,QAAL,EAAJ,EAAqB,OAAO,KAAP;AACrB,QAAI,KAAKZ,SAAL,EAAJ,EAAsB,OAAO,KAAP;AACtB,QAAI,KAAKH,QAAL,EAAJ,EAAqB,OAAO,KAAP;AACrB,QAAI,KAAKC,QAAL,EAAJ,EAAqB,OAAO,KAAP;AACrB,QAAI,KAAKC,QAAL,EAAJ,EAAqB,OAAO,KAAP;AACrB,QAAI,KAAKE,QAAL,EAAJ,EAAqB,OAAO,KAAP;AACrB,QAAI,KAAKE,OAAL,EAAJ,EAAoB,OAAO,KAAP;AACpB,QAAI,KAAKC,YAAL,EAAJ,EAAyB,OAAO,KAAP;AACzB,QAAI,KAAKG,gBAAL,EAAJ,EAA6B,OAAO,KAAP;AAC7B,QAAI,KAAKN,QAAL,EAAJ,EAAqB,OAAO,KAAP;AAErB,WAAO/B,SAAP;AACA;AAED;AACD;AACA;AACA;;;AACCiD,EAAAA,QAAQ,GAAG;AACV,QAAI,KAAKnB,SAAL,EAAJ,EAAsB,OAAQ,GAAE,KAAKzB,IAAK,EAApB;AACtB,QAAI,KAAKoB,MAAL,EAAJ,EAAmB,OAAO,MAAP;AACnB,QAAI,KAAKC,WAAL,EAAJ,EAAwB,OAAO,WAAP;AACxB,QAAI,KAAKC,QAAL,EAAJ,EAAqB,OAAO,KAAKlB,MAAZ;AACrB,QAAI,KAAKmB,QAAL,EAAJ,EAAqB,OAAQ,GAAE,KAAKtB,MAAO,EAAtB;AACrB,QAAI,KAAKuB,QAAL,EAAJ,EAAqB,OAAQ,GAAE,KAAKtB,MAAO,EAAtB;AACrB,QAAI,KAAKwB,QAAL,EAAJ,EAAqB,OAAQ,GAAE,KAAKvB,MAAO,EAAtB;;AACrB,QAAI,KAAKyB,OAAL,EAAJ,EAAoB;AACnB,UAAIrB,KAAK,GAAG,EAAZ;;AACA,WAAK,MAAMuC,IAAX;AAAmB;AAClB,WAAKtC,KADN,EAEG;AACF,cAAMuC,OAAO,GAAGD,IAAI,CAACF,QAAL,EAAhB;AACA,YAAIG,OAAO,KAAKpD,SAAhB,EAA2B,OAAOA,SAAP;AAC3BY,QAAAA,KAAK,CAACyC,IAAN,CAAWD,OAAX;AACA;;AACD,aAAQ,GAAExC,KAAM,EAAhB;AACA;;AACD,QAAI,KAAKsB,YAAL,EAAJ,EAAyB,OAAQ,GAAE,KAAKtB,KAAM,EAArB;;AACzB,QAAI,KAAKyB,gBAAL,EAAJ,EAA6B;AAC5B,UAAIW,GAAG,GAAG,EAAV;;AACA,WAAK,MAAMM,IAAX;AAAmB;AAClB,WAAK3C,KADN,EAEG;AACF,cAAM4C,OAAO,GAAGD,IAAI,CAACL,QAAL,EAAhB;AACA,YAAIM,OAAO,KAAKvD,SAAhB,EAA2B,OAAOA,SAAP;AAC3BgD,QAAAA,GAAG,IAAIO,OAAP;AACA;;AACD,aAAOP,GAAP;AACA;;AACD,WAAOhD,SAAP;AACA;AAED;AACD;AACA;AACA;;;AACCwD,EAAAA,SAAS,CAAC/C,MAAD,EAAS;AACjB,SAAKX,IAAL,GAAYb,UAAZ;AACA,SAAKwB,MAAL,GAAcA,MAAd;AACA,SAAKL,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;;AAEDqD,EAAAA,YAAY,GAAG;AACd,SAAK3D,IAAL,GAAYf,aAAZ;AACA,SAAKqB,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;;AAEDsD,EAAAA,OAAO,GAAG;AACT,SAAK5D,IAAL,GAAYd,QAAZ;AACA,SAAKoB,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCuD,EAAAA,SAAS,CAACrD,MAAD,EAAS;AACjB,SAAKR,IAAL,GAAYZ,UAAZ;AACA,SAAKoB,MAAL,GAAcA,MAAd;AACA,SAAKF,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCwD,EAAAA,SAAS,CAACrD,MAAD,EAAS;AACjB,SAAKT,IAAL,GAAYH,UAAZ;AACA,SAAKY,MAAL,GAAcA,MAAd;AACA,SAAKH,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCyD,EAAAA,UAAU,CAACxD,IAAD,EAAO;AAChB,SAAKP,IAAL,GAAYX,WAAZ;AACA,SAAKkB,IAAL,GAAYA,IAAZ;AACA,SAAKD,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACC0D,EAAAA,SAAS,CAACtD,MAAD,EAAS;AACjB,SAAKV,IAAL,GAAYV,UAAZ;AACA,SAAKoB,MAAL,GAAcA,MAAd;AACA,SAAKJ,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC2D,EAAAA,aAAa,CACZ7C,UADY,EAEZC,QAFY,EAGZC,UAHY,EAIZC,mBAJY,EAKZC,eALY,EAMX;AACD,SAAKxB,IAAL,GAAYN,cAAZ;AACA,SAAK0B,UAAL,GAAkBA,UAAlB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKlB,WAAL,GAAmB,IAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC4D,EAAAA,UAAU,CAACjD,MAAD,EAASC,OAAT,EAAkBiD,gBAAlB,EAAoC;AAC7C,SAAKnE,IAAL,GAAYL,WAAZ;AACA,SAAKsB,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,uBAAL,GAA+BgD,gBAA/B;AACA,SAAK7D,WAAL,GAAmB,IAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC8D,EAAAA,UAAU,CAACpD,OAAD,EAAU;AACnB,SAAKhB,IAAL,GAAYT,eAAZ;AACA,SAAKyB,OAAL,GAAeA,OAAf;AACA,SAAKV,WAAL,GAAmB,IAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC+D,EAAAA,UAAU,CAACrD,OAAD,EAAU;AACnB,QAAI,CAAC,KAAKA,OAAV,EAAmB;AAClB,WAAKhB,IAAL,GAAYT,eAAZ;AACA,WAAKyB,OAAL,GAAe,EAAf;AACA,WAAKV,WAAL,GAAmB,IAAnB;AACA;;AACD,SAAK,MAAM+C,IAAX,IAAmBrC,OAAnB,EAA4B;AAC3B,WAAKA,OAAL,CAAauC,IAAb,CAAkBF,IAAlB;AACA;;AACD,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCiB,EAAAA,QAAQ,CAACvD,KAAD,EAAQ;AACf,SAAKf,IAAL,GAAYR,SAAZ;AACA,SAAKuB,KAAL,GAAaA,KAAb;AACA,SAAKT,WAAL,GAAmBS,KAAK,CAACwD,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACzB,oBAAF,EAAhB,CAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC0B,EAAAA,QAAQ,CAAC3D,KAAD,EAAQ;AACf,SAAKd,IAAL,GAAYP,cAAZ;AACA,SAAKqB,KAAL,GAAaA,KAAb;AACA,SAAKR,WAAL,GAAmB,KAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCoE,EAAAA,iBAAiB,CAAC9D,MAAD,EAASC,KAAT,EAAgB8D,IAAhB,EAAsB;AACtC,SAAK3E,IAAL,GAAYJ,kBAAZ;AACA,SAAKgB,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAK+D,kBAAL,GAA0BD,IAA1B;AACA,SAAKrE,WAAL,GAAmBO,KAAK,CAAC0D,IAAN,CAAWM,CAAC,IAAIA,CAAC,CAACvE,WAAlB,CAAnB;AACA,WAAO,IAAP;AACA;;AAEDwE,EAAAA,SAAS,GAAG;AACX,SAAK3E,KAAL,GAAa,KAAb;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,OAAL,GAAe,KAAf;AACA,WAAO,IAAP;AACA;;AAED0E,EAAAA,QAAQ,GAAG;AACV,SAAK5E,KAAL,GAAa,IAAb;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC4E,EAAAA,UAAU,CAACC,KAAD,EAAQ;AACjB,SAAK5E,OAAL,GAAe4E,KAAf;AAEA,QAAIA,KAAJ,EAAW,OAAO,KAAKF,QAAL,EAAP;AAEX,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,QAAQ,CAACjF,KAAD,EAAQ;AACf,SAAKA,KAAL,GAAaA,KAAb;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCkF,EAAAA,cAAc,GAAqB;AAAA,QAApB7E,WAAoB,uEAAN,IAAM;AAClC,SAAKA,WAAL,GAAmBA,WAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC8E,EAAAA,aAAa,CAAC3D,UAAD,EAAa;AACzB,SAAKA,UAAL,GAAkBA,UAAlB;AACA,WAAO,IAAP;AACA;;AA7hB6B;AAgiB/B;AACA;AACA;AACA;;;AACA3B,wBAAwB,CAACuF,kBAAzB,GAA8CC,KAAK,IAAI;AACtD,QAAMC,GAAG,GAAGD,KAAK,CAACE,MAAlB;AAEA,MAAID,GAAG,KAAK,CAAZ,EAAe,OAAO,IAAP;AACf,MAAIA,GAAG,GAAG,CAAV,EAAa,OAAO,KAAP,CAJyC,CAMtD;;AACA,MAAIE,SAAS,GAAG,MAAhB,CAPsD,CAO9B;;AAExB,OAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,GAApB,EAAyBf,CAAC,EAA1B,EACC,QAAQc,KAAK,CAACI,UAAN,CAAiBlB,CAAjB,CAAR;AACC,SAAK;AAAI;AAAT;AACC,UAAIiB,SAAS,GAAG,MAAhB,EAAwB,OAAO,KAAP;AACxBA,MAAAA,SAAS,IAAI,MAAb;AACA;;AACD,SAAK;AAAI;AAAT;AACC,UAAIA,SAAS,GAAG,MAAhB,EAAwB,OAAO,KAAP;AACxBA,MAAAA,SAAS,IAAI,MAAb;AACA;;AACD,SAAK;AAAI;AAAT;AACC,UAAIA,SAAS,GAAG,MAAhB,EAAwB,OAAO,KAAP;AACxBA,MAAAA,SAAS,IAAI,MAAb;AACA;;AACD,SAAK;AAAI;AAAT;AACC,UAAIA,SAAS,GAAG,MAAhB,EAAwB,OAAO,KAAP;AACxBA,MAAAA,SAAS,IAAI,MAAb;AACA;;AACD;AACC,aAAO,KAAP;AAlBF;;AAqBD,SAAO,IAAP;AACA,CAhCD;;AAkCAE,MAAM,CAACC,OAAP,GAAiB9F,wBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"./JavascriptParser\").Range} Range */\n/** @typedef {import(\"./JavascriptParser\").VariableInfoInterface} VariableInfoInterface */\n\nconst TypeUnknown = 0;\nconst TypeUndefined = 1;\nconst TypeNull = 2;\nconst TypeString = 3;\nconst TypeNumber = 4;\nconst TypeBoolean = 5;\nconst TypeRegExp = 6;\nconst TypeConditional = 7;\nconst TypeArray = 8;\nconst TypeConstArray = 9;\nconst TypeIdentifier = 10;\nconst TypeWrapped = 11;\nconst TypeTemplateString = 12;\nconst TypeBigInt = 13;\n\nclass BasicEvaluatedExpression {\n\tconstructor() {\n\t\tthis.type = TypeUnknown;\n\t\t/** @type {[number, number] | undefined} */\n\t\tthis.range = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.falsy = false;\n\t\t/** @type {boolean} */\n\t\tthis.truthy = false;\n\t\t/** @type {boolean | undefined} */\n\t\tthis.nullish = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.sideEffects = true;\n\t\t/** @type {boolean | undefined} */\n\t\tthis.bool = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis.number = undefined;\n\t\t/** @type {bigint | undefined} */\n\t\tthis.bigint = undefined;\n\t\t/** @type {RegExp | undefined} */\n\t\tthis.regExp = undefined;\n\t\t/** @type {string | undefined} */\n\t\tthis.string = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.quasis = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.parts = undefined;\n\t\t/** @type {any[] | undefined} */\n\t\tthis.array = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.items = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.options = undefined;\n\t\t/** @type {BasicEvaluatedExpression | undefined | null} */\n\t\tthis.prefix = undefined;\n\t\t/** @type {BasicEvaluatedExpression | undefined | null} */\n\t\tthis.postfix = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.wrappedInnerExpressions = undefined;\n\t\t/** @type {string | VariableInfoInterface | undefined} */\n\t\tthis.identifier = undefined;\n\t\t/** @type {string | VariableInfoInterface | undefined} */\n\t\tthis.rootInfo = undefined;\n\t\t/** @type {(() => string[]) | undefined} */\n\t\tthis.getMembers = undefined;\n\t\t/** @type {(() => boolean[]) | undefined} */\n\t\tthis.getMembersOptionals = undefined;\n\t\t/** @type {(() => Range[]) | undefined} */\n\t\tthis.getMemberRanges = undefined;\n\t\t/** @type {Node | undefined} */\n\t\tthis.expression = undefined;\n\t}\n\n\tisUnknown() {\n\t\treturn this.type === TypeUnknown;\n\t}\n\n\tisNull() {\n\t\treturn this.type === TypeNull;\n\t}\n\n\tisUndefined() {\n\t\treturn this.type === TypeUndefined;\n\t}\n\n\tisString() {\n\t\treturn this.type === TypeString;\n\t}\n\n\tisNumber() {\n\t\treturn this.type === TypeNumber;\n\t}\n\n\tisBigInt() {\n\t\treturn this.type === TypeBigInt;\n\t}\n\n\tisBoolean() {\n\t\treturn this.type === TypeBoolean;\n\t}\n\n\tisRegExp() {\n\t\treturn this.type === TypeRegExp;\n\t}\n\n\tisConditional() {\n\t\treturn this.type === TypeConditional;\n\t}\n\n\tisArray() {\n\t\treturn this.type === TypeArray;\n\t}\n\n\tisConstArray() {\n\t\treturn this.type === TypeConstArray;\n\t}\n\n\tisIdentifier() {\n\t\treturn this.type === TypeIdentifier;\n\t}\n\n\tisWrapped() {\n\t\treturn this.type === TypeWrapped;\n\t}\n\n\tisTemplateString() {\n\t\treturn this.type === TypeTemplateString;\n\t}\n\n\t/**\n\t * Is expression a primitive or an object type value?\n\t * @returns {boolean | undefined} true: primitive type, false: object type, undefined: unknown/runtime-defined\n\t */\n\tisPrimitiveType() {\n\t\tswitch (this.type) {\n\t\t\tcase TypeUndefined:\n\t\t\tcase TypeNull:\n\t\t\tcase TypeString:\n\t\t\tcase TypeNumber:\n\t\t\tcase TypeBoolean:\n\t\t\tcase TypeBigInt:\n\t\t\tcase TypeWrapped:\n\t\t\tcase TypeTemplateString:\n\t\t\t\treturn true;\n\t\t\tcase TypeRegExp:\n\t\t\tcase TypeArray:\n\t\t\tcase TypeConstArray:\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Is expression a runtime or compile-time value?\n\t * @returns {boolean} true: compile time value, false: runtime value\n\t */\n\tisCompileTimeValue() {\n\t\tswitch (this.type) {\n\t\t\tcase TypeUndefined:\n\t\t\tcase TypeNull:\n\t\t\tcase TypeString:\n\t\t\tcase TypeNumber:\n\t\t\tcase TypeBoolean:\n\t\t\tcase TypeRegExp:\n\t\t\tcase TypeConstArray:\n\t\t\tcase TypeBigInt:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the compile-time value of the expression\n\t * @returns {any} the javascript value\n\t */\n\tasCompileTimeValue() {\n\t\tswitch (this.type) {\n\t\t\tcase TypeUndefined:\n\t\t\t\treturn undefined;\n\t\t\tcase TypeNull:\n\t\t\t\treturn null;\n\t\t\tcase TypeString:\n\t\t\t\treturn this.string;\n\t\t\tcase TypeNumber:\n\t\t\t\treturn this.number;\n\t\t\tcase TypeBoolean:\n\t\t\t\treturn this.bool;\n\t\t\tcase TypeRegExp:\n\t\t\t\treturn this.regExp;\n\t\t\tcase TypeConstArray:\n\t\t\t\treturn this.array;\n\t\t\tcase TypeBigInt:\n\t\t\t\treturn this.bigint;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"asCompileTimeValue must only be called for compile-time values\"\n\t\t\t\t);\n\t\t}\n\t}\n\n\tisTruthy() {\n\t\treturn this.truthy;\n\t}\n\n\tisFalsy() {\n\t\treturn this.falsy;\n\t}\n\n\tisNullish() {\n\t\treturn this.nullish;\n\t}\n\n\t/**\n\t * Can this expression have side effects?\n\t * @returns {boolean} false: never has side effects\n\t */\n\tcouldHaveSideEffects() {\n\t\treturn this.sideEffects;\n\t}\n\n\t/**\n\t * Creates a boolean representation of this evaluated expression.\n\t * @returns {boolean | undefined} true: truthy, false: falsy, undefined: unknown\n\t */\n\tasBool() {\n\t\tif (this.truthy) return true;\n\t\tif (this.falsy || this.nullish) return false;\n\t\tif (this.isBoolean()) return this.bool;\n\t\tif (this.isNull()) return false;\n\t\tif (this.isUndefined()) return false;\n\t\tif (this.isString()) return this.string !== \"\";\n\t\tif (this.isNumber()) return this.number !== 0;\n\t\tif (this.isBigInt()) return this.bigint !== BigInt(0);\n\t\tif (this.isRegExp()) return true;\n\t\tif (this.isArray()) return true;\n\t\tif (this.isConstArray()) return true;\n\t\tif (this.isWrapped()) {\n\t\t\treturn (this.prefix && this.prefix.asBool()) ||\n\t\t\t\t(this.postfix && this.postfix.asBool())\n\t\t\t\t? true\n\t\t\t\t: undefined;\n\t\t}\n\t\tif (this.isTemplateString()) {\n\t\t\tconst str = this.asString();\n\t\t\tif (typeof str === \"string\") return str !== \"\";\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Creates a nullish coalescing representation of this evaluated expression.\n\t * @returns {boolean | undefined} true: nullish, false: not nullish, undefined: unknown\n\t */\n\tasNullish() {\n\t\tconst nullish = this.isNullish();\n\n\t\tif (nullish === true || this.isNull() || this.isUndefined()) return true;\n\n\t\tif (nullish === false) return false;\n\t\tif (this.isTruthy()) return false;\n\t\tif (this.isBoolean()) return false;\n\t\tif (this.isString()) return false;\n\t\tif (this.isNumber()) return false;\n\t\tif (this.isBigInt()) return false;\n\t\tif (this.isRegExp()) return false;\n\t\tif (this.isArray()) return false;\n\t\tif (this.isConstArray()) return false;\n\t\tif (this.isTemplateString()) return false;\n\t\tif (this.isRegExp()) return false;\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Creates a string representation of this evaluated expression.\n\t * @returns {string | undefined} the string representation or undefined if not possible\n\t */\n\tasString() {\n\t\tif (this.isBoolean()) return `${this.bool}`;\n\t\tif (this.isNull()) return \"null\";\n\t\tif (this.isUndefined()) return \"undefined\";\n\t\tif (this.isString()) return this.string;\n\t\tif (this.isNumber()) return `${this.number}`;\n\t\tif (this.isBigInt()) return `${this.bigint}`;\n\t\tif (this.isRegExp()) return `${this.regExp}`;\n\t\tif (this.isArray()) {\n\t\t\tlet array = [];\n\t\t\tfor (const item of /** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\tthis.items\n\t\t\t)) {\n\t\t\t\tconst itemStr = item.asString();\n\t\t\t\tif (itemStr === undefined) return undefined;\n\t\t\t\tarray.push(itemStr);\n\t\t\t}\n\t\t\treturn `${array}`;\n\t\t}\n\t\tif (this.isConstArray()) return `${this.array}`;\n\t\tif (this.isTemplateString()) {\n\t\t\tlet str = \"\";\n\t\t\tfor (const part of /** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\tthis.parts\n\t\t\t)) {\n\t\t\t\tconst partStr = part.asString();\n\t\t\t\tif (partStr === undefined) return undefined;\n\t\t\t\tstr += partStr;\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {string} string value\n\t * @returns {BasicEvaluatedExpression} basic evaluated expression\n\t */\n\tsetString(string) {\n\t\tthis.type = TypeString;\n\t\tthis.string = string;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\tsetUndefined() {\n\t\tthis.type = TypeUndefined;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\tsetNull() {\n\t\tthis.type = TypeNull;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a number\n\t * @param {number} number number to set\n\t * @returns {this} this\n\t */\n\tsetNumber(number) {\n\t\tthis.type = TypeNumber;\n\t\tthis.number = number;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a BigInt\n\t * @param {bigint} bigint bigint to set\n\t * @returns {this} this\n\t */\n\tsetBigInt(bigint) {\n\t\tthis.type = TypeBigInt;\n\t\tthis.bigint = bigint;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a boolean\n\t * @param {boolean} bool boolean to set\n\t * @returns {this} this\n\t */\n\tsetBoolean(bool) {\n\t\tthis.type = TypeBoolean;\n\t\tthis.bool = bool;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a regular expression\n\t * @param {RegExp} regExp regular expression to set\n\t * @returns {this} this\n\t */\n\tsetRegExp(regExp) {\n\t\tthis.type = TypeRegExp;\n\t\tthis.regExp = regExp;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a particular identifier and its members.\n\t *\n\t * @param {string | VariableInfoInterface} identifier identifier to set\n\t * @param {string | VariableInfoInterface} rootInfo root info\n\t * @param {() => string[]} getMembers members\n\t * @param {() => boolean[]=} getMembersOptionals optional members\n\t * @param {() => Range[]=} getMemberRanges ranges of progressively increasing sub-expressions\n\t * @returns {this} this\n\t */\n\tsetIdentifier(\n\t\tidentifier,\n\t\trootInfo,\n\t\tgetMembers,\n\t\tgetMembersOptionals,\n\t\tgetMemberRanges\n\t) {\n\t\tthis.type = TypeIdentifier;\n\t\tthis.identifier = identifier;\n\t\tthis.rootInfo = rootInfo;\n\t\tthis.getMembers = getMembers;\n\t\tthis.getMembersOptionals = getMembersOptionals;\n\t\tthis.getMemberRanges = getMemberRanges;\n\t\tthis.sideEffects = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wraps an array of expressions with a prefix and postfix expression.\n\t *\n\t * @param {BasicEvaluatedExpression | null | undefined} prefix Expression to be added before the innerExpressions\n\t * @param {BasicEvaluatedExpression | null | undefined} postfix Expression to be added after the innerExpressions\n\t * @param {BasicEvaluatedExpression[]} innerExpressions Expressions to be wrapped\n\t * @returns {this} this\n\t */\n\tsetWrapped(prefix, postfix, innerExpressions) {\n\t\tthis.type = TypeWrapped;\n\t\tthis.prefix = prefix;\n\t\tthis.postfix = postfix;\n\t\tthis.wrappedInnerExpressions = innerExpressions;\n\t\tthis.sideEffects = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stores the options of a conditional expression.\n\t *\n\t * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be set\n\t * @returns {this} this\n\t */\n\tsetOptions(options) {\n\t\tthis.type = TypeConditional;\n\t\tthis.options = options;\n\t\tthis.sideEffects = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds options to a conditional expression.\n\t *\n\t * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be added\n\t * @returns {this} this\n\t */\n\taddOptions(options) {\n\t\tif (!this.options) {\n\t\t\tthis.type = TypeConditional;\n\t\t\tthis.options = [];\n\t\t\tthis.sideEffects = true;\n\t\t}\n\t\tfor (const item of options) {\n\t\t\tthis.options.push(item);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to an array of expressions.\n\t *\n\t * @param {BasicEvaluatedExpression[]} items expressions to set\n\t * @returns {this} this\n\t */\n\tsetItems(items) {\n\t\tthis.type = TypeArray;\n\t\tthis.items = items;\n\t\tthis.sideEffects = items.some(i => i.couldHaveSideEffects());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to an array of strings.\n\t *\n\t * @param {string[]} array array to set\n\t * @returns {this} this\n\t */\n\tsetArray(array) {\n\t\tthis.type = TypeConstArray;\n\t\tthis.array = array;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a processed/unprocessed template string. Used\n\t * for evaluating TemplateLiteral expressions in the JavaScript Parser.\n\t *\n\t * @param {BasicEvaluatedExpression[]} quasis template string quasis\n\t * @param {BasicEvaluatedExpression[]} parts template string parts\n\t * @param {\"cooked\" | \"raw\"} kind template string kind\n\t * @returns {this} this\n\t */\n\tsetTemplateString(quasis, parts, kind) {\n\t\tthis.type = TypeTemplateString;\n\t\tthis.quasis = quasis;\n\t\tthis.parts = parts;\n\t\tthis.templateStringKind = kind;\n\t\tthis.sideEffects = parts.some(p => p.sideEffects);\n\t\treturn this;\n\t}\n\n\tsetTruthy() {\n\t\tthis.falsy = false;\n\t\tthis.truthy = true;\n\t\tthis.nullish = false;\n\t\treturn this;\n\t}\n\n\tsetFalsy() {\n\t\tthis.falsy = true;\n\t\tthis.truthy = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of the expression to nullish.\n\t *\n\t * @param {boolean} value true, if the expression is nullish\n\t * @returns {this} this\n\t */\n\tsetNullish(value) {\n\t\tthis.nullish = value;\n\n\t\tif (value) return this.setFalsy();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the range for the expression.\n\t *\n\t * @param {[number, number]} range range to set\n\t * @returns {this} this\n\t */\n\tsetRange(range) {\n\t\tthis.range = range;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set whether or not the expression has side effects.\n\t *\n\t * @param {boolean} sideEffects true, if the expression has side effects\n\t * @returns {this} this\n\t */\n\tsetSideEffects(sideEffects = true) {\n\t\tthis.sideEffects = sideEffects;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the expression node for the expression.\n\t *\n\t * @param {Node | undefined} expression expression\n\t * @returns {this} this\n\t */\n\tsetExpression(expression) {\n\t\tthis.expression = expression;\n\t\treturn this;\n\t}\n}\n\n/**\n * @param {string} flags regexp flags\n * @returns {boolean} is valid flags\n */\nBasicEvaluatedExpression.isValidRegExpFlags = flags => {\n\tconst len = flags.length;\n\n\tif (len === 0) return true;\n\tif (len > 4) return false;\n\n\t// cspell:word gimy\n\tlet remaining = 0b0000; // bit per RegExp flag: gimy\n\n\tfor (let i = 0; i < len; i++)\n\t\tswitch (flags.charCodeAt(i)) {\n\t\t\tcase 103 /* g */:\n\t\t\t\tif (remaining & 0b1000) return false;\n\t\t\t\tremaining |= 0b1000;\n\t\t\t\tbreak;\n\t\t\tcase 105 /* i */:\n\t\t\t\tif (remaining & 0b0100) return false;\n\t\t\t\tremaining |= 0b0100;\n\t\t\t\tbreak;\n\t\t\tcase 109 /* m */:\n\t\t\t\tif (remaining & 0b0010) return false;\n\t\t\t\tremaining |= 0b0010;\n\t\t\t\tbreak;\n\t\t\tcase 121 /* y */:\n\t\t\t\tif (remaining & 0b0001) return false;\n\t\t\t\tremaining |= 0b0001;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\treturn true;\n};\n\nmodule.exports = BasicEvaluatedExpression;\n"]},"metadata":{},"sourceType":"script"}