{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, function () {\n  'use strict'; // Matches the scheme of a URL, eg \"http://\"\n\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   * 6. Query, including \"?\", optional.\n   * 7. Hash, including \"#\", optional.\n   */\n\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may include \"/\", guaranteed.\n   * 3. Query, including \"?\", optional.\n   * 4. Hash, including \"#\", optional.\n   */\n\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  var UrlType;\n\n  (function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n  })(UrlType || (UrlType = {}));\n\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n  }\n\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n  }\n\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      query,\n      hash,\n      type: UrlType.Absolute\n    };\n  }\n\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      url.type = UrlType.SchemeRelative;\n      return url;\n    }\n\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      url.type = UrlType.AbsolutePath;\n      return url;\n    }\n\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n    return url;\n  }\n\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  function mergePaths(url, base) {\n    normalizePath(base, base.type); // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n\n\n  function normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/'); // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n\n    let pointer = 1; // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n\n    let positive = 0; // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n\n    let addTrailingSlash = false;\n\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i]; // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      } // If we encounter a real directory, then we don't need to append anymore.\n\n\n      addTrailingSlash = false; // A current directory, which we can always drop.\n\n      if (piece === '.') continue; // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n\n        continue;\n      } // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n\n\n      pieces[pointer++] = piece;\n      positive++;\n    }\n\n    let path = '';\n\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n\n\n  function resolve(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n\n    if (base && inputType !== UrlType.Absolute) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n\n      switch (inputType) {\n        case UrlType.Empty:\n          url.hash = baseUrl.hash;\n        // fall through\n\n        case UrlType.Hash:\n          url.query = baseUrl.query;\n        // fall through\n\n        case UrlType.Query:\n        case UrlType.RelativePath:\n          mergePaths(url, baseUrl);\n        // fall through\n\n        case UrlType.AbsolutePath:\n          // The host, user, and port are joined, you can't copy one without the others.\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        // fall through\n\n        case UrlType.SchemeRelative:\n          // The input doesn't have a schema at least, so we need to copy at least that over.\n          url.scheme = baseUrl.scheme;\n      }\n\n      if (baseType > inputType) inputType = baseType;\n    }\n\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n\n    switch (inputType) {\n      // This is impossible, because of the empty checks at the start of the function.\n      // case UrlType.Empty:\n      case UrlType.Hash:\n      case UrlType.Query:\n        return queryHash;\n\n      case UrlType.RelativePath:\n        {\n          // The first char is always a \"/\", and we need it to be relative.\n          const path = url.path.slice(1);\n          if (!path) return queryHash || '.';\n\n          if (isRelative(base || input) && !isRelative(path)) {\n            // If base started with a leading \".\", or there is no base and input started with a \".\",\n            // then we need to ensure that the relative path starts with a \".\". We don't know if\n            // relative starts with a \"..\", though, so check before prepending.\n            return './' + path + queryHash;\n          }\n\n          return path + queryHash;\n        }\n\n      case UrlType.AbsolutePath:\n        return url.path + queryHash;\n\n      default:\n        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n\n  return resolve;\n});","map":{"version":3,"mappings":";;;gBAAA;;AACA,QAAMA,WAAW,GAAG,gBAApB;AAEA;;;;;;;;;;;AAUA,QAAMC,QAAQ,GAAG,0EAAjB;AAEA;;;;;;;;;;AASA,QAAMC,SAAS,GAAG,iEAAlB;AAaA,MAAKC,OAAL;;AAAA,aAAKA,OAAL,EAAY;AACVA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACD,GARD,EAAKA,OAAO,KAAPA,OAAO,MAAZ;;AAUA,WAASC,aAAT,CAAuBC,KAAvB,EAAoC;AAClC,WAAOL,WAAW,CAACM,IAAZ,CAAiBD,KAAjB,CAAP;AACD;;AAED,WAASE,mBAAT,CAA6BF,KAA7B,EAA0C;AACxC,WAAOA,KAAK,CAACG,UAAN,CAAiB,IAAjB,CAAP;AACD;;AAED,WAASC,cAAT,CAAwBJ,KAAxB,EAAqC;AACnC,WAAOA,KAAK,CAACG,UAAN,CAAiB,GAAjB,CAAP;AACD;;AAED,WAASE,SAAT,CAAmBL,KAAnB,EAAgC;AAC9B,WAAOA,KAAK,CAACG,UAAN,CAAiB,OAAjB,CAAP;AACD;;AAED,WAASG,UAAT,CAAoBN,KAApB,EAAiC;AAC/B,WAAO,SAASC,IAAT,CAAcD,KAAd,CAAP;AACD;;AAED,WAASO,gBAAT,CAA0BP,KAA1B,EAAuC;AACrC,UAAMQ,KAAK,GAAGZ,QAAQ,CAACa,IAAT,CAAcT,KAAd,CAAd;AACA,WAAOU,OAAO,CACZF,KAAK,CAAC,CAAD,CADO,EAEZA,KAAK,CAAC,CAAD,CAAL,IAAY,EAFA,EAGZA,KAAK,CAAC,CAAD,CAHO,EAIZA,KAAK,CAAC,CAAD,CAAL,IAAY,EAJA,EAKZA,KAAK,CAAC,CAAD,CAAL,IAAY,GALA,EAMZA,KAAK,CAAC,CAAD,CAAL,IAAY,EANA,EAOZA,KAAK,CAAC,CAAD,CAAL,IAAY,EAPA,CAAd;AASD;;AAED,WAASG,YAAT,CAAsBX,KAAtB,EAAmC;AACjC,UAAMQ,KAAK,GAAGX,SAAS,CAACY,IAAV,CAAeT,KAAf,CAAd;AACA,UAAMY,IAAI,GAAGJ,KAAK,CAAC,CAAD,CAAlB;AACA,WAAOE,OAAO,CACZ,OADY,EAEZ,EAFY,EAGZF,KAAK,CAAC,CAAD,CAAL,IAAY,EAHA,EAIZ,EAJY,EAKZJ,cAAc,CAACQ,IAAD,CAAd,GAAuBA,IAAvB,GAA8B,MAAMA,IALxB,EAMZJ,KAAK,CAAC,CAAD,CAAL,IAAY,EANA,EAOZA,KAAK,CAAC,CAAD,CAAL,IAAY,EAPA,CAAd;AASD;;AAED,WAASE,OAAT,CACEG,MADF,EAEEC,IAFF,EAGEC,IAHF,EAIEC,IAJF,EAKEJ,IALF,EAMEK,KANF,EAOEC,IAPF,EAOc;AAEZ,WAAO;AACLL,YADK;AAELC,UAFK;AAGLC,UAHK;AAILC,UAJK;AAKLJ,UALK;AAMLK,WANK;AAOLC,UAPK;AAQLC,UAAI,EAAErB,OAAO,CAACsB;AART,KAAP;AAUD;;AAED,WAASC,QAAT,CAAkBrB,KAAlB,EAA+B;AAC7B,QAAIE,mBAAmB,CAACF,KAAD,CAAvB,EAAgC;AAC9B,YAAMsB,GAAG,GAAGf,gBAAgB,CAAC,UAAUP,KAAX,CAA5B;AACAsB,SAAG,CAACT,MAAJ,GAAa,EAAb;AACAS,SAAG,CAACH,IAAJ,GAAWrB,OAAO,CAACyB,cAAnB;AACA,aAAOD,GAAP;AACD;;AAED,QAAIlB,cAAc,CAACJ,KAAD,CAAlB,EAA2B;AACzB,YAAMsB,GAAG,GAAGf,gBAAgB,CAAC,mBAAmBP,KAApB,CAA5B;AACAsB,SAAG,CAACT,MAAJ,GAAa,EAAb;AACAS,SAAG,CAACP,IAAJ,GAAW,EAAX;AACAO,SAAG,CAACH,IAAJ,GAAWrB,OAAO,CAAC0B,YAAnB;AACA,aAAOF,GAAP;AACD;;AAED,QAAIjB,SAAS,CAACL,KAAD,CAAb,EAAsB,OAAOW,YAAY,CAACX,KAAD,CAAnB;AAEtB,QAAID,aAAa,CAACC,KAAD,CAAjB,EAA0B,OAAOO,gBAAgB,CAACP,KAAD,CAAvB;AAE1B,UAAMsB,GAAG,GAAGf,gBAAgB,CAAC,oBAAoBP,KAArB,CAA5B;AACAsB,OAAG,CAACT,MAAJ,GAAa,EAAb;AACAS,OAAG,CAACP,IAAJ,GAAW,EAAX;AACAO,OAAG,CAACH,IAAJ,GAAWnB,KAAK,GACZA,KAAK,CAACG,UAAN,CAAiB,GAAjB,IACEL,OAAO,CAAC2B,KADV,GAEEzB,KAAK,CAACG,UAAN,CAAiB,GAAjB,IACAL,OAAO,CAAC4B,IADR,GAEA5B,OAAO,CAAC6B,YALE,GAMZ7B,OAAO,CAAC8B,KANZ;AAOA,WAAON,GAAP;AACD;;AAED,WAASO,iBAAT,CAA2BjB,IAA3B,EAAuC;;;AAGrC,QAAIA,IAAI,CAACkB,QAAL,CAAc,KAAd,CAAJ,EAA0B,OAAOlB,IAAP;AAC1B,UAAMmB,KAAK,GAAGnB,IAAI,CAACoB,WAAL,CAAiB,GAAjB,CAAd;AACA,WAAOpB,IAAI,CAACqB,KAAL,CAAW,CAAX,EAAcF,KAAK,GAAG,CAAtB,CAAP;AACD;;AAED,WAASG,UAAT,CAAoBZ,GAApB,EAA8Ba,IAA9B,EAAuC;AACrCC,iBAAa,CAACD,IAAD,EAAOA,IAAI,CAAChB,IAAZ,CAAb,CADqC;;;AAKrC,QAAIG,GAAG,CAACV,IAAJ,KAAa,GAAjB,EAAsB;AACpBU,SAAG,CAACV,IAAJ,GAAWuB,IAAI,CAACvB,IAAhB;AACD,KAFD,MAEO;;AAELU,SAAG,CAACV,IAAJ,GAAWiB,iBAAiB,CAACM,IAAI,CAACvB,IAAN,CAAjB,GAA+BU,GAAG,CAACV,IAA9C;AACD;AACF;AAED;;;;;;AAIA,WAASwB,aAAT,CAAuBd,GAAvB,EAAiCH,IAAjC,EAA8C;AAC5C,UAAMkB,GAAG,GAAGlB,IAAI,IAAIrB,OAAO,CAAC6B,YAA5B;AACA,UAAMW,MAAM,GAAGhB,GAAG,CAACV,IAAJ,CAAS2B,KAAT,CAAe,GAAf,CAAf,CAF4C;;;AAM5C,QAAIC,OAAO,GAAG,CAAd,CAN4C;;;AAU5C,QAAIC,QAAQ,GAAG,CAAf,CAV4C;;;;AAe5C,QAAIC,gBAAgB,GAAG,KAAvB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,YAAME,KAAK,GAAGP,MAAM,CAACK,CAAD,CAApB,CADsC;;AAItC,UAAI,CAACE,KAAL,EAAY;AACVH,wBAAgB,GAAG,IAAnB;AACA;AACD,OAPqC;;;AAUtCA,sBAAgB,GAAG,KAAnB,CAVsC;;AAatC,UAAIG,KAAK,KAAK,GAAd,EAAmB,SAbmB;;;AAiBtC,UAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB,YAAIJ,QAAJ,EAAc;AACZC,0BAAgB,GAAG,IAAnB;AACAD,kBAAQ;AACRD,iBAAO;AACR,SAJD,MAIO,IAAIH,GAAJ,EAAS;;;AAGdC,gBAAM,CAACE,OAAO,EAAR,CAAN,GAAoBK,KAApB;AACD;;AACD;AACD,OA5BqC;;;;AAgCtCP,YAAM,CAACE,OAAO,EAAR,CAAN,GAAoBK,KAApB;AACAJ,cAAQ;AACT;;AAED,QAAI7B,IAAI,GAAG,EAAX;;AACA,SAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAApB,EAA6BG,CAAC,EAA9B,EAAkC;AAChC/B,UAAI,IAAI,MAAM0B,MAAM,CAACK,CAAD,CAApB;AACD;;AACD,QAAI,CAAC/B,IAAD,IAAU8B,gBAAgB,IAAI,CAAC9B,IAAI,CAACkB,QAAL,CAAc,KAAd,CAAnC,EAA0D;AACxDlB,UAAI,IAAI,GAAR;AACD;;AACDU,OAAG,CAACV,IAAJ,GAAWA,IAAX;AACD;AAED;;;;;WAGwBkC,QAAQ9C,OAAemC,MAAwB;AACrE,QAAI,CAACnC,KAAD,IAAU,CAACmC,IAAf,EAAqB,OAAO,EAAP;AAErB,UAAMb,GAAG,GAAGD,QAAQ,CAACrB,KAAD,CAApB;AACA,QAAI+C,SAAS,GAAGzB,GAAG,CAACH,IAApB;;AAEA,QAAIgB,IAAI,IAAIY,SAAS,KAAKjD,OAAO,CAACsB,QAAlC,EAA4C;AAC1C,YAAM4B,OAAO,GAAG3B,QAAQ,CAACc,IAAD,CAAxB;AACA,YAAMc,QAAQ,GAAGD,OAAO,CAAC7B,IAAzB;;AAEA,cAAQ4B,SAAR;AACE,aAAKjD,OAAO,CAAC8B,KAAb;AACEN,aAAG,CAACJ,IAAJ,GAAW8B,OAAO,CAAC9B,IAAnB;;;AAGF,aAAKpB,OAAO,CAAC4B,IAAb;AACEJ,aAAG,CAACL,KAAJ,GAAY+B,OAAO,CAAC/B,KAApB;;;AAGF,aAAKnB,OAAO,CAAC2B,KAAb;AACA,aAAK3B,OAAO,CAAC6B,YAAb;AACEO,oBAAU,CAACZ,GAAD,EAAM0B,OAAN,CAAV;;;AAGF,aAAKlD,OAAO,CAAC0B,YAAb;;AAEEF,aAAG,CAACR,IAAJ,GAAWkC,OAAO,CAAClC,IAAnB;AACAQ,aAAG,CAACP,IAAJ,GAAWiC,OAAO,CAACjC,IAAnB;AACAO,aAAG,CAACN,IAAJ,GAAWgC,OAAO,CAAChC,IAAnB;;;AAGF,aAAKlB,OAAO,CAACyB,cAAb;;AAEED,aAAG,CAACT,MAAJ,GAAamC,OAAO,CAACnC,MAArB;AAvBJ;;AAyBA,UAAIoC,QAAQ,GAAGF,SAAf,EAA0BA,SAAS,GAAGE,QAAZ;AAC3B;;AAEDb,iBAAa,CAACd,GAAD,EAAMyB,SAAN,CAAb;AAEA,UAAMG,SAAS,GAAG5B,GAAG,CAACL,KAAJ,GAAYK,GAAG,CAACJ,IAAlC;;AACA,YAAQ6B,SAAR;;;AAIE,WAAKjD,OAAO,CAAC4B,IAAb;AACA,WAAK5B,OAAO,CAAC2B,KAAb;AACE,eAAOyB,SAAP;;AAEF,WAAKpD,OAAO,CAAC6B,YAAb;AAA2B;;AAEzB,gBAAMf,IAAI,GAAGU,GAAG,CAACV,IAAJ,CAASqB,KAAT,CAAe,CAAf,CAAb;AAEA,cAAI,CAACrB,IAAL,EAAW,OAAOsC,SAAS,IAAI,GAApB;;AAEX,cAAI5C,UAAU,CAAC6B,IAAI,IAAInC,KAAT,CAAV,IAA6B,CAACM,UAAU,CAACM,IAAD,CAA5C,EAAoD;;;;AAIlD,mBAAO,OAAOA,IAAP,GAAcsC,SAArB;AACD;;AAED,iBAAOtC,IAAI,GAAGsC,SAAd;AACD;;AAED,WAAKpD,OAAO,CAAC0B,YAAb;AACE,eAAOF,GAAG,CAACV,IAAJ,GAAWsC,SAAlB;;AAEF;AACE,eAAO5B,GAAG,CAACT,MAAJ,GAAa,IAAb,GAAoBS,GAAG,CAACR,IAAxB,GAA+BQ,GAAG,CAACP,IAAnC,GAA0CO,GAAG,CAACN,IAA9C,GAAqDM,GAAG,CAACV,IAAzD,GAAgEsC,SAAvE;AA5BJ;AA8BF","names":["schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","Query","Hash","RelativePath","Empty","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","inputType","baseUrl","baseType","queryHash"],"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@jridgewell/resolve-uri/src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nenum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}