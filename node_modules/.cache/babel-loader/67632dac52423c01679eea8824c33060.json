{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { ListContext } from '../useList';\n/**\n * Stabilizes the ListContext value for the Option component, so it doesn't change when sibling Options update.\n *\n * @param value The value of the Option.\n * @returns The stable ListContext value.\n *\n * Demos:\n *\n * - [Select](https://mui.com/base-ui/react-select/#hooks)\n *\n * API:\n *\n * - [useOptionContextStabilizer API](https://mui.com/base-ui/react-select/hooks-api/#use-option-context-stabilizer)\n */\n\nexport function useOptionContextStabilizer(value) {\n  const listContext = React.useContext(ListContext);\n\n  if (!listContext) {\n    throw new Error('Option: ListContext was not found.');\n  }\n\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = getItemState(value); // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== value) {\n      throw new Error(['Base UI Option: Tried to access the state of another Option.', 'This is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.'].join('/n'));\n    }\n\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, value]); // Create a local (per Option) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes Options re-render only when their state actually change, not when any Option's state changes.\n\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue\n  };\n}","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@mui/base/useOption/useOptionContextStabilizer.js"],"names":["React","ListContext","useOptionContextStabilizer","value","listContext","useContext","Error","getItemState","dispatch","highlighted","selected","focusable","localGetItemState","useCallback","itemValue","join","localContextValue","useMemo","contextValue"],"mappings":"AAAA;;AAEA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,WAAT,QAA4B,YAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,0BAAT,CAAoCC,KAApC,EAA2C;AAChD,QAAMC,WAAW,GAAGJ,KAAK,CAACK,UAAN,CAAiBJ,WAAjB,CAApB;;AACA,MAAI,CAACG,WAAL,EAAkB;AAChB,UAAM,IAAIE,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,QAAM;AACJC,IAAAA,YADI;AAEJC,IAAAA;AAFI,MAGFJ,WAHJ;AAIA,QAAM;AACJK,IAAAA,WADI;AAEJC,IAAAA,QAFI;AAGJC,IAAAA;AAHI,MAIFJ,YAAY,CAACJ,KAAD,CAJhB,CATgD,CAehD;AACA;;AACA,QAAMS,iBAAiB,GAAGZ,KAAK,CAACa,WAAN,CAAkBC,SAAS,IAAI;AACvD,QAAIA,SAAS,KAAKX,KAAlB,EAAyB;AACvB,YAAM,IAAIG,KAAJ,CAAU,CAAC,8DAAD,EAAiE,qGAAjE,EAAwKS,IAAxK,CAA6K,IAA7K,CAAV,CAAN;AACD;;AACD,WAAO;AACLN,MAAAA,WADK;AAELC,MAAAA,QAFK;AAGLC,MAAAA;AAHK,KAAP;AAKD,GATyB,EASvB,CAACF,WAAD,EAAcC,QAAd,EAAwBC,SAAxB,EAAmCR,KAAnC,CATuB,CAA1B,CAjBgD,CA4BhD;AACA;AACA;;AACA,QAAMa,iBAAiB,GAAGhB,KAAK,CAACiB,OAAN,CAAc,OAAO;AAC7CT,IAAAA,QAD6C;AAE7CD,IAAAA,YAAY,EAAEK;AAF+B,GAAP,CAAd,EAGtB,CAACJ,QAAD,EAAWI,iBAAX,CAHsB,CAA1B;AAIA,SAAO;AACLM,IAAAA,YAAY,EAAEF;AADT,GAAP;AAGD","sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { ListContext } from '../useList';\n\n/**\n * Stabilizes the ListContext value for the Option component, so it doesn't change when sibling Options update.\n *\n * @param value The value of the Option.\n * @returns The stable ListContext value.\n *\n * Demos:\n *\n * - [Select](https://mui.com/base-ui/react-select/#hooks)\n *\n * API:\n *\n * - [useOptionContextStabilizer API](https://mui.com/base-ui/react-select/hooks-api/#use-option-context-stabilizer)\n */\nexport function useOptionContextStabilizer(value) {\n  const listContext = React.useContext(ListContext);\n  if (!listContext) {\n    throw new Error('Option: ListContext was not found.');\n  }\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = getItemState(value);\n\n  // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== value) {\n      throw new Error(['Base UI Option: Tried to access the state of another Option.', 'This is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.'].join('/n'));\n    }\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, value]);\n\n  // Create a local (per Option) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes Options re-render only when their state actually change, not when any Option's state changes.\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue\n  };\n}"]},"metadata":{},"sourceType":"module"}