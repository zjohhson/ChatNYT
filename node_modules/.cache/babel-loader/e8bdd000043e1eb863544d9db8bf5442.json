{"ast":null,"code":"\"use strict\";\n/** @typedef {import(\"@jridgewell/trace-mapping\").SourceMapInput} SourceMapInput */\n\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n\n/** @typedef {import(\"terser\").CompressOptions} TerserCompressOptions */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/** @typedef {import(\"./index.js\").Input} Input */\n\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\n\nconst notSettled = Symbol(`not-settled`);\n/**\n * @template T\n * @typedef {() => Promise<T>} Task\n */\n\n/**\n * Run tasks with limited concurrency.\n * @template T\n * @param {number} limit - Limit of tasks that run at once.\n * @param {Task<T>[]} tasks - List of tasks to run.\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\n */\n\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(`Expected \\`limit\\` to be a finite number > 0, got \\`${limit}\\` (${typeof limit})`);\n  }\n\n  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {\n    throw new TypeError(`Expected \\`tasks\\` to be a list of functions returning a promise`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const result = Array(tasks.length).fill(notSettled);\n    const entries = tasks.entries();\n\n    const next = () => {\n      const {\n        done,\n        value\n      } = entries.next();\n\n      if (done) {\n        const isLast = !result.includes(notSettled);\n        if (isLast) resolve(\n        /** @type{T[]} **/\n        result);\n        return;\n      }\n\n      const [index, task] = value;\n      /**\n       * @param {T} x\n       */\n\n      const onFulfilled = x => {\n        result[index] = x;\n        next();\n      };\n\n      task().then(onFulfilled, reject);\n    };\n\n    Array(limit).fill(0).forEach(next);\n  });\n}\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function terserMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\n   * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n\n\n  const buildComments = (terserOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    let comments;\n\n    if (terserOptions.format) {\n      ({\n        comments\n      } = terserOptions.format);\n    } else if (terserOptions.output) {\n      ({\n        comments\n      } = terserOptions.output);\n    }\n\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n\n        case \"function\":\n          break;\n\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n\n            break;\n          }\n\n          if (condition[key] === \"some\") {\n            condition[key] =\n            /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n            break;\n          }\n\n          regexStr =\n          /** @type {string} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp(\n          /** @type {string} */\n          regexStr).test(comment.value);\n\n          break;\n\n        default:\n          regex =\n          /** @type {RegExp} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) =>\n          /** @type {RegExp} */\n          regex.test(comment.value);\n\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if (\n      /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n\n      return (\n        /** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\n   * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\n   * @returns {TerserOptions & { sourceMap: undefined } & { compress: TerserCompressOptions } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\n   */\n\n\n  const buildTerserOptions = function () {\n    let terserOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return { ...terserOptions,\n      compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress ? {} : false : { ...terserOptions.compress\n      },\n      // ecma: terserOptions.ecma,\n      // ie8: terserOptions.ie8,\n      // keep_classnames: terserOptions.keep_classnames,\n      // keep_fnames: terserOptions.keep_fnames,\n      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : { ...terserOptions.mangle\n      },\n      // module: terserOptions.module,\n      // nameCache: { ...terserOptions.toplevel },\n      // the `output` option is deprecated\n      ...(terserOptions.format ? {\n        format: {\n          beautify: false,\n          ...terserOptions.format\n        }\n      } : {\n        output: {\n          beautify: false,\n          ...terserOptions.output\n        }\n      }),\n      parse: { ...terserOptions.parse\n      },\n      // safari10: terserOptions.safari10,\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: terserOptions.toplevel\n\n    };\n  }; // eslint-disable-next-line global-require\n\n\n  const {\n    minify\n  } = require(\"terser\"); // Copy `terser` options\n\n\n  const terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = [];\n\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n  }\n\n  if (terserOptions.compress) {\n    // More optimizations\n    if (typeof terserOptions.compress.ecma === \"undefined\") {\n      terserOptions.compress.ecma = terserOptions.ecma;\n    } // https://github.com/webpack/webpack/issues/16135\n\n\n    if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === \"undefined\") {\n      terserOptions.compress.arrows = false;\n    }\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, terserOptions);\n  return {\n    code:\n    /** @type {string} **/\n    result.code,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    map: result.map ?\n    /** @type {SourceMapInput} **/\n    result.map : undefined,\n    extractedComments\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nterserMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\n   * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n\n\n  const buildComments = (uglifyJsOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    const {\n      comments\n    } = uglifyJsOptions.output;\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n\n        case \"function\":\n          break;\n\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n\n            break;\n          }\n\n          if (condition[key] === \"some\") {\n            condition[key] =\n            /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n            break;\n          }\n\n          regexStr =\n          /** @type {string} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp(\n          /** @type {string} */\n          regexStr).test(comment.value);\n\n          break;\n\n        default:\n          regex =\n          /** @type {RegExp} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) =>\n          /** @type {RegExp} */\n          regex.test(comment.value);\n\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if (\n      /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n\n      return (\n        /** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\n   * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\n   * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\n   */\n\n\n  const buildUglifyJsOptions = function () {\n    let uglifyJsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // eslint-disable-next-line no-param-reassign\n    delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\n\n    delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return { ...uglifyJsOptions,\n      // warnings: uglifyJsOptions.warnings,\n      parse: { ...uglifyJsOptions.parse\n      },\n      compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : { ...uglifyJsOptions.compress\n      },\n      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : { ...uglifyJsOptions.mangle\n      },\n      output: {\n        beautify: false,\n        ...uglifyJsOptions.output\n      },\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\n      // nameCache: { ...uglifyJsOptions.toplevel },\n      // ie8: uglifyJsOptions.ie8,\n      // keep_fnames: uglifyJsOptions.keep_fnames,\n\n    };\n  }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n\n\n  const {\n    minify\n  } = require(\"uglify-js\"); // Copy `uglify-js` options\n\n\n  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    uglifyJsOptions.sourceMap = true;\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = []; // @ts-ignore\n\n  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, uglifyJsOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    errors: result.error ? [result.error] : [],\n    warnings: result.warnings || [],\n    extractedComments\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nuglifyJsMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function swcMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\n   * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined } & { compress: import(\"@swc/core\").TerserCompressOptions }}\n   */\n  const buildSwcOptions = function () {\n    let swcOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return { ...swcOptions,\n      compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress ? {} : false : { ...swcOptions.compress\n      },\n      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : { ...swcOptions.mangle\n      },\n      // ecma: swcOptions.ecma,\n      // keep_classnames: swcOptions.keep_classnames,\n      // keep_fnames: swcOptions.keep_fnames,\n      // module: swcOptions.module,\n      // safari10: swcOptions.safari10,\n      // toplevel: swcOptions.toplevel\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n  const swc = require(\"@swc/core\"); // Copy `swc` options\n\n\n  const swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    swcOptions.sourceMap = true;\n  }\n\n  if (swcOptions.compress) {\n    // More optimizations\n    if (typeof swcOptions.compress.ecma === \"undefined\") {\n      swcOptions.compress.ecma = swcOptions.ecma;\n    } // https://github.com/webpack/webpack/issues/16135\n\n\n    if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === \"undefined\") {\n      swcOptions.compress.arrows = false;\n    }\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  const result = await swc.minify(code, swcOptions);\n  let map;\n\n  if (result.map) {\n    map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n\n    map.sources = [filename];\n    delete map.sourcesContent;\n  }\n\n  return {\n    code: result.code,\n    map\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nswcMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function esbuildMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\n   * @returns {import(\"esbuild\").TransformOptions}\n   */\n  const buildEsbuildOptions = function () {\n    let esbuildOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // eslint-disable-next-line no-param-reassign\n    delete esbuildOptions.ecma;\n\n    if (esbuildOptions.module) {\n      // eslint-disable-next-line no-param-reassign\n      esbuildOptions.format = \"esm\";\n    } // eslint-disable-next-line no-param-reassign\n\n\n    delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return {\n      minify: true,\n      legalComments: \"inline\",\n      ...esbuildOptions,\n      sourcemap: false\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n  const esbuild = require(\"esbuild\"); // Copy `esbuild` options\n\n\n  const esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\n\n  if (sourceMap) {\n    esbuildOptions.sourcemap = true;\n    esbuildOptions.sourcesContent = false;\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  esbuildOptions.sourcefile = filename;\n  const result = await esbuild.transform(code, esbuildOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    warnings: result.warnings.length > 0 ? result.warnings.map(item => {\n      const plugin = item.pluginName ? `\\nPlugin Name: ${item.pluginName}` : \"\";\n      const location = item.location ? `\\n\\n${item.location.file}:${item.location.line}:${item.location.column}:\\n  ${item.location.line} | ${item.location.lineText}\\n\\nSuggestion: ${item.location.suggestion}` : \"\";\n      const notes = item.notes.length > 0 ? `\\n\\nNotes:\\n${item.notes.map(note => `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : \"\"}${note.text}${note.location ? `\\nSuggestion: ${note.location.suggestion}` : \"\"}${note.location ? `\\nLine text:\\n${note.location.lineText}\\n` : \"\"}`).join(\"\\n\")}` : \"\";\n      return `${item.text} [${item.id}]${plugin}${location}${item.detail ? `\\nDetails:\\n${item.detail}` : \"\"}${notes}`;\n    }) : []\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nesbuildMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n\nmodule.exports = {\n  throttleAll,\n  terserMinify,\n  uglifyJsMinify,\n  swcMinify,\n  esbuildMinify\n};","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/terser-webpack-plugin/dist/utils.js"],"names":["notSettled","Symbol","throttleAll","limit","tasks","Number","isInteger","TypeError","Array","isArray","every","task","Promise","resolve","reject","result","length","fill","entries","next","done","value","isLast","includes","index","onFulfilled","x","then","forEach","terserMinify","input","sourceMap","minimizerOptions","extractComments","isObject","type","buildComments","terserOptions","extractedComments","condition","comments","format","output","preserve","extract","RegExp","key","regexStr","regex","astNode","comment","test","commentText","push","buildTerserOptions","compress","mangle","beautify","parse","undefined","minify","require","asObject","ecma","arrows","filename","code","Object","map","getMinimizerVersion","packageJson","error","version","uglifyJsMinify","uglifyJsOptions","buildUglifyJsOptions","module","JSON","errors","warnings","swcMinify","buildSwcOptions","swcOptions","swc","sources","sourcesContent","esbuildMinify","buildEsbuildOptions","esbuildOptions","legalComments","sourcemap","esbuild","sourcefile","transform","item","plugin","pluginName","location","file","line","column","lineText","suggestion","notes","note","text","join","id","detail","exports"],"mappings":"AAAA;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;;AAEA,MAAMA,UAAU,GAAGC,MAAM,CAAE,aAAF,CAAzB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmC;AACjC,MAAI,CAACC,MAAM,CAACC,SAAP,CAAiBH,KAAjB,CAAD,IAA4BA,KAAK,GAAG,CAAxC,EAA2C;AACzC,UAAM,IAAII,SAAJ,CAAe,uDAAsDJ,KAAM,OAAM,OAAOA,KAAM,GAA9F,CAAN;AACD;;AACD,MAAI,CAACK,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAD,IAAyB,CAACA,KAAK,CAACM,KAAN,CAAYC,IAAI,IAAI,OAAOA,IAAP,KAAiB,UAArC,CAA9B,EAA+E;AAC7E,UAAM,IAAIJ,SAAJ,CAAe,kEAAf,CAAN;AACD;;AACD,SAAO,IAAIK,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,MAAM,GAAGP,KAAK,CAACJ,KAAK,CAACY,MAAP,CAAL,CAAoBC,IAApB,CAAyBjB,UAAzB,CAAf;AACA,UAAMkB,OAAO,GAAGd,KAAK,CAACc,OAAN,EAAhB;;AACA,UAAMC,IAAI,GAAG,MAAM;AACjB,YAAM;AACJC,QAAAA,IADI;AAEJC,QAAAA;AAFI,UAGFH,OAAO,CAACC,IAAR,EAHJ;;AAIA,UAAIC,IAAJ,EAAU;AACR,cAAME,MAAM,GAAG,CAACP,MAAM,CAACQ,QAAP,CAAgBvB,UAAhB,CAAhB;AACA,YAAIsB,MAAJ,EAAYT,OAAO;AAAE;AAAkBE,QAAAA,MAApB,CAAP;AACZ;AACD;;AACD,YAAM,CAACS,KAAD,EAAQb,IAAR,IAAgBU,KAAtB;AAEA;AACN;AACA;;AACM,YAAMI,WAAW,GAAGC,CAAC,IAAI;AACvBX,QAAAA,MAAM,CAACS,KAAD,CAAN,GAAgBE,CAAhB;AACAP,QAAAA,IAAI;AACL,OAHD;;AAIAR,MAAAA,IAAI,GAAGgB,IAAP,CAAYF,WAAZ,EAAyBX,MAAzB;AACD,KApBD;;AAqBAN,IAAAA,KAAK,CAACL,KAAD,CAAL,CAAac,IAAb,CAAkB,CAAlB,EAAqBW,OAArB,CAA6BT,IAA7B;AACD,GAzBM,CAAP;AA0BD;AAED;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeU,YAAf,CAA4BC,KAA5B,EAAmCC,SAAnC,EAA8CC,gBAA9C,EAAgEC,eAAhE,EAAiF;AAC/E;AACF;AACA;AACA;AACE,QAAMC,QAAQ,GAAGb,KAAK,IAAI;AACxB,UAAMc,IAAI,GAAG,OAAOd,KAApB;AACA,WAAOA,KAAK,IAAI,IAAT,KAAkBc,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,UAAhD,CAAP;AACD,GAHD;AAKA;AACF;AACA;AACA;AACA;;;AACE,QAAMC,aAAa,GAAG,CAACC,aAAD,EAAgBC,iBAAhB,KAAsC;AAC1D;AACA,UAAMC,SAAS,GAAG,EAAlB;AACA,QAAIC,QAAJ;;AACA,QAAIH,aAAa,CAACI,MAAlB,EAA0B;AACxB,OAAC;AACCD,QAAAA;AADD,UAEGH,aAAa,CAACI,MAFlB;AAGD,KAJD,MAIO,IAAIJ,aAAa,CAACK,MAAlB,EAA0B;AAC/B,OAAC;AACCF,QAAAA;AADD,UAEGH,aAAa,CAACK,MAFlB;AAGD;;AACDH,IAAAA,SAAS,CAACI,QAAV,GAAqB,OAAOH,QAAP,KAAoB,WAApB,GAAkCA,QAAlC,GAA6C,KAAlE;;AACA,QAAI,OAAOP,eAAP,KAA2B,SAA3B,IAAwCA,eAA5C,EAA6D;AAC3DM,MAAAA,SAAS,CAACK,OAAV,GAAoB,MAApB;AACD,KAFD,MAEO,IAAI,OAAOX,eAAP,KAA2B,QAA3B,IAAuCA,eAAe,YAAYY,MAAtE,EAA8E;AACnFN,MAAAA,SAAS,CAACK,OAAV,GAAoBX,eAApB;AACD,KAFM,MAEA,IAAI,OAAOA,eAAP,KAA2B,UAA/B,EAA2C;AAChDM,MAAAA,SAAS,CAACK,OAAV,GAAoBX,eAApB;AACD,KAFM,MAEA,IAAIA,eAAe,IAAIC,QAAQ,CAACD,eAAD,CAA/B,EAAkD;AACvDM,MAAAA,SAAS,CAACK,OAAV,GAAoB,OAAOX,eAAe,CAACM,SAAvB,KAAqC,SAArC,IAAkDN,eAAe,CAACM,SAAlE,GAA8E,MAA9E,GAAuF,OAAON,eAAe,CAACM,SAAvB,KAAqC,WAArC,GAAmDN,eAAe,CAACM,SAAnE,GAA+E,MAA1L;AACD,KAFM,MAEA;AACL;AACA;AACAA,MAAAA,SAAS,CAACI,QAAV,GAAqB,OAAOH,QAAP,KAAoB,WAApB,GAAkCA,QAAlC,GAA6C,MAAlE;AACAD,MAAAA,SAAS,CAACK,OAAV,GAAoB,KAApB;AACD,KA3ByD,CA6B1D;;;AACA,KAAC,UAAD,EAAa,SAAb,EAAwBhB,OAAxB,CAAgCkB,GAAG,IAAI;AACrC;AACA,UAAIC,QAAJ;AACA;;AACA,UAAIC,KAAJ;;AACA,cAAQ,OAAOT,SAAS,CAACO,GAAD,CAAxB;AACE,aAAK,SAAL;AACEP,UAAAA,SAAS,CAACO,GAAD,CAAT,GAAiBP,SAAS,CAACO,GAAD,CAAT,GAAiB,MAAM,IAAvB,GAA8B,MAAM,KAArD;AACA;;AACF,aAAK,UAAL;AACE;;AACF,aAAK,QAAL;AACE,cAAIP,SAAS,CAACO,GAAD,CAAT,KAAmB,KAAvB,EAA8B;AAC5BP,YAAAA,SAAS,CAACO,GAAD,CAAT,GAAiB,MAAM,IAAvB;;AACA;AACD;;AACD,cAAIP,SAAS,CAACO,GAAD,CAAT,KAAmB,MAAvB,EAA+B;AAC7BP,YAAAA,SAAS,CAACO,GAAD,CAAT;AAAiB;AACjB,aAACG,OAAD,EAAUC,OAAV,KAAsB,CAACA,OAAO,CAACf,IAAR,KAAiB,UAAjB,IAA+Be,OAAO,CAACf,IAAR,KAAiB,UAAjD,KAAgE,+BAA+BgB,IAA/B,CAAoCD,OAAO,CAAC7B,KAA5C,CADtF;;AAEA;AACD;;AACD0B,UAAAA,QAAQ;AAAG;AAAqBR,UAAAA,SAAS,CAACO,GAAD,CAAzC;;AACAP,UAAAA,SAAS,CAACO,GAAD,CAAT;AAAiB;AACjB,WAACG,OAAD,EAAUC,OAAV,KAAsB,IAAIL,MAAJ;AAAY;AAAqBE,UAAAA,QAAjC,EAA2CI,IAA3C,CAAgDD,OAAO,CAAC7B,KAAxD,CADtB;;AAEA;;AACF;AACE2B,UAAAA,KAAK;AAAG;AAAqBT,UAAAA,SAAS,CAACO,GAAD,CAAtC;;AACAP,UAAAA,SAAS,CAACO,GAAD,CAAT;AAAiB;AACjB,WAACG,OAAD,EAAUC,OAAV;AAAsB;AAAqBF,UAAAA,KAAK,CAACG,IAAN,CAAWD,OAAO,CAAC7B,KAAnB,CAD3C;;AAtBJ;AAyBD,KA9BD,EA9B0D,CA8D1D;AACA;;AACA,WAAO,CAAC4B,OAAD,EAAUC,OAAV,KAAsB;AAC3B;AAAK;AACLX,MAAAA,SAAS,CAACK,OAAV,CAAkBK,OAAlB,EAA2BC,OAA3B,CADA,EACqC;AACnC,cAAME,WAAW,GAAGF,OAAO,CAACf,IAAR,KAAiB,UAAjB,GAA+B,KAAIe,OAAO,CAAC7B,KAAM,IAAjD,GAAwD,KAAI6B,OAAO,CAAC7B,KAAM,EAA9F,CADmC,CAGnC;;AACA,YAAI,CAACiB,iBAAiB,CAACf,QAAlB,CAA2B6B,WAA3B,CAAL,EAA8C;AAC5Cd,UAAAA,iBAAiB,CAACe,IAAlB,CAAuBD,WAAvB;AACD;AACF;;AACD;AAAQ;AAAoDb,QAAAA,SAAS,CAACI,QAAV,CAAmBM,OAAnB,EAA4BC,OAA5B;AAA5D;AAED,KAZD;AAaD,GA7ED;AA+EA;AACF;AACA;AACA;;;AACE,QAAMI,kBAAkB,GAAG,YAAwB;AAAA,QAAvBjB,aAAuB,uEAAP,EAAO;AACjD;AACA,WAAO,EACL,GAAGA,aADE;AAELkB,MAAAA,QAAQ,EAAE,OAAOlB,aAAa,CAACkB,QAArB,KAAkC,SAAlC,GAA8ClB,aAAa,CAACkB,QAAd,GAAyB,EAAzB,GAA8B,KAA5E,GAAoF,EAC5F,GAAGlB,aAAa,CAACkB;AAD2E,OAFzF;AAKL;AACA;AACA;AACA;AACAC,MAAAA,MAAM,EAAEnB,aAAa,CAACmB,MAAd,IAAwB,IAAxB,GAA+B,IAA/B,GAAsC,OAAOnB,aAAa,CAACmB,MAArB,KAAgC,SAAhC,GAA4CnB,aAAa,CAACmB,MAA1D,GAAmE,EAC/G,GAAGnB,aAAa,CAACmB;AAD8F,OAT5G;AAYL;AACA;AACA;AACA,UAAInB,aAAa,CAACI,MAAd,GAAuB;AACzBA,QAAAA,MAAM,EAAE;AACNgB,UAAAA,QAAQ,EAAE,KADJ;AAEN,aAAGpB,aAAa,CAACI;AAFX;AADiB,OAAvB,GAKA;AACFC,QAAAA,MAAM,EAAE;AACNe,UAAAA,QAAQ,EAAE,KADJ;AAEN,aAAGpB,aAAa,CAACK;AAFX;AADN,OALJ,CAfK;AA0BLgB,MAAAA,KAAK,EAAE,EACL,GAAGrB,aAAa,CAACqB;AADZ,OA1BF;AA6BL;AACA;AACA;AACA3B,MAAAA,SAAS,EAAE4B,SAhCN,CAiCL;;AAjCK,KAAP;AAmCD,GArCD,CAlG+E,CAyI/E;;;AACA,QAAM;AACJC,IAAAA;AADI,MAEFC,OAAO,CAAC,QAAD,CAFX,CA1I+E,CA6I/E;;;AACA,QAAMxB,aAAa,GAAGiB,kBAAkB,CAACtB,gBAAD,CAAxC,CA9I+E,CAgJ/E;;AACA,MAAID,SAAJ,EAAe;AACb;AACAM,IAAAA,aAAa,CAACN,SAAd,GAA0B;AACxB+B,MAAAA,QAAQ,EAAE;AADc,KAA1B;AAGD;AAED;;;AACA,QAAMxB,iBAAiB,GAAG,EAA1B;;AACA,MAAID,aAAa,CAACK,MAAlB,EAA0B;AACxBL,IAAAA,aAAa,CAACK,MAAd,CAAqBF,QAArB,GAAgCJ,aAAa,CAACC,aAAD,EAAgBC,iBAAhB,CAA7C;AACD,GAFD,MAEO,IAAID,aAAa,CAACI,MAAlB,EAA0B;AAC/BJ,IAAAA,aAAa,CAACI,MAAd,CAAqBD,QAArB,GAAgCJ,aAAa,CAACC,aAAD,EAAgBC,iBAAhB,CAA7C;AACD;;AACD,MAAID,aAAa,CAACkB,QAAlB,EAA4B;AAC1B;AACA,QAAI,OAAOlB,aAAa,CAACkB,QAAd,CAAuBQ,IAA9B,KAAuC,WAA3C,EAAwD;AACtD1B,MAAAA,aAAa,CAACkB,QAAd,CAAuBQ,IAAvB,GAA8B1B,aAAa,CAAC0B,IAA5C;AACD,KAJyB,CAM1B;;;AACA,QAAI1B,aAAa,CAAC0B,IAAd,KAAuB,CAAvB,IAA4B,OAAO1B,aAAa,CAACkB,QAAd,CAAuBS,MAA9B,KAAyC,WAAzE,EAAsF;AACpF3B,MAAAA,aAAa,CAACkB,QAAd,CAAuBS,MAAvB,GAAgC,KAAhC;AACD;AACF;;AACD,QAAM,CAAC,CAACC,QAAD,EAAWC,IAAX,CAAD,IAAqBC,MAAM,CAACjD,OAAP,CAAeY,KAAf,CAA3B;AACA,QAAMf,MAAM,GAAG,MAAM6C,MAAM,CAAC;AAC1B,KAACK,QAAD,GAAYC;AADc,GAAD,EAExB7B,aAFwB,CAA3B;AAGA,SAAO;AACL6B,IAAAA,IAAI;AAAE;AAAsBnD,IAAAA,MAAM,CAACmD,IAD9B;AAEL;AACA;AACAE,IAAAA,GAAG,EAAErD,MAAM,CAACqD,GAAP;AAAa;AAA8BrD,IAAAA,MAAM,CAACqD,GAAlD,GAAwDT,SAJxD;AAKLrB,IAAAA;AALK,GAAP;AAOD;AAED;AACA;AACA;;;AACAT,YAAY,CAACwC,mBAAb,GAAmC,MAAM;AACvC,MAAIC,WAAJ;;AACA,MAAI;AACF;AACAA,IAAAA,WAAW,GAAGT,OAAO,CAAC,qBAAD,CAArB;AACD,GAHD,CAGE,OAAOU,KAAP,EAAc,CACd;AACD;;AACD,SAAOD,WAAW,IAAIA,WAAW,CAACE,OAAlC;AACD,CATD;AAWA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeC,cAAf,CAA8B3C,KAA9B,EAAqCC,SAArC,EAAgDC,gBAAhD,EAAkEC,eAAlE,EAAmF;AACjF;AACF;AACA;AACA;AACE,QAAMC,QAAQ,GAAGb,KAAK,IAAI;AACxB,UAAMc,IAAI,GAAG,OAAOd,KAApB;AACA,WAAOA,KAAK,IAAI,IAAT,KAAkBc,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,UAAhD,CAAP;AACD,GAHD;AAKA;AACF;AACA;AACA;AACA;;;AACE,QAAMC,aAAa,GAAG,CAACsC,eAAD,EAAkBpC,iBAAlB,KAAwC;AAC5D;AACA,UAAMC,SAAS,GAAG,EAAlB;AACA,UAAM;AACJC,MAAAA;AADI,QAEFkC,eAAe,CAAChC,MAFpB;AAGAH,IAAAA,SAAS,CAACI,QAAV,GAAqB,OAAOH,QAAP,KAAoB,WAApB,GAAkCA,QAAlC,GAA6C,KAAlE;;AACA,QAAI,OAAOP,eAAP,KAA2B,SAA3B,IAAwCA,eAA5C,EAA6D;AAC3DM,MAAAA,SAAS,CAACK,OAAV,GAAoB,MAApB;AACD,KAFD,MAEO,IAAI,OAAOX,eAAP,KAA2B,QAA3B,IAAuCA,eAAe,YAAYY,MAAtE,EAA8E;AACnFN,MAAAA,SAAS,CAACK,OAAV,GAAoBX,eAApB;AACD,KAFM,MAEA,IAAI,OAAOA,eAAP,KAA2B,UAA/B,EAA2C;AAChDM,MAAAA,SAAS,CAACK,OAAV,GAAoBX,eAApB;AACD,KAFM,MAEA,IAAIA,eAAe,IAAIC,QAAQ,CAACD,eAAD,CAA/B,EAAkD;AACvDM,MAAAA,SAAS,CAACK,OAAV,GAAoB,OAAOX,eAAe,CAACM,SAAvB,KAAqC,SAArC,IAAkDN,eAAe,CAACM,SAAlE,GAA8E,MAA9E,GAAuF,OAAON,eAAe,CAACM,SAAvB,KAAqC,WAArC,GAAmDN,eAAe,CAACM,SAAnE,GAA+E,MAA1L;AACD,KAFM,MAEA;AACL;AACA;AACAA,MAAAA,SAAS,CAACI,QAAV,GAAqB,OAAOH,QAAP,KAAoB,WAApB,GAAkCA,QAAlC,GAA6C,MAAlE;AACAD,MAAAA,SAAS,CAACK,OAAV,GAAoB,KAApB;AACD,KApB2D,CAsB5D;;;AACA,KAAC,UAAD,EAAa,SAAb,EAAwBhB,OAAxB,CAAgCkB,GAAG,IAAI;AACrC;AACA,UAAIC,QAAJ;AACA;;AACA,UAAIC,KAAJ;;AACA,cAAQ,OAAOT,SAAS,CAACO,GAAD,CAAxB;AACE,aAAK,SAAL;AACEP,UAAAA,SAAS,CAACO,GAAD,CAAT,GAAiBP,SAAS,CAACO,GAAD,CAAT,GAAiB,MAAM,IAAvB,GAA8B,MAAM,KAArD;AACA;;AACF,aAAK,UAAL;AACE;;AACF,aAAK,QAAL;AACE,cAAIP,SAAS,CAACO,GAAD,CAAT,KAAmB,KAAvB,EAA8B;AAC5BP,YAAAA,SAAS,CAACO,GAAD,CAAT,GAAiB,MAAM,IAAvB;;AACA;AACD;;AACD,cAAIP,SAAS,CAACO,GAAD,CAAT,KAAmB,MAAvB,EAA+B;AAC7BP,YAAAA,SAAS,CAACO,GAAD,CAAT;AAAiB;AACjB,aAACG,OAAD,EAAUC,OAAV,KAAsB,CAACA,OAAO,CAACf,IAAR,KAAiB,UAAjB,IAA+Be,OAAO,CAACf,IAAR,KAAiB,UAAjD,KAAgE,+BAA+BgB,IAA/B,CAAoCD,OAAO,CAAC7B,KAA5C,CADtF;;AAEA;AACD;;AACD0B,UAAAA,QAAQ;AAAG;AAAqBR,UAAAA,SAAS,CAACO,GAAD,CAAzC;;AACAP,UAAAA,SAAS,CAACO,GAAD,CAAT;AAAiB;AACjB,WAACG,OAAD,EAAUC,OAAV,KAAsB,IAAIL,MAAJ;AAAY;AAAqBE,UAAAA,QAAjC,EAA2CI,IAA3C,CAAgDD,OAAO,CAAC7B,KAAxD,CADtB;;AAEA;;AACF;AACE2B,UAAAA,KAAK;AAAG;AAAqBT,UAAAA,SAAS,CAACO,GAAD,CAAtC;;AACAP,UAAAA,SAAS,CAACO,GAAD,CAAT;AAAiB;AACjB,WAACG,OAAD,EAAUC,OAAV;AAAsB;AAAqBF,UAAAA,KAAK,CAACG,IAAN,CAAWD,OAAO,CAAC7B,KAAnB,CAD3C;;AAtBJ;AAyBD,KA9BD,EAvB4D,CAuD5D;AACA;;AACA,WAAO,CAAC4B,OAAD,EAAUC,OAAV,KAAsB;AAC3B;AAAK;AACLX,MAAAA,SAAS,CAACK,OAAV,CAAkBK,OAAlB,EAA2BC,OAA3B,CADA,EACqC;AACnC,cAAME,WAAW,GAAGF,OAAO,CAACf,IAAR,KAAiB,UAAjB,GAA+B,KAAIe,OAAO,CAAC7B,KAAM,IAAjD,GAAwD,KAAI6B,OAAO,CAAC7B,KAAM,EAA9F,CADmC,CAGnC;;AACA,YAAI,CAACiB,iBAAiB,CAACf,QAAlB,CAA2B6B,WAA3B,CAAL,EAA8C;AAC5Cd,UAAAA,iBAAiB,CAACe,IAAlB,CAAuBD,WAAvB;AACD;AACF;;AACD;AAAQ;AAAoDb,QAAAA,SAAS,CAACI,QAAV,CAAmBM,OAAnB,EAA4BC,OAA5B;AAA5D;AAED,KAZD;AAaD,GAtED;AAwEA;AACF;AACA;AACA;;;AACE,QAAMyB,oBAAoB,GAAG,YAA0B;AAAA,QAAzBD,eAAyB,uEAAP,EAAO;AACrD;AACA,WAAO1C,gBAAgB,CAAC+B,IAAxB,CAFqD,CAGrD;;AACA,WAAO/B,gBAAgB,CAAC4C,MAAxB,CAJqD,CAMrD;;AACA,WAAO,EACL,GAAGF,eADE;AAEL;AACAhB,MAAAA,KAAK,EAAE,EACL,GAAGgB,eAAe,CAAChB;AADd,OAHF;AAMLH,MAAAA,QAAQ,EAAE,OAAOmB,eAAe,CAACnB,QAAvB,KAAoC,SAApC,GAAgDmB,eAAe,CAACnB,QAAhE,GAA2E,EACnF,GAAGmB,eAAe,CAACnB;AADgE,OANhF;AASLC,MAAAA,MAAM,EAAEkB,eAAe,CAAClB,MAAhB,IAA0B,IAA1B,GAAiC,IAAjC,GAAwC,OAAOkB,eAAe,CAAClB,MAAvB,KAAkC,SAAlC,GAA8CkB,eAAe,CAAClB,MAA9D,GAAuE,EACrH,GAAGkB,eAAe,CAAClB;AADkG,OATlH;AAYLd,MAAAA,MAAM,EAAE;AACNe,QAAAA,QAAQ,EAAE,KADJ;AAEN,WAAGiB,eAAe,CAAChC;AAFb,OAZH;AAgBL;AACA;AACAX,MAAAA,SAAS,EAAE4B,SAlBN,CAmBL;AACA;AACA;AACA;;AAtBK,KAAP;AAwBD,GA/BD,CA3FiF,CA4HjF;;;AACA,QAAM;AACJC,IAAAA;AADI,MAEFC,OAAO,CAAC,WAAD,CAFX,CA7HiF,CAiIjF;;;AACA,QAAMa,eAAe,GAAGC,oBAAoB,CAAC3C,gBAAD,CAA5C,CAlIiF,CAoIjF;;AACA,MAAID,SAAJ,EAAe;AACb;AACA2C,IAAAA,eAAe,CAAC3C,SAAhB,GAA4B,IAA5B;AACD;AAED;;;AACA,QAAMO,iBAAiB,GAAG,EAA1B,CA3IiF,CA6IjF;;AACAoC,EAAAA,eAAe,CAAChC,MAAhB,CAAuBF,QAAvB,GAAkCJ,aAAa,CAACsC,eAAD,EAAkBpC,iBAAlB,CAA/C;AACA,QAAM,CAAC,CAAC2B,QAAD,EAAWC,IAAX,CAAD,IAAqBC,MAAM,CAACjD,OAAP,CAAeY,KAAf,CAA3B;AACA,QAAMf,MAAM,GAAG,MAAM6C,MAAM,CAAC;AAC1B,KAACK,QAAD,GAAYC;AADc,GAAD,EAExBQ,eAFwB,CAA3B;AAGA,SAAO;AACLR,IAAAA,IAAI,EAAEnD,MAAM,CAACmD,IADR;AAEL;AACAE,IAAAA,GAAG,EAAErD,MAAM,CAACqD,GAAP,GAAaS,IAAI,CAACnB,KAAL,CAAW3C,MAAM,CAACqD,GAAlB,CAAb,GAAsCT,SAHtC;AAILmB,IAAAA,MAAM,EAAE/D,MAAM,CAACwD,KAAP,GAAe,CAACxD,MAAM,CAACwD,KAAR,CAAf,GAAgC,EAJnC;AAKLQ,IAAAA,QAAQ,EAAEhE,MAAM,CAACgE,QAAP,IAAmB,EALxB;AAMLzC,IAAAA;AANK,GAAP;AAQD;AAED;AACA;AACA;;;AACAmC,cAAc,CAACJ,mBAAf,GAAqC,MAAM;AACzC,MAAIC,WAAJ;;AACA,MAAI;AACF;AACAA,IAAAA,WAAW,GAAGT,OAAO,CAAC,wBAAD,CAArB;AACD,GAHD,CAGE,OAAOU,KAAP,EAAc,CACd;AACD;;AACD,SAAOD,WAAW,IAAIA,WAAW,CAACE,OAAlC;AACD,CATD;AAWA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeQ,SAAf,CAAyBlD,KAAzB,EAAgCC,SAAhC,EAA2CC,gBAA3C,EAA6D;AAC3D;AACF;AACA;AACA;AACE,QAAMiD,eAAe,GAAG,YAAqB;AAAA,QAApBC,UAAoB,uEAAP,EAAO;AAC3C;AACA,WAAO,EACL,GAAGA,UADE;AAEL3B,MAAAA,QAAQ,EAAE,OAAO2B,UAAU,CAAC3B,QAAlB,KAA+B,SAA/B,GAA2C2B,UAAU,CAAC3B,QAAX,GAAsB,EAAtB,GAA2B,KAAtE,GAA8E,EACtF,GAAG2B,UAAU,CAAC3B;AADwE,OAFnF;AAKLC,MAAAA,MAAM,EAAE0B,UAAU,CAAC1B,MAAX,IAAqB,IAArB,GAA4B,IAA5B,GAAmC,OAAO0B,UAAU,CAAC1B,MAAlB,KAA6B,SAA7B,GAAyC0B,UAAU,CAAC1B,MAApD,GAA6D,EACtG,GAAG0B,UAAU,CAAC1B;AADwF,OALnG;AAQL;AACA;AACA;AACA;AACA;AACA;AACA;AACAzB,MAAAA,SAAS,EAAE4B;AAfN,KAAP;AAiBD,GAnBD,CAL2D,CA0B3D;;;AACA,QAAMwB,GAAG,GAAGtB,OAAO,CAAC,WAAD,CAAnB,CA3B2D,CA4B3D;;;AACA,QAAMqB,UAAU,GAAGD,eAAe,CAACjD,gBAAD,CAAlC,CA7B2D,CA+B3D;;AACA,MAAID,SAAJ,EAAe;AACb;AACAmD,IAAAA,UAAU,CAACnD,SAAX,GAAuB,IAAvB;AACD;;AACD,MAAImD,UAAU,CAAC3B,QAAf,EAAyB;AACvB;AACA,QAAI,OAAO2B,UAAU,CAAC3B,QAAX,CAAoBQ,IAA3B,KAAoC,WAAxC,EAAqD;AACnDmB,MAAAA,UAAU,CAAC3B,QAAX,CAAoBQ,IAApB,GAA2BmB,UAAU,CAACnB,IAAtC;AACD,KAJsB,CAMvB;;;AACA,QAAImB,UAAU,CAACnB,IAAX,KAAoB,CAApB,IAAyB,OAAOmB,UAAU,CAAC3B,QAAX,CAAoBS,MAA3B,KAAsC,WAAnE,EAAgF;AAC9EkB,MAAAA,UAAU,CAAC3B,QAAX,CAAoBS,MAApB,GAA6B,KAA7B;AACD;AACF;;AACD,QAAM,CAAC,CAACC,QAAD,EAAWC,IAAX,CAAD,IAAqBC,MAAM,CAACjD,OAAP,CAAeY,KAAf,CAA3B;AACA,QAAMf,MAAM,GAAG,MAAMoE,GAAG,CAACvB,MAAJ,CAAWM,IAAX,EAAiBgB,UAAjB,CAArB;AACA,MAAId,GAAJ;;AACA,MAAIrD,MAAM,CAACqD,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAGS,IAAI,CAACnB,KAAL,CAAW3C,MAAM,CAACqD,GAAlB,CAAN,CADc,CAGd;;AACAA,IAAAA,GAAG,CAACgB,OAAJ,GAAc,CAACnB,QAAD,CAAd;AACA,WAAOG,GAAG,CAACiB,cAAX;AACD;;AACD,SAAO;AACLnB,IAAAA,IAAI,EAAEnD,MAAM,CAACmD,IADR;AAELE,IAAAA;AAFK,GAAP;AAID;AAED;AACA;AACA;;;AACAY,SAAS,CAACX,mBAAV,GAAgC,MAAM;AACpC,MAAIC,WAAJ;;AACA,MAAI;AACF;AACAA,IAAAA,WAAW,GAAGT,OAAO,CAAC,wBAAD,CAArB;AACD,GAHD,CAGE,OAAOU,KAAP,EAAc,CACd;AACD;;AACD,SAAOD,WAAW,IAAIA,WAAW,CAACE,OAAlC;AACD,CATD;AAWA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAec,aAAf,CAA6BxD,KAA7B,EAAoCC,SAApC,EAA+CC,gBAA/C,EAAiE;AAC/D;AACF;AACA;AACA;AACE,QAAMuD,mBAAmB,GAAG,YAAyB;AAAA,QAAxBC,cAAwB,uEAAP,EAAO;AACnD;AACA,WAAOA,cAAc,CAACzB,IAAtB;;AACA,QAAIyB,cAAc,CAACZ,MAAnB,EAA2B;AACzB;AACAY,MAAAA,cAAc,CAAC/C,MAAf,GAAwB,KAAxB;AACD,KANkD,CAQnD;;;AACA,WAAO+C,cAAc,CAACZ,MAAtB,CATmD,CAWnD;;AACA,WAAO;AACLhB,MAAAA,MAAM,EAAE,IADH;AAEL6B,MAAAA,aAAa,EAAE,QAFV;AAGL,SAAGD,cAHE;AAILE,MAAAA,SAAS,EAAE;AAJN,KAAP;AAMD,GAlBD,CAL+D,CAyB/D;;;AACA,QAAMC,OAAO,GAAG9B,OAAO,CAAC,SAAD,CAAvB,CA1B+D,CA4B/D;;;AACA,QAAM2B,cAAc,GAAGD,mBAAmB,CAACvD,gBAAD,CAA1C,CA7B+D,CA+B/D;;AACA,MAAID,SAAJ,EAAe;AACbyD,IAAAA,cAAc,CAACE,SAAf,GAA2B,IAA3B;AACAF,IAAAA,cAAc,CAACH,cAAf,GAAgC,KAAhC;AACD;;AACD,QAAM,CAAC,CAACpB,QAAD,EAAWC,IAAX,CAAD,IAAqBC,MAAM,CAACjD,OAAP,CAAeY,KAAf,CAA3B;AACA0D,EAAAA,cAAc,CAACI,UAAf,GAA4B3B,QAA5B;AACA,QAAMlD,MAAM,GAAG,MAAM4E,OAAO,CAACE,SAAR,CAAkB3B,IAAlB,EAAwBsB,cAAxB,CAArB;AACA,SAAO;AACLtB,IAAAA,IAAI,EAAEnD,MAAM,CAACmD,IADR;AAEL;AACAE,IAAAA,GAAG,EAAErD,MAAM,CAACqD,GAAP,GAAaS,IAAI,CAACnB,KAAL,CAAW3C,MAAM,CAACqD,GAAlB,CAAb,GAAsCT,SAHtC;AAILoB,IAAAA,QAAQ,EAAEhE,MAAM,CAACgE,QAAP,CAAgB/D,MAAhB,GAAyB,CAAzB,GAA6BD,MAAM,CAACgE,QAAP,CAAgBX,GAAhB,CAAoB0B,IAAI,IAAI;AACjE,YAAMC,MAAM,GAAGD,IAAI,CAACE,UAAL,GAAmB,kBAAiBF,IAAI,CAACE,UAAW,EAApD,GAAwD,EAAvE;AACA,YAAMC,QAAQ,GAAGH,IAAI,CAACG,QAAL,GAAiB,OAAMH,IAAI,CAACG,QAAL,CAAcC,IAAK,IAAGJ,IAAI,CAACG,QAAL,CAAcE,IAAK,IAAGL,IAAI,CAACG,QAAL,CAAcG,MAAO,QAAON,IAAI,CAACG,QAAL,CAAcE,IAAK,MAAKL,IAAI,CAACG,QAAL,CAAcI,QAAS,mBAAkBP,IAAI,CAACG,QAAL,CAAcK,UAAW,EAAzL,GAA6L,EAA9M;AACA,YAAMC,KAAK,GAAGT,IAAI,CAACS,KAAL,CAAWvF,MAAX,GAAoB,CAApB,GAAyB,eAAc8E,IAAI,CAACS,KAAL,CAAWnC,GAAX,CAAeoC,IAAI,IAAK,GAAEA,IAAI,CAACP,QAAL,GAAiB,IAAGO,IAAI,CAACP,QAAL,CAAcC,IAAK,IAAGM,IAAI,CAACP,QAAL,CAAcE,IAAK,IAAGK,IAAI,CAACP,QAAL,CAAcG,MAAO,IAArF,GAA2F,EAAG,GAAEI,IAAI,CAACC,IAAK,GAAED,IAAI,CAACP,QAAL,GAAiB,iBAAgBO,IAAI,CAACP,QAAL,CAAcK,UAAW,EAA1D,GAA8D,EAAG,GAAEE,IAAI,CAACP,QAAL,GAAiB,iBAAgBO,IAAI,CAACP,QAAL,CAAcI,QAAS,IAAxD,GAA8D,EAAG,EAA1Q,EAA6QK,IAA7Q,CAAkR,IAAlR,CAAwR,EAA/T,GAAmU,EAAjV;AACA,aAAQ,GAAEZ,IAAI,CAACW,IAAK,KAAIX,IAAI,CAACa,EAAG,IAAGZ,MAAO,GAAEE,QAAS,GAAEH,IAAI,CAACc,MAAL,GAAe,eAAcd,IAAI,CAACc,MAAO,EAAzC,GAA6C,EAAG,GAAEL,KAAM,EAA/G;AACD,KALsC,CAA7B,GAKL;AATA,GAAP;AAWD;AAED;AACA;AACA;;;AACAjB,aAAa,CAACjB,mBAAd,GAAoC,MAAM;AACxC,MAAIC,WAAJ;;AACA,MAAI;AACF;AACAA,IAAAA,WAAW,GAAGT,OAAO,CAAC,sBAAD,CAArB;AACD,GAHD,CAGE,OAAOU,KAAP,EAAc,CACd;AACD;;AACD,SAAOD,WAAW,IAAIA,WAAW,CAACE,OAAlC;AACD,CATD;;AAUAI,MAAM,CAACiC,OAAP,GAAiB;AACf3G,EAAAA,WADe;AAEf2B,EAAAA,YAFe;AAGf4C,EAAAA,cAHe;AAIfO,EAAAA,SAJe;AAKfM,EAAAA;AALe,CAAjB","sourcesContent":["\"use strict\";\n\n/** @typedef {import(\"@jridgewell/trace-mapping\").SourceMapInput} SourceMapInput */\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n/** @typedef {import(\"terser\").CompressOptions} TerserCompressOptions */\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n/** @typedef {import(\"./index.js\").Input} Input */\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\n\nconst notSettled = Symbol(`not-settled`);\n\n/**\n * @template T\n * @typedef {() => Promise<T>} Task\n */\n\n/**\n * Run tasks with limited concurrency.\n * @template T\n * @param {number} limit - Limit of tasks that run at once.\n * @param {Task<T>[]} tasks - List of tasks to run.\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\n */\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(`Expected \\`limit\\` to be a finite number > 0, got \\`${limit}\\` (${typeof limit})`);\n  }\n  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {\n    throw new TypeError(`Expected \\`tasks\\` to be a list of functions returning a promise`);\n  }\n  return new Promise((resolve, reject) => {\n    const result = Array(tasks.length).fill(notSettled);\n    const entries = tasks.entries();\n    const next = () => {\n      const {\n        done,\n        value\n      } = entries.next();\n      if (done) {\n        const isLast = !result.includes(notSettled);\n        if (isLast) resolve( /** @type{T[]} **/result);\n        return;\n      }\n      const [index, task] = value;\n\n      /**\n       * @param {T} x\n       */\n      const onFulfilled = x => {\n        result[index] = x;\n        next();\n      };\n      task().then(onFulfilled, reject);\n    };\n    Array(limit).fill(0).forEach(next);\n  });\n}\n\n/* istanbul ignore next */\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\nasync function terserMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n\n  /**\n   * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n  const buildComments = (terserOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    let comments;\n    if (terserOptions.format) {\n      ({\n        comments\n      } = terserOptions.format);\n    } else if (terserOptions.output) {\n      ({\n        comments\n      } = terserOptions.output);\n    }\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    }\n\n    // Ensure that both conditions are functions\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n      let regex;\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n        case \"function\":\n          break;\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n            break;\n          }\n          if (condition[key] === \"some\") {\n            condition[key] = /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n            break;\n          }\n          regexStr = /** @type {string} */condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp( /** @type {string} */regexStr).test(comment.value);\n          break;\n        default:\n          regex = /** @type {RegExp} */condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => /** @type {RegExp} */regex.test(comment.value);\n      }\n    });\n\n    // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n    return (astNode, comment) => {\n      if ( /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`;\n\n        // Don't include duplicate comments\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n      return (/** @type {{ preserve: ExtractCommentsFunction }} */condition.preserve(astNode, comment)\n      );\n    };\n  };\n\n  /**\n   * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\n   * @returns {TerserOptions & { sourceMap: undefined } & { compress: TerserCompressOptions } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\n   */\n  const buildTerserOptions = (terserOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return {\n      ...terserOptions,\n      compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress ? {} : false : {\n        ...terserOptions.compress\n      },\n      // ecma: terserOptions.ecma,\n      // ie8: terserOptions.ie8,\n      // keep_classnames: terserOptions.keep_classnames,\n      // keep_fnames: terserOptions.keep_fnames,\n      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : {\n        ...terserOptions.mangle\n      },\n      // module: terserOptions.module,\n      // nameCache: { ...terserOptions.toplevel },\n      // the `output` option is deprecated\n      ...(terserOptions.format ? {\n        format: {\n          beautify: false,\n          ...terserOptions.format\n        }\n      } : {\n        output: {\n          beautify: false,\n          ...terserOptions.output\n        }\n      }),\n      parse: {\n        ...terserOptions.parse\n      },\n      // safari10: terserOptions.safari10,\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n      // toplevel: terserOptions.toplevel\n    };\n  };\n\n  // eslint-disable-next-line global-require\n  const {\n    minify\n  } = require(\"terser\");\n  // Copy `terser` options\n  const terserOptions = buildTerserOptions(minimizerOptions);\n\n  // Let terser generate a SourceMap\n  if (sourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n\n  /** @type {ExtractedComments} */\n  const extractedComments = [];\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n  }\n  if (terserOptions.compress) {\n    // More optimizations\n    if (typeof terserOptions.compress.ecma === \"undefined\") {\n      terserOptions.compress.ecma = terserOptions.ecma;\n    }\n\n    // https://github.com/webpack/webpack/issues/16135\n    if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === \"undefined\") {\n      terserOptions.compress.arrows = false;\n    }\n  }\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, terserOptions);\n  return {\n    code: /** @type {string} **/result.code,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    map: result.map ? /** @type {SourceMapInput} **/result.map : undefined,\n    extractedComments\n  };\n}\n\n/**\n * @returns {string | undefined}\n */\nterserMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {\n    // Ignore\n  }\n  return packageJson && packageJson.version;\n};\n\n/* istanbul ignore next */\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\nasync function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n\n  /**\n   * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n  const buildComments = (uglifyJsOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    const {\n      comments\n    } = uglifyJsOptions.output;\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    }\n\n    // Ensure that both conditions are functions\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n      let regex;\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n        case \"function\":\n          break;\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n            break;\n          }\n          if (condition[key] === \"some\") {\n            condition[key] = /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n            break;\n          }\n          regexStr = /** @type {string} */condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp( /** @type {string} */regexStr).test(comment.value);\n          break;\n        default:\n          regex = /** @type {RegExp} */condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => /** @type {RegExp} */regex.test(comment.value);\n      }\n    });\n\n    // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n    return (astNode, comment) => {\n      if ( /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`;\n\n        // Don't include duplicate comments\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n      return (/** @type {{ preserve: ExtractCommentsFunction }} */condition.preserve(astNode, comment)\n      );\n    };\n  };\n\n  /**\n   * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\n   * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\n   */\n  const buildUglifyJsOptions = (uglifyJsOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete minimizerOptions.ecma;\n    // eslint-disable-next-line no-param-reassign\n    delete minimizerOptions.module;\n\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return {\n      ...uglifyJsOptions,\n      // warnings: uglifyJsOptions.warnings,\n      parse: {\n        ...uglifyJsOptions.parse\n      },\n      compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : {\n        ...uglifyJsOptions.compress\n      },\n      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : {\n        ...uglifyJsOptions.mangle\n      },\n      output: {\n        beautify: false,\n        ...uglifyJsOptions.output\n      },\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n      // toplevel: uglifyJsOptions.toplevel\n      // nameCache: { ...uglifyJsOptions.toplevel },\n      // ie8: uglifyJsOptions.ie8,\n      // keep_fnames: uglifyJsOptions.keep_fnames,\n    };\n  };\n\n  // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n  const {\n    minify\n  } = require(\"uglify-js\");\n\n  // Copy `uglify-js` options\n  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions);\n\n  // Let terser generate a SourceMap\n  if (sourceMap) {\n    // @ts-ignore\n    uglifyJsOptions.sourceMap = true;\n  }\n\n  /** @type {ExtractedComments} */\n  const extractedComments = [];\n\n  // @ts-ignore\n  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, uglifyJsOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    errors: result.error ? [result.error] : [],\n    warnings: result.warnings || [],\n    extractedComments\n  };\n}\n\n/**\n * @returns {string | undefined}\n */\nuglifyJsMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {\n    // Ignore\n  }\n  return packageJson && packageJson.version;\n};\n\n/* istanbul ignore next */\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\nasync function swcMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\n   * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined } & { compress: import(\"@swc/core\").TerserCompressOptions }}\n   */\n  const buildSwcOptions = (swcOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return {\n      ...swcOptions,\n      compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress ? {} : false : {\n        ...swcOptions.compress\n      },\n      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : {\n        ...swcOptions.mangle\n      },\n      // ecma: swcOptions.ecma,\n      // keep_classnames: swcOptions.keep_classnames,\n      // keep_fnames: swcOptions.keep_fnames,\n      // module: swcOptions.module,\n      // safari10: swcOptions.safari10,\n      // toplevel: swcOptions.toplevel\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n    };\n  };\n\n  // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n  const swc = require(\"@swc/core\");\n  // Copy `swc` options\n  const swcOptions = buildSwcOptions(minimizerOptions);\n\n  // Let `swc` generate a SourceMap\n  if (sourceMap) {\n    // @ts-ignore\n    swcOptions.sourceMap = true;\n  }\n  if (swcOptions.compress) {\n    // More optimizations\n    if (typeof swcOptions.compress.ecma === \"undefined\") {\n      swcOptions.compress.ecma = swcOptions.ecma;\n    }\n\n    // https://github.com/webpack/webpack/issues/16135\n    if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === \"undefined\") {\n      swcOptions.compress.arrows = false;\n    }\n  }\n  const [[filename, code]] = Object.entries(input);\n  const result = await swc.minify(code, swcOptions);\n  let map;\n  if (result.map) {\n    map = JSON.parse(result.map);\n\n    // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n    map.sources = [filename];\n    delete map.sourcesContent;\n  }\n  return {\n    code: result.code,\n    map\n  };\n}\n\n/**\n * @returns {string | undefined}\n */\nswcMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {\n    // Ignore\n  }\n  return packageJson && packageJson.version;\n};\n\n/* istanbul ignore next */\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\nasync function esbuildMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\n   * @returns {import(\"esbuild\").TransformOptions}\n   */\n  const buildEsbuildOptions = (esbuildOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete esbuildOptions.ecma;\n    if (esbuildOptions.module) {\n      // eslint-disable-next-line no-param-reassign\n      esbuildOptions.format = \"esm\";\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    delete esbuildOptions.module;\n\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return {\n      minify: true,\n      legalComments: \"inline\",\n      ...esbuildOptions,\n      sourcemap: false\n    };\n  };\n\n  // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n  const esbuild = require(\"esbuild\");\n\n  // Copy `esbuild` options\n  const esbuildOptions = buildEsbuildOptions(minimizerOptions);\n\n  // Let `esbuild` generate a SourceMap\n  if (sourceMap) {\n    esbuildOptions.sourcemap = true;\n    esbuildOptions.sourcesContent = false;\n  }\n  const [[filename, code]] = Object.entries(input);\n  esbuildOptions.sourcefile = filename;\n  const result = await esbuild.transform(code, esbuildOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    warnings: result.warnings.length > 0 ? result.warnings.map(item => {\n      const plugin = item.pluginName ? `\\nPlugin Name: ${item.pluginName}` : \"\";\n      const location = item.location ? `\\n\\n${item.location.file}:${item.location.line}:${item.location.column}:\\n  ${item.location.line} | ${item.location.lineText}\\n\\nSuggestion: ${item.location.suggestion}` : \"\";\n      const notes = item.notes.length > 0 ? `\\n\\nNotes:\\n${item.notes.map(note => `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : \"\"}${note.text}${note.location ? `\\nSuggestion: ${note.location.suggestion}` : \"\"}${note.location ? `\\nLine text:\\n${note.location.lineText}\\n` : \"\"}`).join(\"\\n\")}` : \"\";\n      return `${item.text} [${item.id}]${plugin}${location}${item.detail ? `\\nDetails:\\n${item.detail}` : \"\"}${notes}`;\n    }) : []\n  };\n}\n\n/**\n * @returns {string | undefined}\n */\nesbuildMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {\n    // Ignore\n  }\n  return packageJson && packageJson.version;\n};\nmodule.exports = {\n  throttleAll,\n  terserMinify,\n  uglifyJsMinify,\n  swcMinify,\n  esbuildMinify\n};"]},"metadata":{},"sourceType":"script"}