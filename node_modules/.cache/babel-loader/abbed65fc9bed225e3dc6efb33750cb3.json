{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { unstable_useId as useId } from '@mui/utils';\nimport { ListContext } from '../useList';\n/**\n * Stabilizes the ListContext value for the MenuItem component, so it doesn't change when sibling items update.\n *\n * @param id The id of the MenuItem. If undefined, it will be generated with useId.\n * @returns The stable ListContext value and the id of the MenuItem.\n *\n * Demos:\n *\n * - [Menu](https://mui.com/base-ui/react-menu/#hooks)\n *\n * API:\n *\n * - [useMenuItemContextStabilizer API](https://mui.com/base-ui/react-menu/hooks-api/#use-menu-item-context-stabilizer)\n */\n\nexport function useMenuItemContextStabilizer(id) {\n  const listContext = React.useContext(ListContext);\n\n  if (!listContext) {\n    throw new Error('MenuItem: ListContext was not found.');\n  }\n\n  const itemId = useId(id);\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  let itemState;\n\n  if (itemId != null) {\n    itemState = getItemState(itemId);\n  } else {\n    itemState = {\n      focusable: true,\n      highlighted: false,\n      selected: false\n    };\n  }\n\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = itemState; // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== itemId) {\n      throw new Error(['Base UI MenuItem: Tried to access the state of another MenuItem.', `itemValue: ${itemValue} | id: ${itemId}`, 'This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization.'].join('/n'));\n    }\n\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, itemId]); // Create a local (per MenuItem) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes MenuItems re-render only when their state actually change, not when any MenuItem's state changes.\n\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue,\n    id: itemId\n  };\n}","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@mui/base/useMenuItem/useMenuItemContextStabilizer.js"],"names":["React","unstable_useId","useId","ListContext","useMenuItemContextStabilizer","id","listContext","useContext","Error","itemId","getItemState","dispatch","itemState","focusable","highlighted","selected","localGetItemState","useCallback","itemValue","join","localContextValue","useMemo","contextValue"],"mappings":"AAAA;;AAEA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,cAAc,IAAIC,KAA3B,QAAwC,YAAxC;AACA,SAASC,WAAT,QAA4B,YAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,4BAAT,CAAsCC,EAAtC,EAA0C;AAC/C,QAAMC,WAAW,GAAGN,KAAK,CAACO,UAAN,CAAiBJ,WAAjB,CAApB;;AACA,MAAI,CAACG,WAAL,EAAkB;AAChB,UAAM,IAAIE,KAAJ,CAAU,sCAAV,CAAN;AACD;;AACD,QAAMC,MAAM,GAAGP,KAAK,CAACG,EAAD,CAApB;AACA,QAAM;AACJK,IAAAA,YADI;AAEJC,IAAAA;AAFI,MAGFL,WAHJ;AAIA,MAAIM,SAAJ;;AACA,MAAIH,MAAM,IAAI,IAAd,EAAoB;AAClBG,IAAAA,SAAS,GAAGF,YAAY,CAACD,MAAD,CAAxB;AACD,GAFD,MAEO;AACLG,IAAAA,SAAS,GAAG;AACVC,MAAAA,SAAS,EAAE,IADD;AAEVC,MAAAA,WAAW,EAAE,KAFH;AAGVC,MAAAA,QAAQ,EAAE;AAHA,KAAZ;AAKD;;AACD,QAAM;AACJD,IAAAA,WADI;AAEJC,IAAAA,QAFI;AAGJF,IAAAA;AAHI,MAIFD,SAJJ,CApB+C,CA0B/C;AACA;;AACA,QAAMI,iBAAiB,GAAGhB,KAAK,CAACiB,WAAN,CAAkBC,SAAS,IAAI;AACvD,QAAIA,SAAS,KAAKT,MAAlB,EAA0B;AACxB,YAAM,IAAID,KAAJ,CAAU,CAAC,kEAAD,EAAsE,cAAaU,SAAU,UAAST,MAAO,EAA7G,EAAgH,yGAAhH,EAA2NU,IAA3N,CAAgO,IAAhO,CAAV,CAAN;AACD;;AACD,WAAO;AACLL,MAAAA,WADK;AAELC,MAAAA,QAFK;AAGLF,MAAAA;AAHK,KAAP;AAKD,GATyB,EASvB,CAACC,WAAD,EAAcC,QAAd,EAAwBF,SAAxB,EAAmCJ,MAAnC,CATuB,CAA1B,CA5B+C,CAuC/C;AACA;AACA;;AACA,QAAMW,iBAAiB,GAAGpB,KAAK,CAACqB,OAAN,CAAc,OAAO;AAC7CV,IAAAA,QAD6C;AAE7CD,IAAAA,YAAY,EAAEM;AAF+B,GAAP,CAAd,EAGtB,CAACL,QAAD,EAAWK,iBAAX,CAHsB,CAA1B;AAIA,SAAO;AACLM,IAAAA,YAAY,EAAEF,iBADT;AAELf,IAAAA,EAAE,EAAEI;AAFC,GAAP;AAID","sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { unstable_useId as useId } from '@mui/utils';\nimport { ListContext } from '../useList';\n\n/**\n * Stabilizes the ListContext value for the MenuItem component, so it doesn't change when sibling items update.\n *\n * @param id The id of the MenuItem. If undefined, it will be generated with useId.\n * @returns The stable ListContext value and the id of the MenuItem.\n *\n * Demos:\n *\n * - [Menu](https://mui.com/base-ui/react-menu/#hooks)\n *\n * API:\n *\n * - [useMenuItemContextStabilizer API](https://mui.com/base-ui/react-menu/hooks-api/#use-menu-item-context-stabilizer)\n */\nexport function useMenuItemContextStabilizer(id) {\n  const listContext = React.useContext(ListContext);\n  if (!listContext) {\n    throw new Error('MenuItem: ListContext was not found.');\n  }\n  const itemId = useId(id);\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  let itemState;\n  if (itemId != null) {\n    itemState = getItemState(itemId);\n  } else {\n    itemState = {\n      focusable: true,\n      highlighted: false,\n      selected: false\n    };\n  }\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = itemState;\n\n  // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== itemId) {\n      throw new Error(['Base UI MenuItem: Tried to access the state of another MenuItem.', `itemValue: ${itemValue} | id: ${itemId}`, 'This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization.'].join('/n'));\n    }\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, itemId]);\n\n  // Create a local (per MenuItem) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes MenuItems re-render only when their state actually change, not when any MenuItem's state changes.\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue,\n    id: itemId\n  };\n}"]},"metadata":{},"sourceType":"module"}