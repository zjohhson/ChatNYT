{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.moduleContextFromModuleAST = moduleContextFromModuleAST;\nexports.ModuleContext = void 0;\n\nvar _nodes = require(\"../../nodes.js\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction moduleContextFromModuleAST(m) {\n  var moduleContext = new ModuleContext();\n\n  if (!(m.type === \"Module\")) {\n    throw new Error('m.type === \"Module\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  m.fields.forEach(function (field) {\n    switch (field.type) {\n      case \"Start\":\n        {\n          moduleContext.setStart(field.index);\n          break;\n        }\n\n      case \"TypeInstruction\":\n        {\n          moduleContext.addType(field);\n          break;\n        }\n\n      case \"Func\":\n        {\n          moduleContext.addFunction(field);\n          break;\n        }\n\n      case \"Global\":\n        {\n          moduleContext.defineGlobal(field);\n          break;\n        }\n\n      case \"ModuleImport\":\n        {\n          switch (field.descr.type) {\n            case \"GlobalType\":\n              {\n                moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);\n                break;\n              }\n\n            case \"Memory\":\n              {\n                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);\n                break;\n              }\n\n            case \"FuncImportDescr\":\n              {\n                moduleContext.importFunction(field.descr);\n                break;\n              }\n\n            case \"Table\":\n              {\n                // FIXME(sven): not implemented yet\n                break;\n              }\n\n            default:\n              throw new Error(\"Unsupported ModuleImport of type \" + JSON.stringify(field.descr.type));\n          }\n\n          break;\n        }\n\n      case \"Memory\":\n        {\n          moduleContext.addMemory(field.limits.min, field.limits.max);\n          break;\n        }\n    }\n  });\n  return moduleContext;\n}\n/**\n * Module context for type checking\n */\n\n\nvar ModuleContext = /*#__PURE__*/function () {\n  function ModuleContext() {\n    _classCallCheck(this, ModuleContext);\n\n    this.funcs = [];\n    this.funcsOffsetByIdentifier = [];\n    this.types = [];\n    this.globals = [];\n    this.globalsOffsetByIdentifier = [];\n    this.mems = []; // Current stack frame\n\n    this.locals = [];\n    this.labels = [];\n    this[\"return\"] = [];\n    this.debugName = \"unknown\";\n    this.start = null;\n  }\n  /**\n   * Set start segment\n   */\n\n\n  _createClass(ModuleContext, [{\n    key: \"setStart\",\n    value: function setStart(index) {\n      this.start = index.value;\n    }\n    /**\n     * Get start function\n     */\n\n  }, {\n    key: \"getStart\",\n    value: function getStart() {\n      return this.start;\n    }\n    /**\n     * Reset the active stack frame\n     */\n\n  }, {\n    key: \"newContext\",\n    value: function newContext(debugName, expectedResult) {\n      this.locals = [];\n      this.labels = [expectedResult];\n      this[\"return\"] = expectedResult;\n      this.debugName = debugName;\n    }\n    /**\n     * Functions\n     */\n\n  }, {\n    key: \"addFunction\",\n    value: function addFunction(func) {\n      /* eslint-disable */\n      // $FlowIgnore\n      var _ref = func.signature || {},\n          _ref$params = _ref.params,\n          args = _ref$params === void 0 ? [] : _ref$params,\n          _ref$results = _ref.results,\n          result = _ref$results === void 0 ? [] : _ref$results;\n      /* eslint-enable */\n\n\n      args = args.map(function (arg) {\n        return arg.valtype;\n      });\n      this.funcs.push({\n        args: args,\n        result: result\n      });\n\n      if (typeof func.name !== \"undefined\") {\n        // $FlowIgnore\n        this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"importFunction\",\n    value: function importFunction(funcimport) {\n      if ((0, _nodes.isSignature)(funcimport.signature)) {\n        // eslint-disable-next-line prefer-const\n        var _funcimport$signature = funcimport.signature,\n            args = _funcimport$signature.params,\n            result = _funcimport$signature.results;\n        args = args.map(function (arg) {\n          return arg.valtype;\n        });\n        this.funcs.push({\n          args: args,\n          result: result\n        });\n      } else {\n        if (!(0, _nodes.isNumberLiteral)(funcimport.signature)) {\n          throw new Error('isNumberLiteral(funcimport.signature)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var typeId = funcimport.signature.value;\n\n        if (!this.hasType(typeId)) {\n          throw new Error('this.hasType(typeId)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var signature = this.getType(typeId);\n        this.funcs.push({\n          args: signature.params.map(function (arg) {\n            return arg.valtype;\n          }),\n          result: signature.results\n        });\n      }\n\n      if (typeof funcimport.id !== \"undefined\") {\n        // imports are first, we can assume their index in the array\n        this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(index) {\n      return typeof this.getFunction(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(index) {\n      if (typeof index !== \"number\") {\n        throw new Error(\"getFunction only supported for number index\");\n      }\n\n      return this.funcs[index];\n    }\n  }, {\n    key: \"getFunctionOffsetByIdentifier\",\n    value: function getFunctionOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      return this.funcsOffsetByIdentifier[name];\n    }\n    /**\n     * Labels\n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(result) {\n      this.labels.unshift(result);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(index) {\n      return this.labels.length > index && index >= 0;\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(index) {\n      return this.labels[index];\n    }\n  }, {\n    key: \"popLabel\",\n    value: function popLabel() {\n      this.labels.shift();\n    }\n    /**\n     * Locals\n     */\n\n  }, {\n    key: \"hasLocal\",\n    value: function hasLocal(index) {\n      return typeof this.getLocal(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(index) {\n      return this.locals[index];\n    }\n  }, {\n    key: \"addLocal\",\n    value: function addLocal(type) {\n      this.locals.push(type);\n    }\n    /**\n     * Types\n     */\n\n  }, {\n    key: \"addType\",\n    value: function addType(type) {\n      if (!(type.functype.type === \"Signature\")) {\n        throw new Error('type.functype.type === \"Signature\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      this.types.push(type.functype);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(index) {\n      return this.types[index] !== undefined;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(index) {\n      return this.types[index];\n    }\n    /**\n     * Globals\n     */\n\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(index) {\n      return this.globals.length > index && index >= 0;\n    }\n  }, {\n    key: \"getGlobal\",\n    value: function getGlobal(index) {\n      return this.globals[index].type;\n    }\n  }, {\n    key: \"getGlobalOffsetByIdentifier\",\n    value: function getGlobalOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      } // $FlowIgnore\n\n\n      return this.globalsOffsetByIdentifier[name];\n    }\n  }, {\n    key: \"defineGlobal\",\n    value: function defineGlobal(global) {\n      var type = global.globalType.valtype;\n      var mutability = global.globalType.mutability;\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n\n      if (typeof global.name !== \"undefined\") {\n        // $FlowIgnore\n        this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;\n      }\n    }\n  }, {\n    key: \"importGlobal\",\n    value: function importGlobal(type, mutability) {\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n    }\n  }, {\n    key: \"isMutableGlobal\",\n    value: function isMutableGlobal(index) {\n      return this.globals[index].mutability === \"var\";\n    }\n  }, {\n    key: \"isImmutableGlobal\",\n    value: function isImmutableGlobal(index) {\n      return this.globals[index].mutability === \"const\";\n    }\n    /**\n     * Memories\n     */\n\n  }, {\n    key: \"hasMemory\",\n    value: function hasMemory(index) {\n      return this.mems.length > index && index >= 0;\n    }\n  }, {\n    key: \"addMemory\",\n    value: function addMemory(min, max) {\n      this.mems.push({\n        min: min,\n        max: max\n      });\n    }\n  }, {\n    key: \"getMemory\",\n    value: function getMemory(index) {\n      return this.mems[index];\n    }\n  }]);\n\n  return ModuleContext;\n}();\n\nexports.ModuleContext = ModuleContext;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/@webassemblyjs/ast/lib/transform/ast-module-to-module-context/index.js"],"names":["Object","defineProperty","exports","value","moduleContextFromModuleAST","ModuleContext","_nodes","require","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","m","moduleContext","type","Error","undefined","fields","forEach","field","setStart","index","addType","addFunction","defineGlobal","descr","importGlobal","valtype","mutability","addMemory","limits","min","max","importFunction","JSON","stringify","funcs","funcsOffsetByIdentifier","types","globals","globalsOffsetByIdentifier","mems","locals","labels","debugName","start","getStart","newContext","expectedResult","func","_ref","signature","_ref$params","params","args","_ref$results","results","result","map","arg","push","name","funcimport","isSignature","_funcimport$signature","isNumberLiteral","typeId","hasType","getType","id","hasFunction","getFunction","getFunctionOffsetByIdentifier","addLabel","unshift","hasLabel","getLabel","popLabel","shift","hasLocal","getLocal","addLocal","functype","hasGlobal","getGlobal","getGlobalOffsetByIdentifier","global","globalType","isMutableGlobal","isImmutableGlobal","hasMemory","getMemory"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.moduleContextFromModuleAST = moduleContextFromModuleAST;\nexports.ModuleContext = void 0;\n\nvar _nodes = require(\"../../nodes.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction moduleContextFromModuleAST(m) {\n  var moduleContext = new ModuleContext();\n\n  if (!(m.type === \"Module\")) {\n    throw new Error('m.type === \"Module\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  m.fields.forEach(function (field) {\n    switch (field.type) {\n      case \"Start\":\n        {\n          moduleContext.setStart(field.index);\n          break;\n        }\n\n      case \"TypeInstruction\":\n        {\n          moduleContext.addType(field);\n          break;\n        }\n\n      case \"Func\":\n        {\n          moduleContext.addFunction(field);\n          break;\n        }\n\n      case \"Global\":\n        {\n          moduleContext.defineGlobal(field);\n          break;\n        }\n\n      case \"ModuleImport\":\n        {\n          switch (field.descr.type) {\n            case \"GlobalType\":\n              {\n                moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);\n                break;\n              }\n\n            case \"Memory\":\n              {\n                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);\n                break;\n              }\n\n            case \"FuncImportDescr\":\n              {\n                moduleContext.importFunction(field.descr);\n                break;\n              }\n\n            case \"Table\":\n              {\n                // FIXME(sven): not implemented yet\n                break;\n              }\n\n            default:\n              throw new Error(\"Unsupported ModuleImport of type \" + JSON.stringify(field.descr.type));\n          }\n\n          break;\n        }\n\n      case \"Memory\":\n        {\n          moduleContext.addMemory(field.limits.min, field.limits.max);\n          break;\n        }\n    }\n  });\n  return moduleContext;\n}\n/**\n * Module context for type checking\n */\n\n\nvar ModuleContext = /*#__PURE__*/function () {\n  function ModuleContext() {\n    _classCallCheck(this, ModuleContext);\n\n    this.funcs = [];\n    this.funcsOffsetByIdentifier = [];\n    this.types = [];\n    this.globals = [];\n    this.globalsOffsetByIdentifier = [];\n    this.mems = []; // Current stack frame\n\n    this.locals = [];\n    this.labels = [];\n    this[\"return\"] = [];\n    this.debugName = \"unknown\";\n    this.start = null;\n  }\n  /**\n   * Set start segment\n   */\n\n\n  _createClass(ModuleContext, [{\n    key: \"setStart\",\n    value: function setStart(index) {\n      this.start = index.value;\n    }\n    /**\n     * Get start function\n     */\n\n  }, {\n    key: \"getStart\",\n    value: function getStart() {\n      return this.start;\n    }\n    /**\n     * Reset the active stack frame\n     */\n\n  }, {\n    key: \"newContext\",\n    value: function newContext(debugName, expectedResult) {\n      this.locals = [];\n      this.labels = [expectedResult];\n      this[\"return\"] = expectedResult;\n      this.debugName = debugName;\n    }\n    /**\n     * Functions\n     */\n\n  }, {\n    key: \"addFunction\",\n    value: function addFunction(func) {\n      /* eslint-disable */\n      // $FlowIgnore\n      var _ref = func.signature || {},\n          _ref$params = _ref.params,\n          args = _ref$params === void 0 ? [] : _ref$params,\n          _ref$results = _ref.results,\n          result = _ref$results === void 0 ? [] : _ref$results;\n      /* eslint-enable */\n\n\n      args = args.map(function (arg) {\n        return arg.valtype;\n      });\n      this.funcs.push({\n        args: args,\n        result: result\n      });\n\n      if (typeof func.name !== \"undefined\") {\n        // $FlowIgnore\n        this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"importFunction\",\n    value: function importFunction(funcimport) {\n      if ((0, _nodes.isSignature)(funcimport.signature)) {\n        // eslint-disable-next-line prefer-const\n        var _funcimport$signature = funcimport.signature,\n            args = _funcimport$signature.params,\n            result = _funcimport$signature.results;\n        args = args.map(function (arg) {\n          return arg.valtype;\n        });\n        this.funcs.push({\n          args: args,\n          result: result\n        });\n      } else {\n        if (!(0, _nodes.isNumberLiteral)(funcimport.signature)) {\n          throw new Error('isNumberLiteral(funcimport.signature)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var typeId = funcimport.signature.value;\n\n        if (!this.hasType(typeId)) {\n          throw new Error('this.hasType(typeId)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var signature = this.getType(typeId);\n        this.funcs.push({\n          args: signature.params.map(function (arg) {\n            return arg.valtype;\n          }),\n          result: signature.results\n        });\n      }\n\n      if (typeof funcimport.id !== \"undefined\") {\n        // imports are first, we can assume their index in the array\n        this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(index) {\n      return typeof this.getFunction(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(index) {\n      if (typeof index !== \"number\") {\n        throw new Error(\"getFunction only supported for number index\");\n      }\n\n      return this.funcs[index];\n    }\n  }, {\n    key: \"getFunctionOffsetByIdentifier\",\n    value: function getFunctionOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      return this.funcsOffsetByIdentifier[name];\n    }\n    /**\n     * Labels\n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(result) {\n      this.labels.unshift(result);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(index) {\n      return this.labels.length > index && index >= 0;\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(index) {\n      return this.labels[index];\n    }\n  }, {\n    key: \"popLabel\",\n    value: function popLabel() {\n      this.labels.shift();\n    }\n    /**\n     * Locals\n     */\n\n  }, {\n    key: \"hasLocal\",\n    value: function hasLocal(index) {\n      return typeof this.getLocal(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(index) {\n      return this.locals[index];\n    }\n  }, {\n    key: \"addLocal\",\n    value: function addLocal(type) {\n      this.locals.push(type);\n    }\n    /**\n     * Types\n     */\n\n  }, {\n    key: \"addType\",\n    value: function addType(type) {\n      if (!(type.functype.type === \"Signature\")) {\n        throw new Error('type.functype.type === \"Signature\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      this.types.push(type.functype);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(index) {\n      return this.types[index] !== undefined;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(index) {\n      return this.types[index];\n    }\n    /**\n     * Globals\n     */\n\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(index) {\n      return this.globals.length > index && index >= 0;\n    }\n  }, {\n    key: \"getGlobal\",\n    value: function getGlobal(index) {\n      return this.globals[index].type;\n    }\n  }, {\n    key: \"getGlobalOffsetByIdentifier\",\n    value: function getGlobalOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      // $FlowIgnore\n      return this.globalsOffsetByIdentifier[name];\n    }\n  }, {\n    key: \"defineGlobal\",\n    value: function defineGlobal(global) {\n      var type = global.globalType.valtype;\n      var mutability = global.globalType.mutability;\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n\n      if (typeof global.name !== \"undefined\") {\n        // $FlowIgnore\n        this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;\n      }\n    }\n  }, {\n    key: \"importGlobal\",\n    value: function importGlobal(type, mutability) {\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n    }\n  }, {\n    key: \"isMutableGlobal\",\n    value: function isMutableGlobal(index) {\n      return this.globals[index].mutability === \"var\";\n    }\n  }, {\n    key: \"isImmutableGlobal\",\n    value: function isImmutableGlobal(index) {\n      return this.globals[index].mutability === \"const\";\n    }\n    /**\n     * Memories\n     */\n\n  }, {\n    key: \"hasMemory\",\n    value: function hasMemory(index) {\n      return this.mems.length > index && index >= 0;\n    }\n  }, {\n    key: \"addMemory\",\n    value: function addMemory(min, max) {\n      this.mems.push({\n        min: min,\n        max: max\n      });\n    }\n  }, {\n    key: \"getMemory\",\n    value: function getMemory(index) {\n      return this.mems[index];\n    }\n  }]);\n\n  return ModuleContext;\n}();\n\nexports.ModuleContext = ModuleContext;"]},"metadata":{},"sourceType":"script"}