{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\n\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\n\nconst InnerGraph = require(\"./InnerGraph\");\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n\n/** @typedef {import(\"estree\").Node} Node */\n\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\n\nconst {\n  topLevelSymbolTag\n} = InnerGraph;\nconst PLUGIN_NAME = \"InnerGraphPlugin\";\n\nclass InnerGraphPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      const logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n      compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template());\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {JavascriptParserOptions} parserOptions options\n       * @returns {void}\n       */\n\n      const handler = (parser, parserOptions) => {\n        const onUsageSuper = sup => {\n          InnerGraph.onUsage(parser.state, usedByExports => {\n            switch (usedByExports) {\n              case undefined:\n              case true:\n                return;\n\n              default:\n                {\n                  const dep = new PureExpressionDependency(sup.range);\n                  dep.loc = sup.loc;\n                  dep.usedByExports = usedByExports;\n                  parser.state.module.addDependency(dep);\n                  break;\n                }\n            }\n          });\n        };\n\n        parser.hooks.program.tap(PLUGIN_NAME, () => {\n          InnerGraph.enable(parser.state);\n        });\n        parser.hooks.finish.tap(PLUGIN_NAME, () => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          logger.time(\"infer dependency usage\");\n          InnerGraph.inferDependencyUsage(parser.state);\n          logger.timeAggregate(\"infer dependency usage\");\n        }); // During prewalking the following datastructures are filled with\n        // nodes that have a TopLevelSymbol assigned and\n        // variables are tagged with the assigned TopLevelSymbol\n        // We differ 3 types of nodes:\n        // 1. full statements (export default, function declaration)\n        // 2. classes (class declaration, class expression)\n        // 3. variable declarators (const x = ...)\n\n        /** @type {WeakMap<Node, TopLevelSymbol>} */\n\n        const statementWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<Node, Node>} */\n\n        const statementPurePart = new WeakMap();\n        /** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\n        const classWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\n        const declWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakSet<VariableDeclaratorNode>} */\n\n        const pureDeclarators = new WeakSet(); // The following hooks are used during prewalking:\n\n        parser.hooks.preStatement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"FunctionDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              statementWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n          }\n        });\n        parser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"ClassDeclaration\" && parser.isPure(statement, statement.range[0])) {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n\n            if (statement.type === \"ExportDefaultDeclaration\") {\n              const name = \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              const decl = statement.declaration;\n\n              if ((decl.type === \"ClassExpression\" || decl.type === \"ClassDeclaration\") && parser.isPure(decl, decl.range[0])) {\n                classWithTopLevelSymbol.set(decl, fn);\n              } else if (parser.isPure(decl, statement.range[0])) {\n                statementWithTopLevelSymbol.set(statement, fn);\n\n                if (!decl.type.endsWith(\"FunctionExpression\") && !decl.type.endsWith(\"Declaration\") && decl.type !== \"Literal\") {\n                  statementPurePart.set(statement, decl);\n                }\n              }\n            }\n          }\n        });\n        parser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true && decl.init && decl.id.type === \"Identifier\") {\n            const name = decl.id.name;\n\n            if (decl.init.type === \"ClassExpression\" && parser.isPure(decl.init, decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(decl.init, fn);\n            } else if (parser.isPure(decl.init, decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              declWithTopLevelSymbol.set(decl, fn);\n\n              if (!decl.init.type.endsWith(\"FunctionExpression\") && decl.init.type !== \"Literal\") {\n                pureDeclarators.add(decl);\n              }\n\n              return true;\n            }\n          }\n        }); // During real walking we set the TopLevelSymbol state to the assigned\n        // TopLevelSymbol by using the fill datastructures.\n        // In addition to tracking TopLevelSymbols, we sometimes need to\n        // add a PureExpressionDependency. This is needed to skip execution\n        // of pure expressions, even when they are not dropped due to\n        // minimizing. Otherwise symbols used there might not exist anymore\n        // as they are removed as unused by this optimization\n        // When we find a reference to a TopLevelSymbol, we register a\n        // TopLevelSymbol dependency from TopLevelSymbol in state to the\n        // referenced TopLevelSymbol. This way we get a graph of all\n        // TopLevelSymbols.\n        // The following hooks are called during walking:\n\n        parser.hooks.statement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            const fn = statementWithTopLevelSymbol.get(statement);\n\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              const purePart = statementPurePart.get(statement);\n\n              if (purePart) {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(purePart.range);\n                        dep.loc = statement.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n          }\n        });\n        parser.hooks.classExtendsExpression.tap(PLUGIN_NAME, (expr, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(statement);\n\n            if (fn && parser.isPure(expr, statement.id ? statement.id.range[1] : statement.range[0])) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              onUsageSuper(expr);\n            }\n          }\n        });\n        parser.hooks.classBodyElement.tap(PLUGIN_NAME, (element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            }\n          }\n        });\n        parser.hooks.classBodyValue.tap(PLUGIN_NAME, (expression, element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n\n            if (fn) {\n              if (!element.static || parser.isPure(expression, element.key ? element.key.range[1] : element.range[0])) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n\n                if (element.type !== \"MethodDefinition\" && element.static) {\n                  InnerGraph.onUsage(parser.state, usedByExports => {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n\n                      default:\n                        {\n                          const dep = new PureExpressionDependency(expression.range);\n                          dep.loc = expression.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              } else {\n                InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              }\n            }\n          }\n        });\n        parser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          const fn = declWithTopLevelSymbol.get(decl);\n\n          if (fn) {\n            InnerGraph.setTopLevelSymbol(parser.state, fn);\n\n            if (pureDeclarators.has(decl)) {\n              if (decl.init.type === \"ClassExpression\") {\n                if (decl.init.superClass) {\n                  onUsageSuper(decl.init.superClass);\n                }\n              } else {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(decl.init.range);\n                        dep.loc = decl.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n\n            parser.walkExpression(decl.init);\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            return true;\n          }\n        });\n        parser.hooks.expression.for(topLevelSymbolTag).tap(PLUGIN_NAME, () => {\n          const topLevelSymbol =\n          /** @type {TopLevelSymbol} */\n          parser.currentTagData;\n          const currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);\n          InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || true);\n        });\n        parser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (expr.operator === \"=\") return true;\n        });\n      };\n\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n      compilation.hooks.finishModules.tap(PLUGIN_NAME, () => {\n        logger.timeAggregateEnd(\"infer dependency usage\");\n      });\n    });\n  }\n\n}\n\nmodule.exports = InnerGraphPlugin;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/optimize/InnerGraphPlugin.js"],"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","require","PureExpressionDependency","InnerGraph","topLevelSymbolTag","PLUGIN_NAME","InnerGraphPlugin","apply","compiler","hooks","compilation","tap","normalModuleFactory","logger","getLogger","dependencyTemplates","set","Template","handler","parser","parserOptions","onUsageSuper","sup","onUsage","state","usedByExports","undefined","dep","range","loc","module","addDependency","program","enable","finish","isEnabled","time","inferDependencyUsage","timeAggregate","statementWithTopLevelSymbol","WeakMap","statementPurePart","classWithTopLevelSymbol","declWithTopLevelSymbol","pureDeclarators","WeakSet","preStatement","statement","scope","topLevelScope","type","name","id","fn","tagTopLevelSymbol","blockPreStatement","isPure","decl","declaration","endsWith","preDeclarator","init","add","setTopLevelSymbol","get","purePart","classExtendsExpression","expr","classBodyElement","element","classDefinition","classBodyValue","expression","static","key","declarator","has","superClass","walkExpression","for","topLevelSymbol","currentTagData","currentTopLevelSymbol","getTopLevelSymbol","addUsage","assign","operator","finishModules","timeAggregateEnd","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst { topLevelSymbolTag } = InnerGraph;\n\nconst PLUGIN_NAME = \"InnerGraphPlugin\";\n\nclass InnerGraphPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tPureExpressionDependency,\n\t\t\t\t\tnew PureExpressionDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {JavascriptParserOptions} parserOptions options\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tconst onUsageSuper = sup => {\n\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(sup.range);\n\t\t\t\t\t\t\t\t\tdep.loc = sup.loc;\n\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tparser.hooks.program.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tInnerGraph.enable(parser.state);\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.finish.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tlogger.time(\"infer dependency usage\");\n\t\t\t\t\t\tInnerGraph.inferDependencyUsage(parser.state);\n\t\t\t\t\t\tlogger.timeAggregate(\"infer dependency usage\");\n\t\t\t\t\t});\n\n\t\t\t\t\t// During prewalking the following datastructures are filled with\n\t\t\t\t\t// nodes that have a TopLevelSymbol assigned and\n\t\t\t\t\t// variables are tagged with the assigned TopLevelSymbol\n\n\t\t\t\t\t// We differ 3 types of nodes:\n\t\t\t\t\t// 1. full statements (export default, function declaration)\n\t\t\t\t\t// 2. classes (class declaration, class expression)\n\t\t\t\t\t// 3. variable declarators (const x = ...)\n\n\t\t\t\t\t/** @type {WeakMap<Node, TopLevelSymbol>} */\n\t\t\t\t\tconst statementWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakMap<Node, Node>} */\n\t\t\t\t\tconst statementPurePart = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\t\t\t\t\tconst classWithTopLevelSymbol = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\t\t\t\t\tconst declWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakSet<VariableDeclaratorNode>} */\n\t\t\t\t\tconst pureDeclarators = new WeakSet();\n\n\t\t\t\t\t// The following hooks are used during prewalking:\n\n\t\t\t\t\tparser.hooks.preStatement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"FunctionDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tstatement.type === \"ClassDeclaration\" &&\n\t\t\t\t\t\t\t\tparser.isPure(statement, statement.range[0])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (statement.type === \"ExportDefaultDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tconst decl = statement.declaration;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t(decl.type === \"ClassExpression\" ||\n\t\t\t\t\t\t\t\t\t\tdecl.type === \"ClassDeclaration\") &&\n\t\t\t\t\t\t\t\t\tparser.isPure(decl, decl.range[0])\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl, statement.range[0])) {\n\t\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"Declaration\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tstatementPurePart.set(statement, decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tparser.scope.topLevelScope === true &&\n\t\t\t\t\t\t\tdecl.init &&\n\t\t\t\t\t\t\tdecl.id.type === \"Identifier\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst name = decl.id.name;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdecl.init.type === \"ClassExpression\" &&\n\t\t\t\t\t\t\t\tparser.isPure(decl.init, decl.id.range[1])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl.init, fn);\n\t\t\t\t\t\t\t} else if (parser.isPure(decl.init, decl.id.range[1])) {\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tdeclWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!decl.init.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\tdecl.init.type !== \"Literal\"\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tpureDeclarators.add(decl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// During real walking we set the TopLevelSymbol state to the assigned\n\t\t\t\t\t// TopLevelSymbol by using the fill datastructures.\n\n\t\t\t\t\t// In addition to tracking TopLevelSymbols, we sometimes need to\n\t\t\t\t\t// add a PureExpressionDependency. This is needed to skip execution\n\t\t\t\t\t// of pure expressions, even when they are not dropped due to\n\t\t\t\t\t// minimizing. Otherwise symbols used there might not exist anymore\n\t\t\t\t\t// as they are removed as unused by this optimization\n\n\t\t\t\t\t// When we find a reference to a TopLevelSymbol, we register a\n\t\t\t\t\t// TopLevelSymbol dependency from TopLevelSymbol in state to the\n\t\t\t\t\t// referenced TopLevelSymbol. This way we get a graph of all\n\t\t\t\t\t// TopLevelSymbols.\n\n\t\t\t\t\t// The following hooks are called during walking:\n\n\t\t\t\t\tparser.hooks.statement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\n\t\t\t\t\t\t\tconst fn = statementWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\tconst purePart = statementPurePart.get(statement);\n\t\t\t\t\t\t\t\tif (purePart) {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tpurePart.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.classExtendsExpression.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(expr, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tfn &&\n\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tstatement.id ? statement.id.range[1] : statement.range[0]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\tonUsageSuper(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyElement.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyValue.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(expression, element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!element.static ||\n\t\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\t\t\t\telement.key ? element.key.range[1] : element.range[0]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\t\tif (element.type !== \"MethodDefinition\" && element.static) {\n\t\t\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpression.range\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tconst fn = declWithTopLevelSymbol.get(decl);\n\n\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\tif (pureDeclarators.has(decl)) {\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tif (decl.init.superClass) {\n\t\t\t\t\t\t\t\t\t\tonUsageSuper(decl.init.superClass);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdecl.init.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = decl.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\tconst topLevelSymbol = /** @type {TopLevelSymbol} */ (\n\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(\n\t\t\t\t\t\t\t\tparser.state\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tInnerGraph.addUsage(\n\t\t\t\t\t\t\t\tparser.state,\n\t\t\t\t\t\t\t\ttopLevelSymbol,\n\t\t\t\t\t\t\t\tcurrentTopLevelSymbol || true\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (expr.operator === \"=\") return true;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\n\t\t\t\tcompilation.hooks.finishModules.tap(PLUGIN_NAME, () => {\n\t\t\t\t\tlogger.timeAggregateEnd(\"infer dependency usage\");\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = InnerGraphPlugin;\n"]},"metadata":{},"sourceType":"script"}