{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000; // We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\n\n/** @type {Object<string, Map<string, string>>} */\n\nconst digestCaches = {};\n/** @typedef {function(): Hash} HashFactory */\n\nclass BulkUpdateDecorator extends Hash {\n  /**\n   * @param {Hash | HashFactory} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    super();\n    this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n\n    this.buffer = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n      if (this.hash === undefined) this.hash =\n      /** @type {HashFactory} */\n      this.hashFactory();\n\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) this.hash =\n        /** @type {HashFactory} */\n        this.hashFactory();\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    let digestCache;\n    const buffer = this.buffer;\n\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n      digestCache = digestCaches[cacheKey];\n\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n\n      const cacheEntry = digestCache.get(buffer);\n      if (cacheEntry !== undefined) return cacheEntry;\n      this.hash =\n      /** @type {HashFactory} */\n      this.hashFactory();\n    }\n\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n\n    const digestResult = this.hash.digest(encoding);\n    const result = typeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, result);\n    }\n\n    return result;\n  }\n\n}\n/* istanbul ignore next */\n\n\nclass DebugHash extends Hash {\n  constructor() {\n    super();\n    this.string = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (typeof data !== \"string\") data = data.toString(\"utf-8\");\n    const prefix = Buffer.from(\"@webpack-debug-digest@\").toString(\"hex\");\n\n    if (data.startsWith(prefix)) {\n      data = Buffer.from(data.slice(prefix.length), \"hex\").toString();\n    }\n\n    this.string += `[${data}](${\n    /** @type {string} */\n    new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    return Buffer.from(\"@webpack-debug-digest@\" + this.string).toString(\"hex\");\n  }\n\n}\n/** @type {typeof import(\"crypto\") | undefined} */\n\n\nlet crypto = undefined;\n/** @type {typeof import(\"./hash/xxhash64\") | undefined} */\n\nlet createXXHash64 = undefined;\n/** @type {typeof import(\"./hash/md4\") | undefined} */\n\nlet createMd4 = undefined;\n/** @type {typeof import(\"./hash/BatchedHash\") | undefined} */\n\nlet BatchedHash = undefined;\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash | undefined} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\n\nmodule.exports = algorithm => {\n  if (typeof algorithm === \"function\") {\n    return new BulkUpdateDecorator(() => new algorithm());\n  }\n\n  switch (algorithm) {\n    // TODO add non-cryptographic algorithm here\n    case \"debug\":\n      return new DebugHash();\n\n    case \"xxhash64\":\n      if (createXXHash64 === undefined) {\n        createXXHash64 = require(\"./hash/xxhash64\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new\n      /** @type {typeof import(\"./hash/BatchedHash\")} */\n      BatchedHash(createXXHash64());\n\n    case \"md4\":\n      if (createMd4 === undefined) {\n        createMd4 = require(\"./hash/md4\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new\n      /** @type {typeof import(\"./hash/BatchedHash\")} */\n      BatchedHash(createMd4());\n\n    case \"native-md4\":\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() =>\n      /** @type {typeof import(\"crypto\")} */\n      crypto.createHash(\"md4\"), \"md4\");\n\n    default:\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() =>\n      /** @type {typeof import(\"crypto\")} */\n      crypto.createHash(\n      /** @type {string} */\n      algorithm), algorithm);\n  }\n};","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/util/createHash.js"],"names":["Hash","require","BULK_SIZE","digestCaches","BulkUpdateDecorator","constructor","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","update","data","inputEncoding","length","digest","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","result","toString","set","DebugHash","string","prefix","Buffer","from","startsWith","slice","Error","stack","split","crypto","createXXHash64","createMd4","BatchedHash","module","exports","algorithm","createHash"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\n/** @type {Object<string, Map<string, string>>} */\nconst digestCaches = {};\n\n/** @typedef {function(): Hash} HashFactory */\n\nclass BulkUpdateDecorator extends Hash {\n\t/**\n\t * @param {Hash | HashFactory} hashOrFactory function to create a hash\n\t * @param {string=} hashKey key for caching\n\t */\n\tconstructor(hashOrFactory, hashKey) {\n\t\tsuper();\n\t\tthis.hashKey = hashKey;\n\t\tif (typeof hashOrFactory === \"function\") {\n\t\t\tthis.hashFactory = hashOrFactory;\n\t\t\tthis.hash = undefined;\n\t\t} else {\n\t\t\tthis.hashFactory = undefined;\n\t\t\tthis.hash = hashOrFactory;\n\t\t}\n\t\tthis.buffer = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (\n\t\t\tinputEncoding !== undefined ||\n\t\t\ttypeof data !== \"string\" ||\n\t\t\tdata.length > BULK_SIZE\n\t\t) {\n\t\t\tif (this.hash === undefined)\n\t\t\t\tthis.hash = /** @type {HashFactory} */ (this.hashFactory)();\n\t\t\tif (this.buffer.length > 0) {\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t\tthis.hash.update(data, inputEncoding);\n\t\t} else {\n\t\t\tthis.buffer += data;\n\t\t\tif (this.buffer.length > BULK_SIZE) {\n\t\t\t\tif (this.hash === undefined)\n\t\t\t\t\tthis.hash = /** @type {HashFactory} */ (this.hashFactory)();\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\tlet digestCache;\n\t\tconst buffer = this.buffer;\n\t\tif (this.hash === undefined) {\n\t\t\t// short data for hash, we can use caching\n\t\t\tconst cacheKey = `${this.hashKey}-${encoding}`;\n\t\t\tdigestCache = digestCaches[cacheKey];\n\t\t\tif (digestCache === undefined) {\n\t\t\t\tdigestCache = digestCaches[cacheKey] = new Map();\n\t\t\t}\n\t\t\tconst cacheEntry = digestCache.get(buffer);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tthis.hash = /** @type {HashFactory} */ (this.hashFactory)();\n\t\t}\n\t\tif (buffer.length > 0) {\n\t\t\tthis.hash.update(buffer);\n\t\t}\n\t\tconst digestResult = this.hash.digest(encoding);\n\t\tconst result =\n\t\t\ttypeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\t\tif (digestCache !== undefined) {\n\t\t\tdigestCache.set(buffer, result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/* istanbul ignore next */\nclass DebugHash extends Hash {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.string = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\t\tconst prefix = Buffer.from(\"@webpack-debug-digest@\").toString(\"hex\");\n\t\tif (data.startsWith(prefix)) {\n\t\t\tdata = Buffer.from(data.slice(prefix.length), \"hex\").toString();\n\t\t}\n\t\tthis.string += `[${data}](${\n\t\t\t/** @type {string} */ (new Error().stack).split(\"\\n\", 3)[2]\n\t\t})\\n`;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\treturn Buffer.from(\"@webpack-debug-digest@\" + this.string).toString(\"hex\");\n\t}\n}\n\n/** @type {typeof import(\"crypto\") | undefined} */\nlet crypto = undefined;\n/** @type {typeof import(\"./hash/xxhash64\") | undefined} */\nlet createXXHash64 = undefined;\n/** @type {typeof import(\"./hash/md4\") | undefined} */\nlet createMd4 = undefined;\n/** @type {typeof import(\"./hash/BatchedHash\") | undefined} */\nlet BatchedHash = undefined;\n\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash | undefined} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\nmodule.exports = algorithm => {\n\tif (typeof algorithm === \"function\") {\n\t\treturn new BulkUpdateDecorator(() => new algorithm());\n\t}\n\tswitch (algorithm) {\n\t\t// TODO add non-cryptographic algorithm here\n\t\tcase \"debug\":\n\t\t\treturn new DebugHash();\n\t\tcase \"xxhash64\":\n\t\t\tif (createXXHash64 === undefined) {\n\t\t\t\tcreateXXHash64 = require(\"./hash/xxhash64\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new /** @type {typeof import(\"./hash/BatchedHash\")} */ (\n\t\t\t\tBatchedHash\n\t\t\t)(createXXHash64());\n\t\tcase \"md4\":\n\t\t\tif (createMd4 === undefined) {\n\t\t\t\tcreateMd4 = require(\"./hash/md4\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new /** @type {typeof import(\"./hash/BatchedHash\")} */ (\n\t\t\t\tBatchedHash\n\t\t\t)(createMd4());\n\t\tcase \"native-md4\":\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(\n\t\t\t\t() => /** @type {typeof import(\"crypto\")} */ (crypto).createHash(\"md4\"),\n\t\t\t\t\"md4\"\n\t\t\t);\n\t\tdefault:\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(\n\t\t\t\t() =>\n\t\t\t\t\t/** @type {typeof import(\"crypto\")} */ (crypto).createHash(\n\t\t\t\t\t\t/** @type {string} */ (algorithm)\n\t\t\t\t\t),\n\t\t\t\talgorithm\n\t\t\t);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}