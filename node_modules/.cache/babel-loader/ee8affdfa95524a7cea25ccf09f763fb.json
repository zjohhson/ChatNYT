{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar _ChatCompletionStream_instances, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_addChunk, _ChatCompletionStream_endRequest, _ChatCompletionStream_accumulateChatCompletion;\n\nimport { OpenAIError, APIUserAbortError } from 'openai/error';\nimport { AbstractChatCompletionRunner } from \"./AbstractChatCompletionRunner.mjs\";\nimport { Stream } from 'openai/streaming';\nexport class ChatCompletionStream extends AbstractChatCompletionRunner {\n  constructor() {\n    super(...arguments);\n\n    _ChatCompletionStream_instances.add(this);\n\n    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n  }\n\n  get currentChatCompletionSnapshot() {\n    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n\n\n  static fromReadableStream(stream) {\n    const runner = new ChatCompletionStream();\n\n    runner._run(() => runner._fromReadableStream(stream));\n\n    return runner;\n  }\n\n  static createChatCompletion(completions, params, options) {\n    const runner = new ChatCompletionStream();\n\n    runner._run(() => runner._runChatCompletion(completions, { ...params,\n      stream: true\n    }, options));\n\n    return runner;\n  }\n\n  async _createChatCompletion(completions, params, options) {\n    const signal = options?.signal;\n\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n\n    const stream = await completions.create({ ...params,\n      stream: true\n    }, { ...options,\n      signal: this.controller.signal\n    });\n\n    this._connected();\n\n    for await (const chunk of stream) {\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n    }\n\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n\n  async _fromReadableStream(readableStream, options) {\n    const signal = options?.signal;\n\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n\n    this._connected();\n\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    let chatId;\n\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n      }\n\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n\n      chatId = chunk.id;\n    }\n\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n\n  [(_ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n    if (this.ended) return;\n\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n    if (this.ended) return;\n\n    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n\n    this._emit('chunk', chunk, completion);\n\n    const delta = chunk.choices[0]?.delta?.content;\n    const snapshot = completion.choices[0]?.message;\n\n    if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n\n    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n\n    return finalizeChatCompletion(snapshot);\n  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n    var _a, _b;\n\n    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n\n    const {\n      choices,\n      ...rest\n    } = chunk;\n\n    if (!snapshot) {\n      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, { ...rest,\n        choices: []\n      }, \"f\");\n    } else {\n      Object.assign(snapshot, rest);\n    }\n\n    for (const {\n      delta,\n      finish_reason,\n      index,\n      ...other\n    } of chunk.choices) {\n      let choice = snapshot.choices[index];\n\n      if (!choice) {\n        snapshot.choices[index] = {\n          finish_reason,\n          index,\n          message: delta,\n          ...other\n        };\n        continue;\n      }\n\n      if (finish_reason) choice.finish_reason = finish_reason;\n      Object.assign(choice, other);\n      if (!delta) continue; // Shouldn't happen; just in case.\n\n      const {\n        content,\n        function_call,\n        role,\n        tool_calls\n      } = delta;\n      if (content) choice.message.content = (choice.message.content || '') + content;\n      if (role) choice.message.role = role;\n\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n\n          if (function_call.arguments) {\n            (_a = choice.message.function_call).arguments ?? (_a.arguments = '');\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n\n        for (const {\n          index,\n          id,\n          type,\n          function: fn\n        } of tool_calls) {\n          const tool_call = (_b = choice.message.tool_calls)[index] ?? (_b[index] = {});\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ?? (tool_call.function = {\n            arguments: ''\n          });\n          if (fn?.name) tool_call.function.name = fn.name;\n          if (fn?.arguments) tool_call.function.arguments += fn.arguments;\n        }\n      }\n    }\n\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('chunk', chunk => {\n      const reader = readQueue.shift();\n\n      if (reader) {\n        reader(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n\n      for (const reader of readQueue) {\n        reader(undefined);\n      }\n\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n\n          return new Promise(resolve => readQueue.push(resolve)).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      }\n    };\n  }\n\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n\n}\n\nfunction finalizeChatCompletion(snapshot) {\n  const {\n    id,\n    choices,\n    created,\n    model\n  } = snapshot;\n  return {\n    id,\n    choices: choices.map(_ref => {\n      let {\n        message,\n        finish_reason,\n        index\n      } = _ref;\n      if (!finish_reason) throw new OpenAIError(`missing finish_reason for choice ${index}`);\n      const {\n        content = null,\n        function_call,\n        tool_calls\n      } = message;\n      const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n\n      if (!role) throw new OpenAIError(`missing role for choice ${index}`);\n\n      if (function_call) {\n        const {\n          arguments: args,\n          name\n        } = function_call;\n        if (args == null) throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n        if (!name) throw new OpenAIError(`missing function_call.name for choice ${index}`);\n        return {\n          message: {\n            content,\n            function_call: {\n              arguments: args,\n              name\n            },\n            role\n          },\n          finish_reason,\n          index\n        };\n      }\n\n      if (tool_calls) {\n        return {\n          index,\n          finish_reason,\n          message: {\n            role,\n            content,\n            tool_calls: tool_calls.map((tool_call, i) => {\n              const {\n                function: fn,\n                type,\n                id\n              } = tool_call;\n              const {\n                arguments: args,\n                name\n              } = fn || {};\n              if (id == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n              if (type == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n              if (name == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n              if (args == null) throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n              return {\n                id,\n                type,\n                function: {\n                  name,\n                  arguments: args\n                }\n              };\n            })\n          }\n        };\n      }\n\n      return {\n        message: {\n          content: content,\n          role\n        },\n        finish_reason,\n        index\n      };\n    }),\n    created,\n    model,\n    object: 'chat.completion'\n  };\n}\n\nfunction str(x) {\n  return JSON.stringify(x);\n}","map":{"version":3,"mappings":"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","names":["OpenAIError","APIUserAbortError","AbstractChatCompletionRunner","Stream","ChatCompletionStream","constructor","_ChatCompletionStream_currentChatCompletionSnapshot","currentChatCompletionSnapshot","__classPrivateFieldGet","fromReadableStream","stream","runner","_run","_fromReadableStream","createChatCompletion","completions","params","options","_runChatCompletion","_createChatCompletion","signal","aborted","controller","abort","addEventListener","_ChatCompletionStream_instances","_ChatCompletionStream_beginRequest","call","create","_connected","chunk","_ChatCompletionStream_addChunk","_addChatCompletion","_ChatCompletionStream_endRequest","readableStream","chatId","id","ended","__classPrivateFieldSet","undefined","completion","_ChatCompletionStream_accumulateChatCompletion","_emit","delta","choices","content","snapshot","message","role","finalizeChatCompletion","rest","Object","assign","finish_reason","index","other","choice","function_call","tool_calls","name","arguments","_a","type","function","fn","tool_call","_b","Symbol","asyncIterator","pushQueue","readQueue","done","on","reader","shift","push","length","next","value","Promise","resolve","then","toReadableStream","bind","created","model","map","args","i","str","object","x","JSON","stringify"],"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/openai/src/lib/ChatCompletionStream.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { OpenAIError, APIUserAbortError } from \"../error\";\nimport {\n  Completions,\n  type ChatCompletion,\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParams,\n  type ChatCompletionCreateParamsBase,\n} from \"../resources/chat/completions\";\nimport {\n  AbstractChatCompletionRunner,\n  type AbstractChatCompletionRunnerEvents,\n} from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\n\nexport interface ChatCompletionStreamEvents extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n}\n\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport class ChatCompletionStream\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\n\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\n    return this.#currentChatCompletionSnapshot;\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionStreamParams,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, options));\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentChatCompletionSnapshot = undefined;\n  }\n  #addChunk(chunk: ChatCompletionChunk) {\n    if (this.ended) return;\n    const completion = this.#accumulateChatCompletion(chunk);\n    this._emit('chunk', chunk, completion);\n    const delta = chunk.choices[0]?.delta?.content;\n    const snapshot = completion.choices[0]?.message;\n    if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }\n  #endRequest(): ChatCompletion {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    this.#currentChatCompletionSnapshot = undefined;\n    return finalizeChatCompletion(snapshot);\n  }\n\n  protected override async _createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await completions.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const chunk of stream) {\n      this.#addChunk(chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(this.#endRequest());\n      }\n\n      this.#addChunk(chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\n    let snapshot = this.#currentChatCompletionSnapshot;\n    const { choices, ...rest } = chunk;\n    if (!snapshot) {\n      snapshot = this.#currentChatCompletionSnapshot = {\n        ...rest,\n        choices: [],\n      };\n    } else {\n      Object.assign(snapshot, rest);\n    }\n\n    for (const { delta, finish_reason, index, ...other } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        snapshot.choices[index] = { finish_reason, index, message: delta, ...other };\n        continue;\n      }\n\n      if (finish_reason) choice.finish_reason = finish_reason;\n      Object.assign(choice, other);\n\n      if (!delta) continue; // Shouldn't happen; just in case.\n      const { content, function_call, role, tool_calls } = delta;\n\n      if (content) choice.message.content = (choice.message.content || '') + content;\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            choice.message.function_call.arguments ??= '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n        for (const { index, id, type, function: fn } of tool_calls) {\n          const tool_call = (choice.message.tool_calls[index] ??= {});\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ??= { arguments: '' };\n          if (fn?.name) tool_call.function!.name = fn.name;\n          if (fn?.arguments) tool_call.function!.arguments += fn.arguments;\n        }\n      }\n    }\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<ChatCompletionChunk> {\n    const pushQueue: ChatCompletionChunk[] = [];\n    const readQueue: ((chunk: ChatCompletionChunk | undefined) => void)[] = [];\n    let done = false;\n\n    this.on('chunk', (chunk) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ChatCompletionChunk | undefined>((resolve) => readQueue.push(resolve)).then(\n            (chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }),\n          );\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\nfunction finalizeChatCompletion(snapshot: ChatCompletionSnapshot): ChatCompletion {\n  const { id, choices, created, model } = snapshot;\n  return {\n    id,\n    choices: choices.map(({ message, finish_reason, index }): ChatCompletion.Choice => {\n      if (!finish_reason) throw new OpenAIError(`missing finish_reason for choice ${index}`);\n      const { content = null, function_call, tool_calls } = message;\n      const role = message.role as 'assistant'; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n      if (!role) throw new OpenAIError(`missing role for choice ${index}`);\n      if (function_call) {\n        const { arguments: args, name } = function_call;\n        if (args == null) throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n        if (!name) throw new OpenAIError(`missing function_call.name for choice ${index}`);\n        return { message: { content, function_call: { arguments: args, name }, role }, finish_reason, index };\n      }\n      if (tool_calls) {\n        return {\n          index,\n          finish_reason,\n          message: {\n            role,\n            content,\n            tool_calls: tool_calls.map((tool_call, i) => {\n              const { function: fn, type, id } = tool_call;\n              const { arguments: args, name } = fn || {};\n              if (id == null)\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n              if (type == null)\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n              if (name == null)\n                throw new OpenAIError(\n                  `missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`,\n                );\n              if (args == null)\n                throw new OpenAIError(\n                  `missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`,\n                );\n\n              return { id, type, function: { name, arguments: args } };\n            }),\n          },\n        };\n      }\n      return { message: { content: content, role }, finish_reason, index };\n    }),\n    created,\n    model,\n    object: 'chat.completion',\n  };\n}\n\nfunction str(x: unknown) {\n  return JSON.stringify(x);\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionSnapshot {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletionSnapshot.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n}\n\nexport namespace ChatCompletionSnapshot {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    message: Choice.Message;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, or `function_call`\n     * if the model called a function.\n     */\n    finish_reason: ChatCompletion.Choice['finish_reason'] | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Message {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      function_call?: Message.FunctionCall;\n\n      tool_calls?: Array<Message.ToolCall>;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'function' | 'tool';\n    }\n\n    export namespace Message {\n      export interface ToolCall {\n        /**\n         * The ID of the tool call.\n         */\n        id?: string;\n\n        function?: ToolCall.Function;\n\n        /**\n         * The type of the tool.\n         */\n        type?: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments?: string;\n\n          /**\n           * The name of the function to call.\n           */\n          name?: string;\n        }\n      }\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}