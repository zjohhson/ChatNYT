{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC\n} = require(\"./ModuleTypeConstants\");\n\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\n\nconst WebpackError = require(\"./WebpackError\");\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\n\nconst {\n  evaluateToString,\n  toConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\n\nconst createHash = require(\"./util/createHash\");\n/** @typedef {import(\"estree\").Expression} Expression */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {Object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\n\nclass RuntimeValue {\n  /**\n   * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   */\n  constructor(fn, options) {\n    this.fn = fn;\n\n    if (Array.isArray(options)) {\n      options = {\n        fileDependencies: options\n      };\n    }\n\n    this.options = options || {};\n  }\n\n  get fileDependencies() {\n    return this.options === true ? true : this.options.fileDependencies;\n  }\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n   * @param {string} key the defined key\n   * @returns {CodeValuePrimitive} code\n   */\n\n\n  exec(parser, valueCacheVersions, key) {\n    const buildInfo = parser.state.module.buildInfo;\n\n    if (this.options === true) {\n      buildInfo.cacheable = false;\n    } else {\n      if (this.options.fileDependencies) {\n        for (const dep of this.options.fileDependencies) {\n          buildInfo.fileDependencies.add(dep);\n        }\n      }\n\n      if (this.options.contextDependencies) {\n        for (const dep of this.options.contextDependencies) {\n          buildInfo.contextDependencies.add(dep);\n        }\n      }\n\n      if (this.options.missingDependencies) {\n        for (const dep of this.options.missingDependencies) {\n          buildInfo.missingDependencies.add(dep);\n        }\n      }\n\n      if (this.options.buildDependencies) {\n        for (const dep of this.options.buildDependencies) {\n          buildInfo.buildDependencies.add(dep);\n        }\n      }\n    }\n\n    return this.fn({\n      module: parser.state.module,\n      key,\n\n      get version() {\n        return (\n          /** @type {string} */\n          valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n        );\n      }\n\n    });\n  }\n\n  getCacheVersion() {\n    return this.options === true ? undefined : (typeof this.options.version === \"function\" ? this.options.version() : this.options.version) || \"unset\";\n  }\n\n}\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {Set<string>|undefined=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\n\n\nconst stringifyObj = (obj, parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe, objKeys) => {\n  let code;\n  let arr = Array.isArray(obj);\n\n  if (arr) {\n    code = `[${obj.map(code => toCode(code, parser, valueCacheVersions, key, runtimeTemplate, logger, null)).join(\",\")}]`;\n  } else {\n    let keys = Object.keys(obj);\n\n    if (objKeys) {\n      if (objKeys.size === 0) keys = [];else keys = keys.filter(k => objKeys.has(k));\n    }\n\n    code = `{${keys.map(key => {\n      const code = obj[key];\n      return JSON.stringify(key) + \":\" + toCode(code, parser, valueCacheVersions, key, runtimeTemplate, logger, null);\n    }).join(\",\")}}`;\n  }\n\n  switch (asiSafe) {\n    case null:\n      return code;\n\n    case true:\n      return arr ? code : `(${code})`;\n\n    case false:\n      return arr ? `;${code}` : `;(${code})`;\n\n    default:\n      return `/*#__PURE__*/Object(${code})`;\n  }\n};\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {Set<string>|undefined=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\n\n\nconst toCode = (code, parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe, objKeys) => {\n  const transformToCode = () => {\n    if (code === null) {\n      return \"null\";\n    }\n\n    if (code === undefined) {\n      return \"undefined\";\n    }\n\n    if (Object.is(code, -0)) {\n      return \"-0\";\n    }\n\n    if (code instanceof RuntimeValue) {\n      return toCode(code.exec(parser, valueCacheVersions, key), parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe);\n    }\n\n    if (code instanceof RegExp && code.toString) {\n      return code.toString();\n    }\n\n    if (typeof code === \"function\" && code.toString) {\n      return \"(\" + code.toString() + \")\";\n    }\n\n    if (typeof code === \"object\") {\n      return stringifyObj(code, parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe, objKeys);\n    }\n\n    if (typeof code === \"bigint\") {\n      return runtimeTemplate.supportsBigIntLiteral() ? `${code}n` : `BigInt(\"${code}\")`;\n    }\n\n    return code + \"\";\n  };\n\n  const strCode = transformToCode();\n  logger.log(`Replaced \"${key}\" with \"${strCode}\"`);\n  return strCode;\n};\n\nconst toCacheVersion = code => {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (Object.is(code, -0)) {\n    return \"-0\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return code.getCacheVersion();\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    const items = Object.keys(code).map(key => ({\n      key,\n      value: toCacheVersion(code[key])\n    }));\n    if (items.some(_ref => {\n      let {\n        value\n      } = _ref;\n      return value === undefined;\n    })) return undefined;\n    return `{${items.map(_ref2 => {\n      let {\n        key,\n        value\n      } = _ref2;\n      return `${key}: ${value}`;\n    }).join(\", \")}}`;\n  }\n\n  if (typeof code === \"bigint\") {\n    return `${code}n`;\n  }\n\n  return code + \"\";\n};\n\nconst PLUGIN_NAME = \"DefinePlugin\";\nconst VALUE_DEP_PREFIX = `webpack/${PLUGIN_NAME} `;\nconst VALUE_DEP_MAIN = `webpack/${PLUGIN_NAME}_hash`;\nconst TYPEOF_OPERATOR_REGEXP = /^typeof\\s+/;\nconst WEBPACK_REQUIRE_FUNCTION_REGEXP = /__webpack_require__\\s*(!?\\.)/;\nconst WEBPACK_REQUIRE_IDENTIFIER_REGEXP = /__webpack_require__/;\n\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n  /**\n   * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   * @returns {RuntimeValue} runtime value\n   */\n\n\n  static runtimeValue(fn, options) {\n    return new RuntimeValue(fn, options);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, _ref3) => {\n      let {\n        normalModuleFactory\n      } = _ref3;\n      const logger = compilation.getLogger(\"webpack.DefinePlugin\");\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      const {\n        runtimeTemplate\n      } = compilation;\n      const mainHash = createHash(compilation.outputOptions.hashFunction);\n      mainHash.update(\n      /** @type {string} */\n      compilation.valueCacheVersions.get(VALUE_DEP_MAIN) || \"\");\n      /**\n       * Handler\n       * @param {JavascriptParser} parser Parser\n       * @returns {void}\n       */\n\n      const handler = parser => {\n        const mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n        parser.hooks.program.tap(PLUGIN_NAME, () => {\n          const {\n            buildInfo\n          } = parser.state.module;\n          if (!buildInfo.valueDependencies) buildInfo.valueDependencies = new Map();\n          buildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n        });\n\n        const addValueDependency = key => {\n          const {\n            buildInfo\n          } = parser.state.module;\n          buildInfo.valueDependencies.set(VALUE_DEP_PREFIX + key, compilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key));\n        };\n\n        const withValueDependency = (key, fn) => function () {\n          addValueDependency(key);\n          return fn(...arguments);\n        };\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n\n\n        const walkDefinitions = (definitions, prefix) => {\n          Object.keys(definitions).forEach(key => {\n            const code = definitions[key];\n\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(code, prefix + key + \".\");\n              applyObjectDefine(prefix + key, code);\n              return;\n            }\n\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          });\n        };\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n\n\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          splittedKey.slice(1).forEach((_, i) => {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(PLUGIN_NAME, () => {\n              addValueDependency(key);\n              return true;\n            });\n          });\n        };\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n\n\n        const applyDefine = (key, code) => {\n          const originalKey = key;\n          const isTypeof = TYPEOF_OPERATOR_REGEXP.test(key);\n          if (isTypeof) key = key.replace(TYPEOF_OPERATOR_REGEXP, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n              addValueDependency(originalKey);\n              return true;\n            });\n            parser.hooks.evaluateIdentifier.for(key).tap(PLUGIN_NAME, expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              addValueDependency(originalKey);\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser, compilation.valueCacheVersions, key, runtimeTemplate, logger, null));\n              recurse = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n              addValueDependency(originalKey);\n              let strCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, logger, !parser.isAsiPosition(expr.range[0]), parser.destructuringAssignmentPropertiesFor(expr));\n\n              if (parser.scope.inShorthand) {\n                strCode = parser.scope.inShorthand + \":\" + strCode;\n              }\n\n              if (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n              } else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n              } else {\n                return toConstantDependency(parser, strCode)(expr);\n              }\n            });\n          }\n\n          parser.hooks.evaluateTypeof.for(key).tap(PLUGIN_NAME, expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            addValueDependency(originalKey);\n            const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, logger, null);\n            const typeofCode = isTypeof ? codeCode : \"typeof (\" + codeCode + \")\";\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(PLUGIN_NAME, expr => {\n            addValueDependency(originalKey);\n            const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, logger, null);\n            const typeofCode = isTypeof ? codeCode : \"typeof (\" + codeCode + \")\";\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {Object} obj Object\n         * @returns {void}\n         */\n\n\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n            addValueDependency(key);\n            return true;\n          });\n          parser.hooks.evaluateIdentifier.for(key).tap(PLUGIN_NAME, expr => {\n            addValueDependency(key);\n            return new BasicEvaluatedExpression().setTruthy().setSideEffects(false).setRange(expr.range);\n          });\n          parser.hooks.evaluateTypeof.for(key).tap(PLUGIN_NAME, withValueDependency(key, evaluateToString(\"object\")));\n          parser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n            addValueDependency(key);\n            let strCode = stringifyObj(obj, parser, compilation.valueCacheVersions, key, runtimeTemplate, logger, !parser.isAsiPosition(expr.range[0]), parser.destructuringAssignmentPropertiesFor(expr));\n\n            if (parser.scope.inShorthand) {\n              strCode = parser.scope.inShorthand + \":\" + strCode;\n            }\n\n            if (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n              return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n            } else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n              return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n            } else {\n              return toConstantDependency(parser, strCode)(expr);\n            }\n          });\n          parser.hooks.typeof.for(key).tap(PLUGIN_NAME, withValueDependency(key, toConstantDependency(parser, JSON.stringify(\"object\"))));\n        };\n\n        walkDefinitions(definitions, \"\");\n      };\n\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n      /**\n       * Walk definitions\n       * @param {Object} definitions Definitions map\n       * @param {string} prefix Prefix string\n       * @returns {void}\n       */\n\n      const walkDefinitionsForValues = (definitions, prefix) => {\n        Object.keys(definitions).forEach(key => {\n          const code = definitions[key];\n          const version = toCacheVersion(code);\n          const name = VALUE_DEP_PREFIX + prefix + key;\n          mainHash.update(\"|\" + prefix + key);\n          const oldVersion = compilation.valueCacheVersions.get(name);\n\n          if (oldVersion === undefined) {\n            compilation.valueCacheVersions.set(name, version);\n          } else if (oldVersion !== version) {\n            const warning = new WebpackError(`${PLUGIN_NAME}\\nConflicting values for '${prefix + key}'`);\n            warning.details = `'${oldVersion}' !== '${version}'`;\n            warning.hideStack = true;\n            compilation.warnings.push(warning);\n          }\n\n          if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n            walkDefinitionsForValues(code, prefix + key + \".\");\n          }\n        });\n      };\n\n      walkDefinitionsForValues(definitions, \"\");\n      compilation.valueCacheVersions.set(VALUE_DEP_MAIN,\n      /** @type {string} */\n      mainHash.digest(\"hex\").slice(0, 8));\n    });\n  }\n\n}\n\nmodule.exports = DefinePlugin;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/DefinePlugin.js"],"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","JAVASCRIPT_MODULE_TYPE_DYNAMIC","require","RuntimeGlobals","WebpackError","ConstDependency","BasicEvaluatedExpression","evaluateToString","toConstantDependency","createHash","RuntimeValue","constructor","fn","options","Array","isArray","fileDependencies","exec","parser","valueCacheVersions","key","buildInfo","state","module","cacheable","dep","add","contextDependencies","missingDependencies","buildDependencies","version","get","VALUE_DEP_PREFIX","getCacheVersion","undefined","stringifyObj","obj","runtimeTemplate","logger","asiSafe","objKeys","code","arr","map","toCode","join","keys","Object","size","filter","k","has","JSON","stringify","transformToCode","is","RegExp","toString","supportsBigIntLiteral","strCode","log","toCacheVersion","items","value","some","PLUGIN_NAME","VALUE_DEP_MAIN","TYPEOF_OPERATOR_REGEXP","WEBPACK_REQUIRE_FUNCTION_REGEXP","WEBPACK_REQUIRE_IDENTIFIER_REGEXP","DefinePlugin","definitions","runtimeValue","apply","compiler","hooks","compilation","tap","normalModuleFactory","getLogger","dependencyTemplates","set","Template","mainHash","outputOptions","hashFunction","update","handler","mainValue","program","valueDependencies","Map","addValueDependency","withValueDependency","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","originalKey","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","isAsiPosition","destructuringAssignmentPropertiesFor","scope","inShorthand","requireScope","evaluateTypeof","codeCode","typeofCode","typeof","isString","string","bind","setTruthy","setSideEffects","walkDefinitionsForValues","name","oldVersion","warning","details","hideStack","warnings","push","digest","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC\n} = require(\"./ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\n\nconst {\n\tevaluateToString,\n\ttoConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst createHash = require(\"./util/createHash\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {Object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\nclass RuntimeValue {\n\t/**\n\t * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t */\n\tconstructor(fn, options) {\n\t\tthis.fn = fn;\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = {\n\t\t\t\tfileDependencies: options\n\t\t\t};\n\t\t}\n\t\tthis.options = options || {};\n\t}\n\n\tget fileDependencies() {\n\t\treturn this.options === true ? true : this.options.fileDependencies;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n\t * @param {string} key the defined key\n\t * @returns {CodeValuePrimitive} code\n\t */\n\texec(parser, valueCacheVersions, key) {\n\t\tconst buildInfo = parser.state.module.buildInfo;\n\t\tif (this.options === true) {\n\t\t\tbuildInfo.cacheable = false;\n\t\t} else {\n\t\t\tif (this.options.fileDependencies) {\n\t\t\t\tfor (const dep of this.options.fileDependencies) {\n\t\t\t\t\tbuildInfo.fileDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.contextDependencies) {\n\t\t\t\tfor (const dep of this.options.contextDependencies) {\n\t\t\t\t\tbuildInfo.contextDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.missingDependencies) {\n\t\t\t\tfor (const dep of this.options.missingDependencies) {\n\t\t\t\t\tbuildInfo.missingDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.buildDependencies) {\n\t\t\t\tfor (const dep of this.options.buildDependencies) {\n\t\t\t\t\tbuildInfo.buildDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({\n\t\t\tmodule: parser.state.module,\n\t\t\tkey,\n\t\t\tget version() {\n\t\t\t\treturn /** @type {string} */ (\n\t\t\t\t\tvalueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetCacheVersion() {\n\t\treturn this.options === true\n\t\t\t? undefined\n\t\t\t: (typeof this.options.version === \"function\"\n\t\t\t\t\t? this.options.version()\n\t\t\t\t\t: this.options.version) || \"unset\";\n\t}\n}\n\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {Set<string>|undefined=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\nconst stringifyObj = (\n\tobj,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tlogger,\n\tasiSafe,\n\tobjKeys\n) => {\n\tlet code;\n\tlet arr = Array.isArray(obj);\n\tif (arr) {\n\t\tcode = `[${obj\n\t\t\t.map(code =>\n\t\t\t\ttoCode(\n\t\t\t\t\tcode,\n\t\t\t\t\tparser,\n\t\t\t\t\tvalueCacheVersions,\n\t\t\t\t\tkey,\n\t\t\t\t\truntimeTemplate,\n\t\t\t\t\tlogger,\n\t\t\t\t\tnull\n\t\t\t\t)\n\t\t\t)\n\t\t\t.join(\",\")}]`;\n\t} else {\n\t\tlet keys = Object.keys(obj);\n\t\tif (objKeys) {\n\t\t\tif (objKeys.size === 0) keys = [];\n\t\t\telse keys = keys.filter(k => objKeys.has(k));\n\t\t}\n\t\tcode = `{${keys\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn (\n\t\t\t\t\tJSON.stringify(key) +\n\t\t\t\t\t\":\" +\n\t\t\t\t\ttoCode(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tparser,\n\t\t\t\t\t\tvalueCacheVersions,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tnull\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.join(\",\")}}`;\n\t}\n\n\tswitch (asiSafe) {\n\t\tcase null:\n\t\t\treturn code;\n\t\tcase true:\n\t\t\treturn arr ? code : `(${code})`;\n\t\tcase false:\n\t\t\treturn arr ? `;${code}` : `;(${code})`;\n\t\tdefault:\n\t\t\treturn `/*#__PURE__*/Object(${code})`;\n\t}\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {Set<string>|undefined=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (\n\tcode,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tlogger,\n\tasiSafe,\n\tobjKeys\n) => {\n\tconst transformToCode = () => {\n\t\tif (code === null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (code === undefined) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tif (Object.is(code, -0)) {\n\t\t\treturn \"-0\";\n\t\t}\n\t\tif (code instanceof RuntimeValue) {\n\t\t\treturn toCode(\n\t\t\t\tcode.exec(parser, valueCacheVersions, key),\n\t\t\t\tparser,\n\t\t\t\tvalueCacheVersions,\n\t\t\t\tkey,\n\t\t\t\truntimeTemplate,\n\t\t\t\tlogger,\n\t\t\t\tasiSafe\n\t\t\t);\n\t\t}\n\t\tif (code instanceof RegExp && code.toString) {\n\t\t\treturn code.toString();\n\t\t}\n\t\tif (typeof code === \"function\" && code.toString) {\n\t\t\treturn \"(\" + code.toString() + \")\";\n\t\t}\n\t\tif (typeof code === \"object\") {\n\t\t\treturn stringifyObj(\n\t\t\t\tcode,\n\t\t\t\tparser,\n\t\t\t\tvalueCacheVersions,\n\t\t\t\tkey,\n\t\t\t\truntimeTemplate,\n\t\t\t\tlogger,\n\t\t\t\tasiSafe,\n\t\t\t\tobjKeys\n\t\t\t);\n\t\t}\n\t\tif (typeof code === \"bigint\") {\n\t\t\treturn runtimeTemplate.supportsBigIntLiteral()\n\t\t\t\t? `${code}n`\n\t\t\t\t: `BigInt(\"${code}\")`;\n\t\t}\n\t\treturn code + \"\";\n\t};\n\n\tconst strCode = transformToCode();\n\n\tlogger.log(`Replaced \"${key}\" with \"${strCode}\"`);\n\n\treturn strCode;\n};\n\nconst toCacheVersion = code => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (Object.is(code, -0)) {\n\t\treturn \"-0\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn code.getCacheVersion();\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\tconst items = Object.keys(code).map(key => ({\n\t\t\tkey,\n\t\t\tvalue: toCacheVersion(code[key])\n\t\t}));\n\t\tif (items.some(({ value }) => value === undefined)) return undefined;\n\t\treturn `{${items.map(({ key, value }) => `${key}: ${value}`).join(\", \")}}`;\n\t}\n\tif (typeof code === \"bigint\") {\n\t\treturn `${code}n`;\n\t}\n\treturn code + \"\";\n};\n\nconst PLUGIN_NAME = \"DefinePlugin\";\nconst VALUE_DEP_PREFIX = `webpack/${PLUGIN_NAME} `;\nconst VALUE_DEP_MAIN = `webpack/${PLUGIN_NAME}_hash`;\nconst TYPEOF_OPERATOR_REGEXP = /^typeof\\s+/;\nconst WEBPACK_REQUIRE_FUNCTION_REGEXP = /__webpack_require__\\s*(!?\\.)/;\nconst WEBPACK_REQUIRE_IDENTIFIER_REGEXP = /__webpack_require__/;\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\t/**\n\t * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t * @returns {RuntimeValue} runtime value\n\t */\n\tstatic runtimeValue(fn, options) {\n\t\treturn new RuntimeValue(fn, options);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.DefinePlugin\");\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\t\t\t\tconst { runtimeTemplate } = compilation;\n\n\t\t\t\tconst mainHash = createHash(compilation.outputOptions.hashFunction);\n\t\t\t\tmainHash.update(\n\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_MAIN)\n\t\t\t\t\t) || \"\"\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {JavascriptParser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tconst mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n\t\t\t\t\tparser.hooks.program.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tconst { buildInfo } = parser.state.module;\n\t\t\t\t\t\tif (!buildInfo.valueDependencies)\n\t\t\t\t\t\t\tbuildInfo.valueDependencies = new Map();\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n\t\t\t\t\t});\n\n\t\t\t\t\tconst addValueDependency = key => {\n\t\t\t\t\t\tconst { buildInfo } = parser.state.module;\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(\n\t\t\t\t\t\t\tVALUE_DEP_PREFIX + key,\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst withValueDependency =\n\t\t\t\t\t\t(key, fn) =>\n\t\t\t\t\t\t(...args) => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn fn(...args);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename.for(fullKey).tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst originalKey = key;\n\t\t\t\t\t\tconst isTypeof = TYPEOF_OPERATOR_REGEXP.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(TYPEOF_OPERATOR_REGEXP, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(\n\t\t\t\t\t\t\t\t\t\ttoCode(\n\t\t\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\tlet strCode = toCode(\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\t\t!parser.isAsiPosition(expr.range[0]),\n\t\t\t\t\t\t\t\t\tparser.destructuringAssignmentPropertiesFor(expr)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (parser.scope.inShorthand) {\n\t\t\t\t\t\t\t\t\tstrCode = parser.scope.inShorthand + \":\" + strCode;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? codeCode\n\t\t\t\t\t\t\t\t: \"typeof (\" + codeCode + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? codeCode\n\t\t\t\t\t\t\t\t: \"typeof (\" + codeCode + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setTruthy()\n\t\t\t\t\t\t\t\t.setSideEffects(false)\n\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t\t\twithValueDependency(key, evaluateToString(\"object\"))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\tlet strCode = stringifyObj(\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\t!parser.isAsiPosition(expr.range[0]),\n\t\t\t\t\t\t\t\tparser.destructuringAssignmentPropertiesFor(expr)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (parser.scope.inShorthand) {\n\t\t\t\t\t\t\t\tstrCode = parser.scope.inShorthand + \":\" + strCode;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t\t\twithValueDependency(\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"object\"))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\n\t\t\t\t/**\n\t\t\t\t * Walk definitions\n\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst walkDefinitionsForValues = (definitions, prefix) => {\n\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\tconst version = toCacheVersion(code);\n\t\t\t\t\t\tconst name = VALUE_DEP_PREFIX + prefix + key;\n\t\t\t\t\t\tmainHash.update(\"|\" + prefix + key);\n\t\t\t\t\t\tconst oldVersion = compilation.valueCacheVersions.get(name);\n\t\t\t\t\t\tif (oldVersion === undefined) {\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.set(name, version);\n\t\t\t\t\t\t} else if (oldVersion !== version) {\n\t\t\t\t\t\t\tconst warning = new WebpackError(\n\t\t\t\t\t\t\t\t`${PLUGIN_NAME}\\nConflicting values for '${prefix + key}'`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\twarning.details = `'${oldVersion}' !== '${version}'`;\n\t\t\t\t\t\t\twarning.hideStack = true;\n\t\t\t\t\t\t\tcompilation.warnings.push(warning);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\twalkDefinitionsForValues(code, prefix + key + \".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\twalkDefinitionsForValues(definitions, \"\");\n\n\t\t\t\tcompilation.valueCacheVersions.set(\n\t\t\t\t\tVALUE_DEP_MAIN,\n\t\t\t\t\t/** @type {string} */ (mainHash.digest(\"hex\").slice(0, 8))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"]},"metadata":{},"sourceType":"script"}