{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * @typedef {Object} CssTokenCallbacks\n * @property {function(string, number): boolean=} isSelector\n * @property {function(string, number, number, number, number): number=} url\n * @property {function(string, number, number): number=} string\n * @property {function(string, number, number): number=} leftParenthesis\n * @property {function(string, number, number): number=} rightParenthesis\n * @property {function(string, number, number): number=} pseudoFunction\n * @property {function(string, number, number): number=} function\n * @property {function(string, number, number): number=} pseudoClass\n * @property {function(string, number, number): number=} atKeyword\n * @property {function(string, number, number): number=} class\n * @property {function(string, number, number): number=} identifier\n * @property {function(string, number, number): number=} id\n * @property {function(string, number, number): number=} leftCurlyBracket\n * @property {function(string, number, number): number=} rightCurlyBracket\n * @property {function(string, number, number): number=} semicolon\n * @property {function(string, number, number): number=} comma\n */\n\n/** @typedef {function(string, number, CssTokenCallbacks): number} CharHandler */\n// spec: https://drafts.csswg.org/css-syntax/\n\nconst CC_LINE_FEED = \"\\n\".charCodeAt(0);\nconst CC_CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nconst CC_FORM_FEED = \"\\f\".charCodeAt(0);\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_SPACE = \" \".charCodeAt(0);\nconst CC_SOLIDUS = \"/\".charCodeAt(0);\nconst CC_REVERSE_SOLIDUS = \"\\\\\".charCodeAt(0);\nconst CC_ASTERISK = \"*\".charCodeAt(0);\nconst CC_LEFT_PARENTHESIS = \"(\".charCodeAt(0);\nconst CC_RIGHT_PARENTHESIS = \")\".charCodeAt(0);\nconst CC_LEFT_CURLY = \"{\".charCodeAt(0);\nconst CC_RIGHT_CURLY = \"}\".charCodeAt(0);\nconst CC_LEFT_SQUARE = \"[\".charCodeAt(0);\nconst CC_RIGHT_SQUARE = \"]\".charCodeAt(0);\nconst CC_QUOTATION_MARK = '\"'.charCodeAt(0);\nconst CC_APOSTROPHE = \"'\".charCodeAt(0);\nconst CC_FULL_STOP = \".\".charCodeAt(0);\nconst CC_COLON = \":\".charCodeAt(0);\nconst CC_SEMICOLON = \";\".charCodeAt(0);\nconst CC_COMMA = \",\".charCodeAt(0);\nconst CC_PERCENTAGE = \"%\".charCodeAt(0);\nconst CC_AT_SIGN = \"@\".charCodeAt(0);\nconst CC_LOW_LINE = \"_\".charCodeAt(0);\nconst CC_LOWER_A = \"a\".charCodeAt(0);\nconst CC_LOWER_U = \"u\".charCodeAt(0);\nconst CC_LOWER_E = \"e\".charCodeAt(0);\nconst CC_LOWER_Z = \"z\".charCodeAt(0);\nconst CC_UPPER_A = \"A\".charCodeAt(0);\nconst CC_UPPER_E = \"E\".charCodeAt(0);\nconst CC_UPPER_U = \"U\".charCodeAt(0);\nconst CC_UPPER_Z = \"Z\".charCodeAt(0);\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\nconst CC_NUMBER_SIGN = \"#\".charCodeAt(0);\nconst CC_PLUS_SIGN = \"+\".charCodeAt(0);\nconst CC_HYPHEN_MINUS = \"-\".charCodeAt(0);\nconst CC_LESS_THAN_SIGN = \"<\".charCodeAt(0);\nconst CC_GREATER_THAN_SIGN = \">\".charCodeAt(0);\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\n\nconst _isNewLine = cc => {\n  return cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n};\n/** @type {CharHandler} */\n\n\nconst consumeSpace = (input, pos, callbacks) => {\n  /** @type {number} */\n  let cc;\n\n  do {\n    pos++;\n    cc = input.charCodeAt(pos);\n  } while (_isWhiteSpace(cc));\n\n  return pos;\n};\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\n\n\nconst _isNewline = cc => {\n  return cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n};\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a space (U+0009 CHARACTER TABULATION or U+0020 SPACE)\n */\n\n\nconst _isSpace = cc => {\n  return cc === CC_TAB || cc === CC_SPACE;\n};\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a whitespace\n */\n\n\nconst _isWhiteSpace = cc => {\n  return _isNewline(cc) || _isSpace(cc);\n};\n/**\n * ident-start code point\n *\n * A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n *\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a start code point of an identifier\n */\n\n\nconst isIdentStartCodePoint = cc => {\n  return cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z || cc === CC_LOW_LINE || cc >= 0x80;\n};\n/** @type {CharHandler} */\n\n\nconst consumeDelimToken = (input, pos, callbacks) => {\n  return pos + 1;\n};\n/** @type {CharHandler} */\n\n\nconst consumeComments = (input, pos, callbacks) => {\n  // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A\n  // ASTERISK (*), consume them and all following code points up to and including\n  // the first U+002A ASTERISK (*) followed by a U+002F SOLIDUS (/), or up to an\n  // EOF code point. Return to the start of this step.\n  //\n  // If the preceding paragraph ended by consuming an EOF code point, this is a parse error.\n  // But we are silent on errors.\n  if (input.charCodeAt(pos) === CC_SOLIDUS && input.charCodeAt(pos + 1) === CC_ASTERISK) {\n    pos += 1;\n\n    while (pos < input.length) {\n      if (input.charCodeAt(pos) === CC_ASTERISK && input.charCodeAt(pos + 1) === CC_SOLIDUS) {\n        pos += 2;\n        break;\n      }\n\n      pos++;\n    }\n  }\n\n  return pos;\n};\n/** @type {function(number): CharHandler} */\n\n\nconst consumeString = quote_cc => (input, pos, callbacks) => {\n  const start = pos;\n  pos = _consumeString(input, pos, quote_cc);\n\n  if (callbacks.string !== undefined) {\n    pos = callbacks.string(input, start, pos);\n  }\n\n  return pos;\n};\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number} quote_cc quote char code\n * @returns {number} new position\n */\n\n\nconst _consumeString = (input, pos, quote_cc) => {\n  pos++;\n\n  for (;;) {\n    if (pos === input.length) return pos;\n    const cc = input.charCodeAt(pos);\n    if (cc === quote_cc) return pos + 1;\n\n    if (_isNewLine(cc)) {\n      // bad string\n      return pos;\n    }\n\n    if (cc === CC_REVERSE_SOLIDUS) {\n      // we don't need to fully parse the escaped code point\n      // just skip over a potential new line\n      pos++;\n      if (pos === input.length) return pos;\n      pos++;\n    } else {\n      pos++;\n    }\n  }\n};\n/**\n * @param {number} cc char code\n * @returns {boolean} is identifier start code\n */\n\n\nconst _isIdentifierStartCode = cc => {\n  return cc === CC_LOW_LINE || cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z || cc > 0x80;\n};\n/**\n * @param {number} first first code point\n * @param {number} second second code point\n * @returns {boolean} true if two code points are a valid escape\n */\n\n\nconst _isTwoCodePointsAreValidEscape = (first, second) => {\n  if (first !== CC_REVERSE_SOLIDUS) return false;\n  if (_isNewLine(second)) return false;\n  return true;\n};\n/**\n * @param {number} cc char code\n * @returns {boolean} is digit\n */\n\n\nconst _isDigit = cc => {\n  return cc >= CC_0 && cc <= CC_9;\n};\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {boolean} true, if input at pos starts an identifier\n */\n\n\nconst _startsIdentifier = (input, pos) => {\n  const cc = input.charCodeAt(pos);\n\n  if (cc === CC_HYPHEN_MINUS) {\n    if (pos === input.length) return false;\n    const cc = input.charCodeAt(pos + 1);\n    if (cc === CC_HYPHEN_MINUS) return true;\n\n    if (cc === CC_REVERSE_SOLIDUS) {\n      const cc = input.charCodeAt(pos + 2);\n      return !_isNewLine(cc);\n    }\n\n    return _isIdentifierStartCode(cc);\n  }\n\n  if (cc === CC_REVERSE_SOLIDUS) {\n    const cc = input.charCodeAt(pos + 1);\n    return !_isNewLine(cc);\n  }\n\n  return _isIdentifierStartCode(cc);\n};\n/** @type {CharHandler} */\n\n\nconst consumeNumberSign = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n\n  if (callbacks.isSelector(input, pos) && _startsIdentifier(input, pos)) {\n    pos = _consumeIdentifier(input, pos, callbacks);\n\n    if (callbacks.id !== undefined) {\n      return callbacks.id(input, start, pos);\n    }\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeMinus = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  const cc = input.charCodeAt(pos); // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n\n  if (cc === CC_FULL_STOP || _isDigit(cc)) {\n    return consumeNumericToken(input, pos, callbacks);\n  } else if (cc === CC_HYPHEN_MINUS) {\n    pos++;\n    if (pos === input.length) return pos;\n    const cc = input.charCodeAt(pos);\n\n    if (cc === CC_GREATER_THAN_SIGN) {\n      return pos + 1;\n    } else {\n      pos = _consumeIdentifier(input, pos, callbacks);\n\n      if (callbacks.identifier !== undefined) {\n        return callbacks.identifier(input, start, pos);\n      }\n    }\n  } else if (cc === CC_REVERSE_SOLIDUS) {\n    if (pos + 1 === input.length) return pos;\n    const cc = input.charCodeAt(pos + 1);\n    if (_isNewLine(cc)) return pos;\n    pos = _consumeIdentifier(input, pos, callbacks);\n\n    if (callbacks.identifier !== undefined) {\n      return callbacks.identifier(input, start, pos);\n    }\n  } else if (_isIdentifierStartCode(cc)) {\n    pos = consumeOtherIdentifier(input, pos - 1, callbacks);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeDot = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  const cc = input.charCodeAt(pos);\n  if (_isDigit(cc)) return consumeNumericToken(input, pos - 2, callbacks);\n  if (!callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos)) return pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  if (callbacks.class !== undefined) return callbacks.class(input, start, pos);\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeNumericToken = (input, pos, callbacks) => {\n  pos = _consumeNumber(input, pos, callbacks);\n  if (pos === input.length) return pos;\n  if (_startsIdentifier(input, pos)) return _consumeIdentifier(input, pos, callbacks);\n  const cc = input.charCodeAt(pos);\n  if (cc === CC_PERCENTAGE) return pos + 1;\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeOtherIdentifier = (input, pos, callbacks) => {\n  const start = pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n\n  if (pos !== input.length && input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n    pos++;\n\n    if (callbacks.function !== undefined) {\n      return callbacks.function(input, start, pos);\n    }\n  } else {\n    if (callbacks.identifier !== undefined) {\n      return callbacks.identifier(input, start, pos);\n    }\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumePotentialUrl = (input, pos, callbacks) => {\n  const start = pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  const nextPos = pos + 1;\n\n  if (pos === start + 3 && input.slice(start, nextPos).toLowerCase() === \"url(\") {\n    pos++;\n    let cc = input.charCodeAt(pos);\n\n    while (_isWhiteSpace(cc)) {\n      pos++;\n      if (pos === input.length) return pos;\n      cc = input.charCodeAt(pos);\n    }\n\n    if (cc === CC_QUOTATION_MARK || cc === CC_APOSTROPHE) {\n      if (callbacks.function !== undefined) {\n        return callbacks.function(input, start, nextPos);\n      }\n\n      return nextPos;\n    } else {\n      const contentStart = pos;\n      /** @type {number} */\n\n      let contentEnd;\n\n      for (;;) {\n        if (cc === CC_REVERSE_SOLIDUS) {\n          pos++;\n          if (pos === input.length) return pos;\n          pos++;\n        } else if (_isWhiteSpace(cc)) {\n          contentEnd = pos;\n\n          do {\n            pos++;\n            if (pos === input.length) return pos;\n            cc = input.charCodeAt(pos);\n          } while (_isWhiteSpace(cc));\n\n          if (cc !== CC_RIGHT_PARENTHESIS) return pos;\n          pos++;\n\n          if (callbacks.url !== undefined) {\n            return callbacks.url(input, start, pos, contentStart, contentEnd);\n          }\n\n          return pos;\n        } else if (cc === CC_RIGHT_PARENTHESIS) {\n          contentEnd = pos;\n          pos++;\n\n          if (callbacks.url !== undefined) {\n            return callbacks.url(input, start, pos, contentStart, contentEnd);\n          }\n\n          return pos;\n        } else if (cc === CC_LEFT_PARENTHESIS) {\n          return pos;\n        } else {\n          pos++;\n        }\n\n        if (pos === input.length) return pos;\n        cc = input.charCodeAt(pos);\n      }\n    }\n  } else {\n    if (callbacks.identifier !== undefined) {\n      return callbacks.identifier(input, start, pos);\n    }\n\n    return pos;\n  }\n};\n/** @type {CharHandler} */\n\n\nconst consumePotentialPseudo = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (!callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos)) return pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  let cc = input.charCodeAt(pos);\n\n  if (cc === CC_LEFT_PARENTHESIS) {\n    pos++;\n\n    if (callbacks.pseudoFunction !== undefined) {\n      return callbacks.pseudoFunction(input, start, pos);\n    }\n\n    return pos;\n  }\n\n  if (callbacks.pseudoClass !== undefined) {\n    return callbacks.pseudoClass(input, start, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeLeftParenthesis = (input, pos, callbacks) => {\n  pos++;\n\n  if (callbacks.leftParenthesis !== undefined) {\n    return callbacks.leftParenthesis(input, pos - 1, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeRightParenthesis = (input, pos, callbacks) => {\n  pos++;\n\n  if (callbacks.rightParenthesis !== undefined) {\n    return callbacks.rightParenthesis(input, pos - 1, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeLeftCurlyBracket = (input, pos, callbacks) => {\n  pos++;\n\n  if (callbacks.leftCurlyBracket !== undefined) {\n    return callbacks.leftCurlyBracket(input, pos - 1, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeRightCurlyBracket = (input, pos, callbacks) => {\n  pos++;\n\n  if (callbacks.rightCurlyBracket !== undefined) {\n    return callbacks.rightCurlyBracket(input, pos - 1, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeSemicolon = (input, pos, callbacks) => {\n  pos++;\n\n  if (callbacks.semicolon !== undefined) {\n    return callbacks.semicolon(input, pos - 1, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeComma = (input, pos, callbacks) => {\n  pos++;\n\n  if (callbacks.comma !== undefined) {\n    return callbacks.comma(input, pos - 1, pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst _consumeIdentifier = (input, pos) => {\n  for (;;) {\n    const cc = input.charCodeAt(pos);\n\n    if (cc === CC_REVERSE_SOLIDUS) {\n      pos++;\n      if (pos === input.length) return pos;\n      pos++;\n    } else if (_isIdentifierStartCode(cc) || _isDigit(cc) || cc === CC_HYPHEN_MINUS) {\n      pos++;\n    } else {\n      return pos;\n    }\n  }\n};\n/** @type {CharHandler} */\n\n\nconst _consumeNumber = (input, pos) => {\n  pos++;\n  if (pos === input.length) return pos;\n  let cc = input.charCodeAt(pos);\n\n  while (_isDigit(cc)) {\n    pos++;\n    if (pos === input.length) return pos;\n    cc = input.charCodeAt(pos);\n  }\n\n  if (cc === CC_FULL_STOP && pos + 1 !== input.length) {\n    const next = input.charCodeAt(pos + 1);\n\n    if (_isDigit(next)) {\n      pos += 2;\n      cc = input.charCodeAt(pos);\n\n      while (_isDigit(cc)) {\n        pos++;\n        if (pos === input.length) return pos;\n        cc = input.charCodeAt(pos);\n      }\n    }\n  }\n\n  if (cc === CC_LOWER_E || cc === CC_UPPER_E) {\n    if (pos + 1 !== input.length) {\n      const next = input.charCodeAt(pos + 2);\n\n      if (_isDigit(next)) {\n        pos += 2;\n      } else if ((next === CC_HYPHEN_MINUS || next === CC_PLUS_SIGN) && pos + 2 !== input.length) {\n        const next = input.charCodeAt(pos + 2);\n\n        if (_isDigit(next)) {\n          pos += 3;\n        } else {\n          return pos;\n        }\n      } else {\n        return pos;\n      }\n    }\n  } else {\n    return pos;\n  }\n\n  cc = input.charCodeAt(pos);\n\n  while (_isDigit(cc)) {\n    pos++;\n    if (pos === input.length) return pos;\n    cc = input.charCodeAt(pos);\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeLessThan = (input, pos, callbacks) => {\n  if (input.slice(pos + 1, pos + 4) === \"!--\") return pos + 4;\n  return pos + 1;\n};\n/** @type {CharHandler} */\n\n\nconst consumeAt = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n\n  if (_startsIdentifier(input, pos)) {\n    pos = _consumeIdentifier(input, pos, callbacks);\n\n    if (callbacks.atKeyword !== undefined) {\n      pos = callbacks.atKeyword(input, start, pos);\n    }\n  }\n\n  return pos;\n};\n/** @type {CharHandler} */\n\n\nconst consumeReverseSolidus = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos; // If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n\n  if (_isTwoCodePointsAreValidEscape(input.charCodeAt(start), input.charCodeAt(pos))) {\n    return consumeOtherIdentifier(input, pos - 1, callbacks);\n  } // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n\n\n  return pos;\n};\n\nconst CHAR_MAP = Array.from({\n  length: 0x80\n}, (_, cc) => {\n  // https://drafts.csswg.org/css-syntax/#consume-token\n  switch (cc) {\n    // whitespace\n    case CC_LINE_FEED:\n    case CC_CARRIAGE_RETURN:\n    case CC_FORM_FEED:\n    case CC_TAB:\n    case CC_SPACE:\n      return consumeSpace;\n    // U+0022 QUOTATION MARK (\")\n\n    case CC_QUOTATION_MARK:\n      return consumeString(cc);\n    // U+0023 NUMBER SIGN (#)\n\n    case CC_NUMBER_SIGN:\n      return consumeNumberSign;\n    // U+0027 APOSTROPHE (')\n\n    case CC_APOSTROPHE:\n      return consumeString(cc);\n    // U+0028 LEFT PARENTHESIS (()\n\n    case CC_LEFT_PARENTHESIS:\n      return consumeLeftParenthesis;\n    // U+0029 RIGHT PARENTHESIS ())\n\n    case CC_RIGHT_PARENTHESIS:\n      return consumeRightParenthesis;\n    // U+002B PLUS SIGN (+)\n\n    case CC_PLUS_SIGN:\n      return consumeNumericToken;\n    // U+002C COMMA (,)\n\n    case CC_COMMA:\n      return consumeComma;\n    // U+002D HYPHEN-MINUS (-)\n\n    case CC_HYPHEN_MINUS:\n      return consumeMinus;\n    // U+002E FULL STOP (.)\n\n    case CC_FULL_STOP:\n      return consumeDot;\n    // U+003A COLON (:)\n\n    case CC_COLON:\n      return consumePotentialPseudo;\n    // U+003B SEMICOLON (;)\n\n    case CC_SEMICOLON:\n      return consumeSemicolon;\n    // U+003C LESS-THAN SIGN (<)\n\n    case CC_LESS_THAN_SIGN:\n      return consumeLessThan;\n    // U+0040 COMMERCIAL AT (@)\n\n    case CC_AT_SIGN:\n      return consumeAt;\n    // U+005B LEFT SQUARE BRACKET ([)\n\n    case CC_LEFT_SQUARE:\n      return consumeDelimToken;\n    // U+005C REVERSE SOLIDUS (\\)\n\n    case CC_REVERSE_SOLIDUS:\n      return consumeReverseSolidus;\n    // U+005D RIGHT SQUARE BRACKET (])\n\n    case CC_RIGHT_SQUARE:\n      return consumeDelimToken;\n    // U+007B LEFT CURLY BRACKET ({)\n\n    case CC_LEFT_CURLY:\n      return consumeLeftCurlyBracket;\n    // U+007D RIGHT CURLY BRACKET (})\n\n    case CC_RIGHT_CURLY:\n      return consumeRightCurlyBracket;\n    // Optimization\n\n    case CC_LOWER_U:\n    case CC_UPPER_U:\n      return consumePotentialUrl;\n\n    default:\n      // digit\n      if (_isDigit(cc)) return consumeNumericToken; // ident-start code point\n\n      if (isIdentStartCodePoint(cc)) {\n        return consumeOtherIdentifier;\n      } // EOF, but we don't have it\n      // anything else\n\n\n      return consumeDelimToken;\n  }\n});\n/**\n * @param {string} input input css\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {void}\n */\n\nmodule.exports = (input, callbacks) => {\n  // This section describes how to consume a token from a stream of code points. It will return a single token of any type.\n  let pos = 0;\n\n  while (pos < input.length) {\n    // Consume comments.\n    pos = consumeComments(input, pos, callbacks);\n    const cc = input.charCodeAt(pos); // Consume the next input code point.\n\n    if (cc < 0x80) {\n      pos = CHAR_MAP[cc](input, pos, callbacks);\n    } else {\n      pos++;\n    }\n  }\n};\n\nmodule.exports.isIdentStartCodePoint = isIdentStartCodePoint;\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after comments\n */\n\nmodule.exports.eatComments = (input, pos) => {\n  for (;;) {\n    let originalPos = pos;\n    pos = consumeComments(input, pos, {});\n\n    if (originalPos === pos) {\n      break;\n    }\n  }\n\n  return pos;\n};\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\n\n\nmodule.exports.eatWhitespace = (input, pos) => {\n  while (_isWhiteSpace(input.charCodeAt(pos))) {\n    pos++;\n  }\n\n  return pos;\n};\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\n\n\nmodule.exports.eatWhitespaceAndComments = (input, pos) => {\n  for (;;) {\n    let originalPos = pos;\n    pos = consumeComments(input, pos, {});\n\n    while (_isWhiteSpace(input.charCodeAt(pos))) {\n      pos++;\n    }\n\n    if (originalPos === pos) {\n      break;\n    }\n  }\n\n  return pos;\n};\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\n\n\nmodule.exports.eatWhiteLine = (input, pos) => {\n  for (;;) {\n    const cc = input.charCodeAt(pos);\n\n    if (_isSpace(cc)) {\n      pos++;\n      continue;\n    }\n\n    if (_isNewLine(cc)) pos++; // For `\\r\\n`\n\n    if (cc === CC_CARRIAGE_RETURN && input.charCodeAt(pos + 1) === CC_LINE_FEED) pos++;\n    break;\n  }\n\n  return pos;\n};","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/css/walkCssTokens.js"],"names":["CC_LINE_FEED","charCodeAt","CC_CARRIAGE_RETURN","CC_FORM_FEED","CC_TAB","CC_SPACE","CC_SOLIDUS","CC_REVERSE_SOLIDUS","CC_ASTERISK","CC_LEFT_PARENTHESIS","CC_RIGHT_PARENTHESIS","CC_LEFT_CURLY","CC_RIGHT_CURLY","CC_LEFT_SQUARE","CC_RIGHT_SQUARE","CC_QUOTATION_MARK","CC_APOSTROPHE","CC_FULL_STOP","CC_COLON","CC_SEMICOLON","CC_COMMA","CC_PERCENTAGE","CC_AT_SIGN","CC_LOW_LINE","CC_LOWER_A","CC_LOWER_U","CC_LOWER_E","CC_LOWER_Z","CC_UPPER_A","CC_UPPER_E","CC_UPPER_U","CC_UPPER_Z","CC_0","CC_9","CC_NUMBER_SIGN","CC_PLUS_SIGN","CC_HYPHEN_MINUS","CC_LESS_THAN_SIGN","CC_GREATER_THAN_SIGN","_isNewLine","cc","consumeSpace","input","pos","callbacks","_isWhiteSpace","_isNewline","_isSpace","isIdentStartCodePoint","consumeDelimToken","consumeComments","length","consumeString","quote_cc","start","_consumeString","string","undefined","_isIdentifierStartCode","_isTwoCodePointsAreValidEscape","first","second","_isDigit","_startsIdentifier","consumeNumberSign","isSelector","_consumeIdentifier","id","consumeMinus","consumeNumericToken","identifier","consumeOtherIdentifier","consumeDot","class","_consumeNumber","function","consumePotentialUrl","nextPos","slice","toLowerCase","contentStart","contentEnd","url","consumePotentialPseudo","pseudoFunction","pseudoClass","consumeLeftParenthesis","leftParenthesis","consumeRightParenthesis","rightParenthesis","consumeLeftCurlyBracket","leftCurlyBracket","consumeRightCurlyBracket","rightCurlyBracket","consumeSemicolon","semicolon","consumeComma","comma","next","consumeLessThan","consumeAt","atKeyword","consumeReverseSolidus","CHAR_MAP","Array","from","_","module","exports","eatComments","originalPos","eatWhitespace","eatWhitespaceAndComments","eatWhiteLine"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {Object} CssTokenCallbacks\n * @property {function(string, number): boolean=} isSelector\n * @property {function(string, number, number, number, number): number=} url\n * @property {function(string, number, number): number=} string\n * @property {function(string, number, number): number=} leftParenthesis\n * @property {function(string, number, number): number=} rightParenthesis\n * @property {function(string, number, number): number=} pseudoFunction\n * @property {function(string, number, number): number=} function\n * @property {function(string, number, number): number=} pseudoClass\n * @property {function(string, number, number): number=} atKeyword\n * @property {function(string, number, number): number=} class\n * @property {function(string, number, number): number=} identifier\n * @property {function(string, number, number): number=} id\n * @property {function(string, number, number): number=} leftCurlyBracket\n * @property {function(string, number, number): number=} rightCurlyBracket\n * @property {function(string, number, number): number=} semicolon\n * @property {function(string, number, number): number=} comma\n */\n\n/** @typedef {function(string, number, CssTokenCallbacks): number} CharHandler */\n\n// spec: https://drafts.csswg.org/css-syntax/\n\nconst CC_LINE_FEED = \"\\n\".charCodeAt(0);\nconst CC_CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nconst CC_FORM_FEED = \"\\f\".charCodeAt(0);\n\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_SPACE = \" \".charCodeAt(0);\n\nconst CC_SOLIDUS = \"/\".charCodeAt(0);\nconst CC_REVERSE_SOLIDUS = \"\\\\\".charCodeAt(0);\nconst CC_ASTERISK = \"*\".charCodeAt(0);\n\nconst CC_LEFT_PARENTHESIS = \"(\".charCodeAt(0);\nconst CC_RIGHT_PARENTHESIS = \")\".charCodeAt(0);\nconst CC_LEFT_CURLY = \"{\".charCodeAt(0);\nconst CC_RIGHT_CURLY = \"}\".charCodeAt(0);\nconst CC_LEFT_SQUARE = \"[\".charCodeAt(0);\nconst CC_RIGHT_SQUARE = \"]\".charCodeAt(0);\n\nconst CC_QUOTATION_MARK = '\"'.charCodeAt(0);\nconst CC_APOSTROPHE = \"'\".charCodeAt(0);\n\nconst CC_FULL_STOP = \".\".charCodeAt(0);\nconst CC_COLON = \":\".charCodeAt(0);\nconst CC_SEMICOLON = \";\".charCodeAt(0);\nconst CC_COMMA = \",\".charCodeAt(0);\nconst CC_PERCENTAGE = \"%\".charCodeAt(0);\nconst CC_AT_SIGN = \"@\".charCodeAt(0);\n\nconst CC_LOW_LINE = \"_\".charCodeAt(0);\nconst CC_LOWER_A = \"a\".charCodeAt(0);\nconst CC_LOWER_U = \"u\".charCodeAt(0);\nconst CC_LOWER_E = \"e\".charCodeAt(0);\nconst CC_LOWER_Z = \"z\".charCodeAt(0);\nconst CC_UPPER_A = \"A\".charCodeAt(0);\nconst CC_UPPER_E = \"E\".charCodeAt(0);\nconst CC_UPPER_U = \"U\".charCodeAt(0);\nconst CC_UPPER_Z = \"Z\".charCodeAt(0);\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\n\nconst CC_NUMBER_SIGN = \"#\".charCodeAt(0);\nconst CC_PLUS_SIGN = \"+\".charCodeAt(0);\nconst CC_HYPHEN_MINUS = \"-\".charCodeAt(0);\n\nconst CC_LESS_THAN_SIGN = \"<\".charCodeAt(0);\nconst CC_GREATER_THAN_SIGN = \">\".charCodeAt(0);\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewLine = cc => {\n\treturn (\n\t\tcc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED\n\t);\n};\n\n/** @type {CharHandler} */\nconst consumeSpace = (input, pos, callbacks) => {\n\t/** @type {number} */\n\tlet cc;\n\tdo {\n\t\tpos++;\n\t\tcc = input.charCodeAt(pos);\n\t} while (_isWhiteSpace(cc));\n\treturn pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewline = cc => {\n\treturn (\n\t\tcc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED\n\t);\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a space (U+0009 CHARACTER TABULATION or U+0020 SPACE)\n */\nconst _isSpace = cc => {\n\treturn cc === CC_TAB || cc === CC_SPACE;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a whitespace\n */\nconst _isWhiteSpace = cc => {\n\treturn _isNewline(cc) || _isSpace(cc);\n};\n\n/**\n * ident-start code point\n *\n * A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n *\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a start code point of an identifier\n */\nconst isIdentStartCodePoint = cc => {\n\treturn (\n\t\t(cc >= CC_LOWER_A && cc <= CC_LOWER_Z) ||\n\t\t(cc >= CC_UPPER_A && cc <= CC_UPPER_Z) ||\n\t\tcc === CC_LOW_LINE ||\n\t\tcc >= 0x80\n\t);\n};\n\n/** @type {CharHandler} */\nconst consumeDelimToken = (input, pos, callbacks) => {\n\treturn pos + 1;\n};\n\n/** @type {CharHandler} */\nconst consumeComments = (input, pos, callbacks) => {\n\t// If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A\n\t// ASTERISK (*), consume them and all following code points up to and including\n\t// the first U+002A ASTERISK (*) followed by a U+002F SOLIDUS (/), or up to an\n\t// EOF code point. Return to the start of this step.\n\t//\n\t// If the preceding paragraph ended by consuming an EOF code point, this is a parse error.\n\t// But we are silent on errors.\n\tif (\n\t\tinput.charCodeAt(pos) === CC_SOLIDUS &&\n\t\tinput.charCodeAt(pos + 1) === CC_ASTERISK\n\t) {\n\t\tpos += 1;\n\t\twhile (pos < input.length) {\n\t\t\tif (\n\t\t\t\tinput.charCodeAt(pos) === CC_ASTERISK &&\n\t\t\t\tinput.charCodeAt(pos + 1) === CC_SOLIDUS\n\t\t\t) {\n\t\t\t\tpos += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {function(number): CharHandler} */\nconst consumeString = quote_cc => (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos = _consumeString(input, pos, quote_cc);\n\tif (callbacks.string !== undefined) {\n\t\tpos = callbacks.string(input, start, pos);\n\t}\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number} quote_cc quote char code\n * @returns {number} new position\n */\nconst _consumeString = (input, pos, quote_cc) => {\n\tpos++;\n\tfor (;;) {\n\t\tif (pos === input.length) return pos;\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (cc === quote_cc) return pos + 1;\n\t\tif (_isNewLine(cc)) {\n\t\t\t// bad string\n\t\t\treturn pos;\n\t\t}\n\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\t// we don't need to fully parse the escaped code point\n\t\t\t// just skip over a potential new line\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} is identifier start code\n */\nconst _isIdentifierStartCode = cc => {\n\treturn (\n\t\tcc === CC_LOW_LINE ||\n\t\t(cc >= CC_LOWER_A && cc <= CC_LOWER_Z) ||\n\t\t(cc >= CC_UPPER_A && cc <= CC_UPPER_Z) ||\n\t\tcc > 0x80\n\t);\n};\n\n/**\n * @param {number} first first code point\n * @param {number} second second code point\n * @returns {boolean} true if two code points are a valid escape\n */\nconst _isTwoCodePointsAreValidEscape = (first, second) => {\n\tif (first !== CC_REVERSE_SOLIDUS) return false;\n\tif (_isNewLine(second)) return false;\n\treturn true;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} is digit\n */\nconst _isDigit = cc => {\n\treturn cc >= CC_0 && cc <= CC_9;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _startsIdentifier = (input, pos) => {\n\tconst cc = input.charCodeAt(pos);\n\tif (cc === CC_HYPHEN_MINUS) {\n\t\tif (pos === input.length) return false;\n\t\tconst cc = input.charCodeAt(pos + 1);\n\t\tif (cc === CC_HYPHEN_MINUS) return true;\n\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\tconst cc = input.charCodeAt(pos + 2);\n\t\t\treturn !_isNewLine(cc);\n\t\t}\n\t\treturn _isIdentifierStartCode(cc);\n\t}\n\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\tconst cc = input.charCodeAt(pos + 1);\n\t\treturn !_isNewLine(cc);\n\t}\n\treturn _isIdentifierStartCode(cc);\n};\n\n/** @type {CharHandler} */\nconst consumeNumberSign = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tif (callbacks.isSelector(input, pos) && _startsIdentifier(input, pos)) {\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.id !== undefined) {\n\t\t\treturn callbacks.id(input, start, pos);\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeMinus = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tconst cc = input.charCodeAt(pos);\n\t// If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n\tif (cc === CC_FULL_STOP || _isDigit(cc)) {\n\t\treturn consumeNumericToken(input, pos, callbacks);\n\t} else if (cc === CC_HYPHEN_MINUS) {\n\t\tpos++;\n\t\tif (pos === input.length) return pos;\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (cc === CC_GREATER_THAN_SIGN) {\n\t\t\treturn pos + 1;\n\t\t} else {\n\t\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\t\tif (callbacks.identifier !== undefined) {\n\t\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t\t}\n\t\t}\n\t} else if (cc === CC_REVERSE_SOLIDUS) {\n\t\tif (pos + 1 === input.length) return pos;\n\t\tconst cc = input.charCodeAt(pos + 1);\n\t\tif (_isNewLine(cc)) return pos;\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.identifier !== undefined) {\n\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t}\n\t} else if (_isIdentifierStartCode(cc)) {\n\t\tpos = consumeOtherIdentifier(input, pos - 1, callbacks);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeDot = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tconst cc = input.charCodeAt(pos);\n\tif (_isDigit(cc)) return consumeNumericToken(input, pos - 2, callbacks);\n\tif (!callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos))\n\t\treturn pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tif (callbacks.class !== undefined) return callbacks.class(input, start, pos);\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeNumericToken = (input, pos, callbacks) => {\n\tpos = _consumeNumber(input, pos, callbacks);\n\tif (pos === input.length) return pos;\n\tif (_startsIdentifier(input, pos))\n\t\treturn _consumeIdentifier(input, pos, callbacks);\n\tconst cc = input.charCodeAt(pos);\n\tif (cc === CC_PERCENTAGE) return pos + 1;\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeOtherIdentifier = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tif (pos !== input.length && input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n\t\tpos++;\n\t\tif (callbacks.function !== undefined) {\n\t\t\treturn callbacks.function(input, start, pos);\n\t\t}\n\t} else {\n\t\tif (callbacks.identifier !== undefined) {\n\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumePotentialUrl = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tconst nextPos = pos + 1;\n\tif (\n\t\tpos === start + 3 &&\n\t\tinput.slice(start, nextPos).toLowerCase() === \"url(\"\n\t) {\n\t\tpos++;\n\t\tlet cc = input.charCodeAt(pos);\n\t\twhile (_isWhiteSpace(cc)) {\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t\tcc = input.charCodeAt(pos);\n\t\t}\n\t\tif (cc === CC_QUOTATION_MARK || cc === CC_APOSTROPHE) {\n\t\t\tif (callbacks.function !== undefined) {\n\t\t\t\treturn callbacks.function(input, start, nextPos);\n\t\t\t}\n\t\t\treturn nextPos;\n\t\t} else {\n\t\t\tconst contentStart = pos;\n\t\t\t/** @type {number} */\n\t\t\tlet contentEnd;\n\t\t\tfor (;;) {\n\t\t\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\t\tpos++;\n\t\t\t\t} else if (_isWhiteSpace(cc)) {\n\t\t\t\t\tcontentEnd = pos;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\t\t\tcc = input.charCodeAt(pos);\n\t\t\t\t\t} while (_isWhiteSpace(cc));\n\t\t\t\t\tif (cc !== CC_RIGHT_PARENTHESIS) return pos;\n\t\t\t\t\tpos++;\n\t\t\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\t\t\treturn callbacks.url(input, start, pos, contentStart, contentEnd);\n\t\t\t\t\t}\n\t\t\t\t\treturn pos;\n\t\t\t\t} else if (cc === CC_RIGHT_PARENTHESIS) {\n\t\t\t\t\tcontentEnd = pos;\n\t\t\t\t\tpos++;\n\t\t\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\t\t\treturn callbacks.url(input, start, pos, contentStart, contentEnd);\n\t\t\t\t\t}\n\t\t\t\t\treturn pos;\n\t\t\t\t} else if (cc === CC_LEFT_PARENTHESIS) {\n\t\t\t\t\treturn pos;\n\t\t\t\t} else {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\tcc = input.charCodeAt(pos);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (callbacks.identifier !== undefined) {\n\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t}\n\t\treturn pos;\n\t}\n};\n\n/** @type {CharHandler} */\nconst consumePotentialPseudo = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (!callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos))\n\t\treturn pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tlet cc = input.charCodeAt(pos);\n\tif (cc === CC_LEFT_PARENTHESIS) {\n\t\tpos++;\n\t\tif (callbacks.pseudoFunction !== undefined) {\n\t\t\treturn callbacks.pseudoFunction(input, start, pos);\n\t\t}\n\t\treturn pos;\n\t}\n\tif (callbacks.pseudoClass !== undefined) {\n\t\treturn callbacks.pseudoClass(input, start, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftParenthesis = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.leftParenthesis !== undefined) {\n\t\treturn callbacks.leftParenthesis(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightParenthesis = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.rightParenthesis !== undefined) {\n\t\treturn callbacks.rightParenthesis(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftCurlyBracket = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.leftCurlyBracket !== undefined) {\n\t\treturn callbacks.leftCurlyBracket(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightCurlyBracket = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.rightCurlyBracket !== undefined) {\n\t\treturn callbacks.rightCurlyBracket(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeSemicolon = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.semicolon !== undefined) {\n\t\treturn callbacks.semicolon(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeComma = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.comma !== undefined) {\n\t\treturn callbacks.comma(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeIdentifier = (input, pos) => {\n\tfor (;;) {\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t\tpos++;\n\t\t} else if (\n\t\t\t_isIdentifierStartCode(cc) ||\n\t\t\t_isDigit(cc) ||\n\t\t\tcc === CC_HYPHEN_MINUS\n\t\t) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\treturn pos;\n\t\t}\n\t}\n};\n\n/** @type {CharHandler} */\nconst _consumeNumber = (input, pos) => {\n\tpos++;\n\tif (pos === input.length) return pos;\n\tlet cc = input.charCodeAt(pos);\n\twhile (_isDigit(cc)) {\n\t\tpos++;\n\t\tif (pos === input.length) return pos;\n\t\tcc = input.charCodeAt(pos);\n\t}\n\tif (cc === CC_FULL_STOP && pos + 1 !== input.length) {\n\t\tconst next = input.charCodeAt(pos + 1);\n\t\tif (_isDigit(next)) {\n\t\t\tpos += 2;\n\t\t\tcc = input.charCodeAt(pos);\n\t\t\twhile (_isDigit(cc)) {\n\t\t\t\tpos++;\n\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\tcc = input.charCodeAt(pos);\n\t\t\t}\n\t\t}\n\t}\n\tif (cc === CC_LOWER_E || cc === CC_UPPER_E) {\n\t\tif (pos + 1 !== input.length) {\n\t\t\tconst next = input.charCodeAt(pos + 2);\n\t\t\tif (_isDigit(next)) {\n\t\t\t\tpos += 2;\n\t\t\t} else if (\n\t\t\t\t(next === CC_HYPHEN_MINUS || next === CC_PLUS_SIGN) &&\n\t\t\t\tpos + 2 !== input.length\n\t\t\t) {\n\t\t\t\tconst next = input.charCodeAt(pos + 2);\n\t\t\t\tif (_isDigit(next)) {\n\t\t\t\t\tpos += 3;\n\t\t\t\t} else {\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn pos;\n\t}\n\tcc = input.charCodeAt(pos);\n\twhile (_isDigit(cc)) {\n\t\tpos++;\n\t\tif (pos === input.length) return pos;\n\t\tcc = input.charCodeAt(pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLessThan = (input, pos, callbacks) => {\n\tif (input.slice(pos + 1, pos + 4) === \"!--\") return pos + 4;\n\treturn pos + 1;\n};\n\n/** @type {CharHandler} */\nconst consumeAt = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tif (_startsIdentifier(input, pos)) {\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.atKeyword !== undefined) {\n\t\t\tpos = callbacks.atKeyword(input, start, pos);\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeReverseSolidus = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\t// If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n\tif (\n\t\t_isTwoCodePointsAreValidEscape(\n\t\t\tinput.charCodeAt(start),\n\t\t\tinput.charCodeAt(pos)\n\t\t)\n\t) {\n\t\treturn consumeOtherIdentifier(input, pos - 1, callbacks);\n\t}\n\t// Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\nconst CHAR_MAP = Array.from({ length: 0x80 }, (_, cc) => {\n\t// https://drafts.csswg.org/css-syntax/#consume-token\n\tswitch (cc) {\n\t\t// whitespace\n\t\tcase CC_LINE_FEED:\n\t\tcase CC_CARRIAGE_RETURN:\n\t\tcase CC_FORM_FEED:\n\t\tcase CC_TAB:\n\t\tcase CC_SPACE:\n\t\t\treturn consumeSpace;\n\t\t// U+0022 QUOTATION MARK (\")\n\t\tcase CC_QUOTATION_MARK:\n\t\t\treturn consumeString(cc);\n\t\t// U+0023 NUMBER SIGN (#)\n\t\tcase CC_NUMBER_SIGN:\n\t\t\treturn consumeNumberSign;\n\t\t// U+0027 APOSTROPHE (')\n\t\tcase CC_APOSTROPHE:\n\t\t\treturn consumeString(cc);\n\t\t// U+0028 LEFT PARENTHESIS (()\n\t\tcase CC_LEFT_PARENTHESIS:\n\t\t\treturn consumeLeftParenthesis;\n\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\tcase CC_RIGHT_PARENTHESIS:\n\t\t\treturn consumeRightParenthesis;\n\t\t// U+002B PLUS SIGN (+)\n\t\tcase CC_PLUS_SIGN:\n\t\t\treturn consumeNumericToken;\n\t\t// U+002C COMMA (,)\n\t\tcase CC_COMMA:\n\t\t\treturn consumeComma;\n\t\t// U+002D HYPHEN-MINUS (-)\n\t\tcase CC_HYPHEN_MINUS:\n\t\t\treturn consumeMinus;\n\t\t// U+002E FULL STOP (.)\n\t\tcase CC_FULL_STOP:\n\t\t\treturn consumeDot;\n\t\t// U+003A COLON (:)\n\t\tcase CC_COLON:\n\t\t\treturn consumePotentialPseudo;\n\t\t// U+003B SEMICOLON (;)\n\t\tcase CC_SEMICOLON:\n\t\t\treturn consumeSemicolon;\n\t\t// U+003C LESS-THAN SIGN (<)\n\t\tcase CC_LESS_THAN_SIGN:\n\t\t\treturn consumeLessThan;\n\t\t// U+0040 COMMERCIAL AT (@)\n\t\tcase CC_AT_SIGN:\n\t\t\treturn consumeAt;\n\t\t// U+005B LEFT SQUARE BRACKET ([)\n\t\tcase CC_LEFT_SQUARE:\n\t\t\treturn consumeDelimToken;\n\t\t// U+005C REVERSE SOLIDUS (\\)\n\t\tcase CC_REVERSE_SOLIDUS:\n\t\t\treturn consumeReverseSolidus;\n\t\t// U+005D RIGHT SQUARE BRACKET (])\n\t\tcase CC_RIGHT_SQUARE:\n\t\t\treturn consumeDelimToken;\n\t\t// U+007B LEFT CURLY BRACKET ({)\n\t\tcase CC_LEFT_CURLY:\n\t\t\treturn consumeLeftCurlyBracket;\n\t\t// U+007D RIGHT CURLY BRACKET (})\n\t\tcase CC_RIGHT_CURLY:\n\t\t\treturn consumeRightCurlyBracket;\n\t\t// Optimization\n\t\tcase CC_LOWER_U:\n\t\tcase CC_UPPER_U:\n\t\t\treturn consumePotentialUrl;\n\t\tdefault:\n\t\t\t// digit\n\t\t\tif (_isDigit(cc)) return consumeNumericToken;\n\t\t\t// ident-start code point\n\t\t\tif (isIdentStartCodePoint(cc)) {\n\t\t\t\treturn consumeOtherIdentifier;\n\t\t\t}\n\t\t\t// EOF, but we don't have it\n\t\t\t// anything else\n\t\t\treturn consumeDelimToken;\n\t}\n});\n\n/**\n * @param {string} input input css\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {void}\n */\nmodule.exports = (input, callbacks) => {\n\t// This section describes how to consume a token from a stream of code points. It will return a single token of any type.\n\tlet pos = 0;\n\twhile (pos < input.length) {\n\t\t// Consume comments.\n\t\tpos = consumeComments(input, pos, callbacks);\n\n\t\tconst cc = input.charCodeAt(pos);\n\n\t\t// Consume the next input code point.\n\t\tif (cc < 0x80) {\n\t\t\tpos = CHAR_MAP[cc](input, pos, callbacks);\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n};\n\nmodule.exports.isIdentStartCodePoint = isIdentStartCodePoint;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after comments\n */\nmodule.exports.eatComments = (input, pos) => {\n\tfor (;;) {\n\t\tlet originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhitespace = (input, pos) => {\n\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatWhitespaceAndComments = (input, pos) => {\n\tfor (;;) {\n\t\tlet originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\t\tpos++;\n\t\t}\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhiteLine = (input, pos) => {\n\tfor (;;) {\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (_isSpace(cc)) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (_isNewLine(cc)) pos++;\n\t\t// For `\\r\\n`\n\t\tif (cc === CC_CARRIAGE_RETURN && input.charCodeAt(pos + 1) === CC_LINE_FEED)\n\t\t\tpos++;\n\t\tbreak;\n\t}\n\n\treturn pos;\n};\n"]},"metadata":{},"sourceType":"script"}