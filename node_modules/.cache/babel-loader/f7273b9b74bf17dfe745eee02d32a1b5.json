{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"./ModuleTypeConstants\");\n\nconst CachedConstDependency = require(\"./dependencies/CachedConstDependency\");\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst {\n  evaluateToString\n} = require(\"./javascript/JavascriptParserHelpers\");\n\nconst {\n  parseResource\n} = require(\"./util/identifier\");\n/** @typedef {import(\"estree\").AssignmentProperty} AssignmentProperty */\n\n/** @typedef {import(\"estree\").Expression} Expression */\n\n/** @typedef {import(\"estree\").Identifier} Identifier */\n\n/** @typedef {import(\"estree\").Pattern} Pattern */\n\n/** @typedef {import(\"estree\").SourceLocation} SourceLocation */\n\n/** @typedef {import(\"estree\").Statement} Statement */\n\n/** @typedef {import(\"estree\").Super} Super */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"./javascript/JavascriptParser\").Range} Range */\n\n/**\n * @param {Set<string>} declarations set of declarations\n * @param {Identifier | Pattern} pattern pattern to collect declarations from\n */\n\n\nconst collectDeclaration = (declarations, pattern) => {\n  const stack = [pattern];\n\n  while (stack.length > 0) {\n    const node =\n    /** @type {Pattern} */\n    stack.pop();\n\n    switch (node.type) {\n      case \"Identifier\":\n        declarations.add(node.name);\n        break;\n\n      case \"ArrayPattern\":\n        for (const element of node.elements) {\n          if (element) {\n            stack.push(element);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        stack.push(node.left);\n        break;\n\n      case \"ObjectPattern\":\n        for (const property of node.properties) {\n          stack.push(\n          /** @type {AssignmentProperty} */\n          property.value);\n        }\n\n        break;\n\n      case \"RestElement\":\n        stack.push(node.argument);\n        break;\n    }\n  }\n};\n/**\n * @param {Statement} branch branch to get hoisted declarations from\n * @param {boolean} includeFunctionDeclarations whether to include function declarations\n * @returns {Array<string>} hoisted declarations\n */\n\n\nconst getHoistedDeclarations = (branch, includeFunctionDeclarations) => {\n  const declarations = new Set();\n  /** @type {Array<TODO | null | undefined>} */\n\n  const stack = [branch];\n\n  while (stack.length > 0) {\n    const node = stack.pop(); // Some node could be `null` or `undefined`.\n\n    if (!node) continue;\n\n    switch (node.type) {\n      // Walk through control statements to look for hoisted declarations.\n      // Some branches are skipped since they do not allow declarations.\n      case \"BlockStatement\":\n        for (const stmt of node.body) {\n          stack.push(stmt);\n        }\n\n        break;\n\n      case \"IfStatement\":\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n        break;\n\n      case \"ForStatement\":\n        stack.push(node.init);\n        stack.push(node.body);\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        stack.push(node.left);\n        stack.push(node.body);\n        break;\n\n      case \"DoWhileStatement\":\n      case \"WhileStatement\":\n      case \"LabeledStatement\":\n        stack.push(node.body);\n        break;\n\n      case \"SwitchStatement\":\n        for (const cs of node.cases) {\n          for (const consequent of cs.consequent) {\n            stack.push(consequent);\n          }\n        }\n\n        break;\n\n      case \"TryStatement\":\n        stack.push(node.block);\n\n        if (node.handler) {\n          stack.push(node.handler.body);\n        }\n\n        stack.push(node.finalizer);\n        break;\n\n      case \"FunctionDeclaration\":\n        if (includeFunctionDeclarations) {\n          collectDeclaration(declarations,\n          /** @type {Identifier} */\n          node.id);\n        }\n\n        break;\n\n      case \"VariableDeclaration\":\n        if (node.kind === \"var\") {\n          for (const decl of node.declarations) {\n            collectDeclaration(declarations, decl.id);\n          }\n        }\n\n        break;\n    }\n  }\n\n  return Array.from(declarations);\n};\n\nconst PLUGIN_NAME = \"ConstPlugin\";\n\nclass ConstPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cachedParseResource = parseResource.bindCache(compiler.root);\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      compilation.dependencyTemplates.set(CachedConstDependency, new CachedConstDependency.Template());\n      /**\n       * @param {JavascriptParser} parser the parser\n       */\n\n      const handler = parser => {\n        parser.hooks.statementIf.tap(PLUGIN_NAME, statement => {\n          if (parser.scope.isAsmJs) return;\n          const param = parser.evaluateExpression(statement.test);\n          const bool = param.asBool();\n\n          if (typeof bool === \"boolean\") {\n            if (!param.couldHaveSideEffects()) {\n              const dep = new ConstDependency(`${bool}`,\n              /** @type {Range} */\n              param.range);\n              dep.loc =\n              /** @type {SourceLocation} */\n              statement.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            } else {\n              parser.walkExpression(statement.test);\n            }\n\n            const branchToRemove = bool ? statement.alternate : statement.consequent;\n\n            if (branchToRemove) {\n              // Before removing the dead branch, the hoisted declarations\n              // must be collected.\n              //\n              // Given the following code:\n              //\n              //     if (true) f() else g()\n              //     if (false) {\n              //       function f() {}\n              //       const g = function g() {}\n              //       if (someTest) {\n              //         let a = 1\n              //         var x, {y, z} = obj\n              //       }\n              //     } else {\n              //       …\n              //     }\n              //\n              // the generated code is:\n              //\n              //     if (true) f() else {}\n              //     if (false) {\n              //       var f, x, y, z;   (in loose mode)\n              //       var x, y, z;      (in strict mode)\n              //     } else {\n              //       …\n              //     }\n              //\n              // NOTE: When code runs in strict mode, `var` declarations\n              // are hoisted but `function` declarations don't.\n              //\n              let declarations;\n\n              if (parser.scope.isStrict) {\n                // If the code runs in strict mode, variable declarations\n                // using `var` must be hoisted.\n                declarations = getHoistedDeclarations(branchToRemove, false);\n              } else {\n                // Otherwise, collect all hoisted declaration.\n                declarations = getHoistedDeclarations(branchToRemove, true);\n              }\n\n              let replacement;\n\n              if (declarations.length > 0) {\n                replacement = `{ var ${declarations.join(\", \")}; }`;\n              } else {\n                replacement = \"{}\";\n              }\n\n              const dep = new ConstDependency(replacement,\n              /** @type {Range} */\n              branchToRemove.range);\n              dep.loc =\n              /** @type {SourceLocation} */\n              branchToRemove.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            }\n\n            return bool;\n          }\n        });\n        parser.hooks.expressionConditionalOperator.tap(PLUGIN_NAME, expression => {\n          if (parser.scope.isAsmJs) return;\n          const param = parser.evaluateExpression(expression.test);\n          const bool = param.asBool();\n\n          if (typeof bool === \"boolean\") {\n            if (!param.couldHaveSideEffects()) {\n              const dep = new ConstDependency(` ${bool}`,\n              /** @type {Range} */\n              param.range);\n              dep.loc =\n              /** @type {SourceLocation} */\n              expression.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            } else {\n              parser.walkExpression(expression.test);\n            } // Expressions do not hoist.\n            // It is safe to remove the dead branch.\n            //\n            // Given the following code:\n            //\n            //   false ? someExpression() : otherExpression();\n            //\n            // the generated code is:\n            //\n            //   false ? 0 : otherExpression();\n            //\n\n\n            const branchToRemove = bool ? expression.alternate : expression.consequent;\n            const dep = new ConstDependency(\"0\",\n            /** @type {Range} */\n            branchToRemove.range);\n            dep.loc =\n            /** @type {SourceLocation} */\n            branchToRemove.loc;\n            parser.state.module.addPresentationalDependency(dep);\n            return bool;\n          }\n        });\n        parser.hooks.expressionLogicalOperator.tap(PLUGIN_NAME, expression => {\n          if (parser.scope.isAsmJs) return;\n\n          if (expression.operator === \"&&\" || expression.operator === \"||\") {\n            const param = parser.evaluateExpression(expression.left);\n            const bool = param.asBool();\n\n            if (typeof bool === \"boolean\") {\n              // Expressions do not hoist.\n              // It is safe to remove the dead branch.\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   falsyExpression() && someExpression();\n              //\n              // the generated code is:\n              //\n              //   falsyExpression() && false;\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   truthyExpression() && someExpression();\n              //\n              // the generated code is:\n              //\n              //   true && someExpression();\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   truthyExpression() || someExpression();\n              //\n              // the generated code is:\n              //\n              //   truthyExpression() || false;\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   falsyExpression() || someExpression();\n              //\n              // the generated code is:\n              //\n              //   false && someExpression();\n              //\n              const keepRight = expression.operator === \"&&\" && bool || expression.operator === \"||\" && !bool;\n\n              if (!param.couldHaveSideEffects() && (param.isBoolean() || keepRight)) {\n                // for case like\n                //\n                //   return'development'===process.env.NODE_ENV&&'foo'\n                //\n                // we need a space before the bool to prevent result like\n                //\n                //   returnfalse&&'foo'\n                //\n                const dep = new ConstDependency(` ${bool}`,\n                /** @type {Range} */\n                param.range);\n                dep.loc =\n                /** @type {SourceLocation} */\n                expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              } else {\n                parser.walkExpression(expression.left);\n              }\n\n              if (!keepRight) {\n                const dep = new ConstDependency(\"0\",\n                /** @type {Range} */\n                expression.right.range);\n                dep.loc =\n                /** @type {SourceLocation} */\n                expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              }\n\n              return keepRight;\n            }\n          } else if (expression.operator === \"??\") {\n            const param = parser.evaluateExpression(expression.left);\n            const keepRight = param.asNullish();\n\n            if (typeof keepRight === \"boolean\") {\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   nonNullish ?? someExpression();\n              //\n              // the generated code is:\n              //\n              //   nonNullish ?? 0;\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   nullish ?? someExpression();\n              //\n              // the generated code is:\n              //\n              //   null ?? someExpression();\n              //\n              if (!param.couldHaveSideEffects() && keepRight) {\n                // cspell:word returnnull\n                // for case like\n                //\n                //   return('development'===process.env.NODE_ENV&&null)??'foo'\n                //\n                // we need a space before the bool to prevent result like\n                //\n                //   returnnull??'foo'\n                //\n                const dep = new ConstDependency(\" null\",\n                /** @type {Range} */\n                param.range);\n                dep.loc =\n                /** @type {SourceLocation} */\n                expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              } else {\n                const dep = new ConstDependency(\"0\",\n                /** @type {Range} */\n                expression.right.range);\n                dep.loc =\n                /** @type {SourceLocation} */\n                expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n                parser.walkExpression(expression.left);\n              }\n\n              return keepRight;\n            }\n          }\n        });\n        parser.hooks.optionalChaining.tap(PLUGIN_NAME, expr => {\n          /** @type {Expression[]} */\n          const optionalExpressionsStack = [];\n          /** @type {Expression | Super} */\n\n          let next = expr.expression;\n\n          while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n            if (next.type === \"MemberExpression\") {\n              if (next.optional) {\n                // SuperNode can not be optional\n                optionalExpressionsStack.push(\n                /** @type {Expression} */\n                next.object);\n              }\n\n              next = next.object;\n            } else {\n              if (next.optional) {\n                // SuperNode can not be optional\n                optionalExpressionsStack.push(\n                /** @type {Expression} */\n                next.callee);\n              }\n\n              next = next.callee;\n            }\n          }\n\n          while (optionalExpressionsStack.length) {\n            const expression = optionalExpressionsStack.pop();\n            const evaluated = parser.evaluateExpression(\n            /** @type {Expression} */\n            expression);\n\n            if (evaluated.asNullish()) {\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   nullishMemberChain?.a.b();\n              //\n              // the generated code is:\n              //\n              //   undefined;\n              //\n              // ------------------------------------------\n              //\n              const dep = new ConstDependency(\" undefined\",\n              /** @type {Range} */\n              expr.range);\n              dep.loc =\n              /** @type {SourceLocation} */\n              expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n              return true;\n            }\n          }\n        });\n        parser.hooks.evaluateIdentifier.for(\"__resourceQuery\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          return evaluateToString(cachedParseResource(parser.state.module.resource).query)(expr);\n        });\n        parser.hooks.expression.for(\"__resourceQuery\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          const dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).query),\n          /** @type {Range} */\n          expr.range, \"__resourceQuery\");\n          dep.loc =\n          /** @type {SourceLocation} */\n          expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n          return true;\n        });\n        parser.hooks.evaluateIdentifier.for(\"__resourceFragment\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          return evaluateToString(cachedParseResource(parser.state.module.resource).fragment)(expr);\n        });\n        parser.hooks.expression.for(\"__resourceFragment\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          const dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).fragment),\n          /** @type {Range} */\n          expr.range, \"__resourceFragment\");\n          dep.loc =\n          /** @type {SourceLocation} */\n          expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n          return true;\n        });\n      };\n\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n    });\n  }\n\n}\n\nmodule.exports = ConstPlugin;","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/ConstPlugin.js"],"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_DYNAMIC","JAVASCRIPT_MODULE_TYPE_ESM","require","CachedConstDependency","ConstDependency","evaluateToString","parseResource","collectDeclaration","declarations","pattern","stack","length","node","pop","type","add","name","element","elements","push","left","property","properties","value","argument","getHoistedDeclarations","branch","includeFunctionDeclarations","Set","stmt","body","consequent","alternate","init","cs","cases","block","handler","finalizer","id","kind","decl","Array","from","PLUGIN_NAME","ConstPlugin","apply","compiler","cachedParseResource","bindCache","root","hooks","compilation","tap","normalModuleFactory","dependencyTemplates","set","Template","parser","statementIf","statement","scope","isAsmJs","param","evaluateExpression","test","bool","asBool","couldHaveSideEffects","dep","range","loc","state","module","addPresentationalDependency","walkExpression","branchToRemove","isStrict","replacement","join","expressionConditionalOperator","expression","expressionLogicalOperator","operator","keepRight","isBoolean","right","asNullish","optionalChaining","expr","optionalExpressionsStack","next","optional","object","callee","evaluated","evaluateIdentifier","for","resource","query","JSON","stringify","fragment","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"./ModuleTypeConstants\");\nconst CachedConstDependency = require(\"./dependencies/CachedConstDependency\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst { evaluateToString } = require(\"./javascript/JavascriptParserHelpers\");\nconst { parseResource } = require(\"./util/identifier\");\n\n/** @typedef {import(\"estree\").AssignmentProperty} AssignmentProperty */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").SourceLocation} SourceLocation */\n/** @typedef {import(\"estree\").Statement} Statement */\n/** @typedef {import(\"estree\").Super} Super */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./javascript/JavascriptParser\").Range} Range */\n\n/**\n * @param {Set<string>} declarations set of declarations\n * @param {Identifier | Pattern} pattern pattern to collect declarations from\n */\nconst collectDeclaration = (declarations, pattern) => {\n\tconst stack = [pattern];\n\twhile (stack.length > 0) {\n\t\tconst node = /** @type {Pattern} */ (stack.pop());\n\t\tswitch (node.type) {\n\t\t\tcase \"Identifier\":\n\t\t\t\tdeclarations.add(node.name);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tfor (const element of node.elements) {\n\t\t\t\t\tif (element) {\n\t\t\t\t\t\tstack.push(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tfor (const property of node.properties) {\n\t\t\t\t\tstack.push(/** @type {AssignmentProperty} */ (property).value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tstack.push(node.argument);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\n/**\n * @param {Statement} branch branch to get hoisted declarations from\n * @param {boolean} includeFunctionDeclarations whether to include function declarations\n * @returns {Array<string>} hoisted declarations\n */\nconst getHoistedDeclarations = (branch, includeFunctionDeclarations) => {\n\tconst declarations = new Set();\n\t/** @type {Array<TODO | null | undefined>} */\n\tconst stack = [branch];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\t// Some node could be `null` or `undefined`.\n\t\tif (!node) continue;\n\t\tswitch (node.type) {\n\t\t\t// Walk through control statements to look for hoisted declarations.\n\t\t\t// Some branches are skipped since they do not allow declarations.\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tfor (const stmt of node.body) {\n\t\t\t\t\tstack.push(stmt);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tstack.push(node.consequent);\n\t\t\t\tstack.push(node.alternate);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tstack.push(node.init);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\tcase \"WhileStatement\":\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tfor (const cs of node.cases) {\n\t\t\t\t\tfor (const consequent of cs.consequent) {\n\t\t\t\t\t\tstack.push(consequent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tstack.push(node.block);\n\t\t\t\tif (node.handler) {\n\t\t\t\t\tstack.push(node.handler.body);\n\t\t\t\t}\n\t\t\t\tstack.push(node.finalizer);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tif (includeFunctionDeclarations) {\n\t\t\t\t\tcollectDeclaration(declarations, /** @type {Identifier} */ (node.id));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tif (node.kind === \"var\") {\n\t\t\t\t\tfor (const decl of node.declarations) {\n\t\t\t\t\t\tcollectDeclaration(declarations, decl.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn Array.from(declarations);\n};\n\nconst PLUGIN_NAME = \"ConstPlugin\";\n\nclass ConstPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedParseResource = parseResource.bindCache(compiler.root);\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tCachedConstDependency,\n\t\t\t\t\tnew CachedConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tparser.hooks.statementIf.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\tconst param = parser.evaluateExpression(statement.test);\n\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\tif (!param.couldHaveSideEffects()) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t`${bool}`,\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (param.range)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (statement.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(statement.test);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t? statement.alternate\n\t\t\t\t\t\t\t\t: statement.consequent;\n\t\t\t\t\t\t\tif (branchToRemove) {\n\t\t\t\t\t\t\t\t// Before removing the dead branch, the hoisted declarations\n\t\t\t\t\t\t\t\t// must be collected.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else g()\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       function f() {}\n\t\t\t\t\t\t\t\t//       const g = function g() {}\n\t\t\t\t\t\t\t\t//       if (someTest) {\n\t\t\t\t\t\t\t\t//         let a = 1\n\t\t\t\t\t\t\t\t//         var x, {y, z} = obj\n\t\t\t\t\t\t\t\t//       }\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else {}\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       var f, x, y, z;   (in loose mode)\n\t\t\t\t\t\t\t\t//       var x, y, z;      (in strict mode)\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// NOTE: When code runs in strict mode, `var` declarations\n\t\t\t\t\t\t\t\t// are hoisted but `function` declarations don't.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tlet declarations;\n\t\t\t\t\t\t\t\tif (parser.scope.isStrict) {\n\t\t\t\t\t\t\t\t\t// If the code runs in strict mode, variable declarations\n\t\t\t\t\t\t\t\t\t// using `var` must be hoisted.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, false);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Otherwise, collect all hoisted declaration.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet replacement;\n\t\t\t\t\t\t\t\tif (declarations.length > 0) {\n\t\t\t\t\t\t\t\t\treplacement = `{ var ${declarations.join(\", \")}; }`;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treplacement = \"{}\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\treplacement,\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (branchToRemove.range)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (branchToRemove.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expressionConditionalOperator.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.test);\n\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\tif (!param.couldHaveSideEffects()) {\n\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t` ${bool}`,\n\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (param.range)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expression.loc);\n\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.test);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? someExpression() : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? 0 : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t\t? expression.alternate\n\t\t\t\t\t\t\t\t\t: expression.consequent;\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (branchToRemove.range)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (branchToRemove.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.expressionLogicalOperator.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\texpression.operator === \"&&\" ||\n\t\t\t\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   true && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   false && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tconst keepRight =\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"&&\" && bool) ||\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"||\" && !bool);\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!param.couldHaveSideEffects() &&\n\t\t\t\t\t\t\t\t\t\t(param.isBoolean() || keepRight)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return'development'===process.env.NODE_ENV&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnfalse&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t` ${bool}`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (param.range)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expression.loc);\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!keepRight) {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (expression.right.range)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expression.loc);\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (expression.operator === \"??\") {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst keepRight = param.asNullish();\n\t\t\t\t\t\t\t\tif (typeof keepRight === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nonNullish ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nonNullish ?? 0;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nullish ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   null ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tif (!param.couldHaveSideEffects() && keepRight) {\n\t\t\t\t\t\t\t\t\t\t// cspell:word returnnull\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return('development'===process.env.NODE_ENV&&null)??'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnnull??'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\" null\",\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (param.range)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expression.loc);\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (expression.right.range)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expression.loc);\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.optionalChaining.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t/** @type {Expression[]} */\n\t\t\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t\t\t/** @type {Expression | Super} */\n\t\t\t\t\t\tlet next = expr.expression;\n\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (next.object)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (next.callee)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile (optionalExpressionsStack.length) {\n\t\t\t\t\t\t\tconst expression = optionalExpressionsStack.pop();\n\t\t\t\t\t\t\tconst evaluated = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t/** @type {Expression} */ (expression)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   nullishMemberChain?.a.b();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   undefined;\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\" undefined\",\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn evaluateToString(\n\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).query\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tconst dep = new CachedConstDependency(\n\t\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).query\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\t\t\t\t\"__resourceQuery\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expr.loc);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceFragment\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn evaluateToString(\n\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).fragment\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceFragment\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tconst dep = new CachedConstDependency(\n\t\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).fragment\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\t\t\t\t\"__resourceFragment\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = /** @type {SourceLocation} */ (expr.loc);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = ConstPlugin;\n"]},"metadata":{},"sourceType":"script"}