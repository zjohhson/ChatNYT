{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/**\n * @summary Get the subset of ids and their corresponding range in an id chain that should be re-rendered by webpack.\n * Only those in the chain that are actually referring to namespaces or imports should be re-rendered.\n * Deeper member accessors on the imported object should not be re-rendered.  If deeper member accessors are re-rendered,\n * there is a potential loss of meaning with rendering a quoted accessor as an unquoted accessor, or vice versa,\n * because minifiers treat quoted accessors differently.  e.g. import { a } from \"./module\"; a[\"b\"] vs a.b\n * @param {string[]} untrimmedIds chained ids\n * @param {Range} untrimmedRange range encompassing allIds\n * @param {Range[]} ranges cumulative range of ids for each of allIds\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {{trimmedIds: string[], trimmedRange: Range}} computed trimmed ids and cumulative range of those ids\n */\n\nexports.getTrimmedIdsAndRange = (untrimmedIds, untrimmedRange, ranges, moduleGraph, dependency) => {\n  let trimmedIds = trimIdsToThoseImported(untrimmedIds, moduleGraph, dependency);\n  let trimmedRange = untrimmedRange;\n\n  if (trimmedIds.length !== untrimmedIds.length) {\n    // The array returned from dep.idRanges is right-aligned with the array returned from dep.names.\n    // Meaning, the two arrays may not always have the same number of elements, but the last element of\n    // dep.idRanges corresponds to [the expression fragment to the left of] the last element of dep.names.\n    // Use this to find the correct replacement range based on the number of ids that were trimmed.\n    const idx = ranges === undefined ? -1\n    /* trigger failure case below */\n    : ranges.length + (trimmedIds.length - untrimmedIds.length);\n\n    if (idx < 0 || idx >= ranges.length) {\n      // cspell:ignore minifiers\n      // Should not happen but we can't throw an error here because of backward compatibility with\n      // external plugins in wp5.  Instead, we just disable trimming for now.  This may break some minifiers.\n      trimmedIds = untrimmedIds; // TODO webpack 6 remove the \"trimmedIds = ids\" above and uncomment the following line instead.\n      // throw new Error(\"Missing range starts data for id replacement trimming.\");\n    } else {\n      trimmedRange = ranges[idx];\n    }\n  }\n\n  return {\n    trimmedIds,\n    trimmedRange\n  };\n};\n/**\n * @summary Determine which IDs in the id chain are actually referring to namespaces or imports,\n * and which are deeper member accessors on the imported object.\n * @param {string[]} ids untrimmed ids\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {string[]} trimmed ids\n */\n\n\nfunction trimIdsToThoseImported(ids, moduleGraph, dependency) {\n  let trimmedIds = [];\n  const exportsInfo = moduleGraph.getExportsInfo(moduleGraph.getModule(dependency));\n  let currentExportsInfo =\n  /** @type {ExportsInfo=} */\n  exportsInfo;\n\n  for (let i = 0; i < ids.length; i++) {\n    if (i === 0 && ids[i] === \"default\") {\n      continue; // ExportInfo for the next level under default is still at the root ExportsInfo, so don't advance currentExportsInfo\n    }\n\n    const exportInfo = currentExportsInfo.getExportInfo(ids[i]);\n\n    if (exportInfo.provided === false) {\n      // json imports have nested ExportInfo for elements that things that are not actually exported, so check .provided\n      trimmedIds = ids.slice(0, i);\n      break;\n    }\n\n    const nestedInfo = exportInfo.getNestedExportsInfo();\n\n    if (!nestedInfo) {\n      // once all nested exports are traversed, the next item is the actual import so stop there\n      trimmedIds = ids.slice(0, i + 1);\n      break;\n    }\n\n    currentExportsInfo = nestedInfo;\n  } // Never trim to nothing.  This can happen for invalid imports (e.g. import { notThere } from \"./module\", or import { anything } from \"./missingModule\")\n\n\n  return trimmedIds.length ? trimmedIds : ids;\n}","map":{"version":3,"sources":["/Users/zachjohnson/Desktop/ChatNYT/node_modules/webpack/lib/util/chainedImports.js"],"names":["exports","getTrimmedIdsAndRange","untrimmedIds","untrimmedRange","ranges","moduleGraph","dependency","trimmedIds","trimIdsToThoseImported","trimmedRange","length","idx","undefined","ids","exportsInfo","getExportsInfo","getModule","currentExportsInfo","i","exportInfo","getExportInfo","provided","slice","nestedInfo","getNestedExportsInfo"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,OAAO,CAACC,qBAAR,GAAgC,CAC/BC,YAD+B,EAE/BC,cAF+B,EAG/BC,MAH+B,EAI/BC,WAJ+B,EAK/BC,UAL+B,KAM3B;AACJ,MAAIC,UAAU,GAAGC,sBAAsB,CACtCN,YADsC,EAEtCG,WAFsC,EAGtCC,UAHsC,CAAvC;AAKA,MAAIG,YAAY,GAAGN,cAAnB;;AACA,MAAII,UAAU,CAACG,MAAX,KAAsBR,YAAY,CAACQ,MAAvC,EAA+C;AAC9C;AACA;AACA;AACA;AACA,UAAMC,GAAG,GACRP,MAAM,KAAKQ,SAAX,GACG,CAAC;AAAE;AADN,MAEGR,MAAM,CAACM,MAAP,IAAiBH,UAAU,CAACG,MAAX,GAAoBR,YAAY,CAACQ,MAAlD,CAHJ;;AAIA,QAAIC,GAAG,GAAG,CAAN,IAAWA,GAAG,IAAIP,MAAM,CAACM,MAA7B,EAAqC;AACpC;AACA;AACA;AACAH,MAAAA,UAAU,GAAGL,YAAb,CAJoC,CAKpC;AACA;AACA,KAPD,MAOO;AACNO,MAAAA,YAAY,GAAGL,MAAM,CAACO,GAAD,CAArB;AACA;AACD;;AAED,SAAO;AAAEJ,IAAAA,UAAF;AAAcE,IAAAA;AAAd,GAAP;AACA,CAnCD;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASD,sBAAT,CAAgCK,GAAhC,EAAqCR,WAArC,EAAkDC,UAAlD,EAA8D;AAC7D,MAAIC,UAAU,GAAG,EAAjB;AACA,QAAMO,WAAW,GAAGT,WAAW,CAACU,cAAZ,CACnBV,WAAW,CAACW,SAAZ,CAAsBV,UAAtB,CADmB,CAApB;AAGA,MAAIW,kBAAkB;AAAG;AAA4BH,EAAAA,WAArD;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACH,MAAxB,EAAgCQ,CAAC,EAAjC,EAAqC;AACpC,QAAIA,CAAC,KAAK,CAAN,IAAWL,GAAG,CAACK,CAAD,CAAH,KAAW,SAA1B,EAAqC;AACpC,eADoC,CAC1B;AACV;;AACD,UAAMC,UAAU,GAAGF,kBAAkB,CAACG,aAAnB,CAAiCP,GAAG,CAACK,CAAD,CAApC,CAAnB;;AACA,QAAIC,UAAU,CAACE,QAAX,KAAwB,KAA5B,EAAmC;AAClC;AACAd,MAAAA,UAAU,GAAGM,GAAG,CAACS,KAAJ,CAAU,CAAV,EAAaJ,CAAb,CAAb;AACA;AACA;;AACD,UAAMK,UAAU,GAAGJ,UAAU,CAACK,oBAAX,EAAnB;;AACA,QAAI,CAACD,UAAL,EAAiB;AAChB;AACAhB,MAAAA,UAAU,GAAGM,GAAG,CAACS,KAAJ,CAAU,CAAV,EAAaJ,CAAC,GAAG,CAAjB,CAAb;AACA;AACA;;AACDD,IAAAA,kBAAkB,GAAGM,UAArB;AACA,GAvB4D,CAwB7D;;;AACA,SAAOhB,UAAU,CAACG,MAAX,GAAoBH,UAApB,GAAiCM,GAAxC;AACA","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/**\n * @summary Get the subset of ids and their corresponding range in an id chain that should be re-rendered by webpack.\n * Only those in the chain that are actually referring to namespaces or imports should be re-rendered.\n * Deeper member accessors on the imported object should not be re-rendered.  If deeper member accessors are re-rendered,\n * there is a potential loss of meaning with rendering a quoted accessor as an unquoted accessor, or vice versa,\n * because minifiers treat quoted accessors differently.  e.g. import { a } from \"./module\"; a[\"b\"] vs a.b\n * @param {string[]} untrimmedIds chained ids\n * @param {Range} untrimmedRange range encompassing allIds\n * @param {Range[]} ranges cumulative range of ids for each of allIds\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {{trimmedIds: string[], trimmedRange: Range}} computed trimmed ids and cumulative range of those ids\n */\nexports.getTrimmedIdsAndRange = (\n\tuntrimmedIds,\n\tuntrimmedRange,\n\tranges,\n\tmoduleGraph,\n\tdependency\n) => {\n\tlet trimmedIds = trimIdsToThoseImported(\n\t\tuntrimmedIds,\n\t\tmoduleGraph,\n\t\tdependency\n\t);\n\tlet trimmedRange = untrimmedRange;\n\tif (trimmedIds.length !== untrimmedIds.length) {\n\t\t// The array returned from dep.idRanges is right-aligned with the array returned from dep.names.\n\t\t// Meaning, the two arrays may not always have the same number of elements, but the last element of\n\t\t// dep.idRanges corresponds to [the expression fragment to the left of] the last element of dep.names.\n\t\t// Use this to find the correct replacement range based on the number of ids that were trimmed.\n\t\tconst idx =\n\t\t\tranges === undefined\n\t\t\t\t? -1 /* trigger failure case below */\n\t\t\t\t: ranges.length + (trimmedIds.length - untrimmedIds.length);\n\t\tif (idx < 0 || idx >= ranges.length) {\n\t\t\t// cspell:ignore minifiers\n\t\t\t// Should not happen but we can't throw an error here because of backward compatibility with\n\t\t\t// external plugins in wp5.  Instead, we just disable trimming for now.  This may break some minifiers.\n\t\t\ttrimmedIds = untrimmedIds;\n\t\t\t// TODO webpack 6 remove the \"trimmedIds = ids\" above and uncomment the following line instead.\n\t\t\t// throw new Error(\"Missing range starts data for id replacement trimming.\");\n\t\t} else {\n\t\t\ttrimmedRange = ranges[idx];\n\t\t}\n\t}\n\n\treturn { trimmedIds, trimmedRange };\n};\n\n/**\n * @summary Determine which IDs in the id chain are actually referring to namespaces or imports,\n * and which are deeper member accessors on the imported object.\n * @param {string[]} ids untrimmed ids\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {string[]} trimmed ids\n */\nfunction trimIdsToThoseImported(ids, moduleGraph, dependency) {\n\tlet trimmedIds = [];\n\tconst exportsInfo = moduleGraph.getExportsInfo(\n\t\tmoduleGraph.getModule(dependency)\n\t);\n\tlet currentExportsInfo = /** @type {ExportsInfo=} */ exportsInfo;\n\tfor (let i = 0; i < ids.length; i++) {\n\t\tif (i === 0 && ids[i] === \"default\") {\n\t\t\tcontinue; // ExportInfo for the next level under default is still at the root ExportsInfo, so don't advance currentExportsInfo\n\t\t}\n\t\tconst exportInfo = currentExportsInfo.getExportInfo(ids[i]);\n\t\tif (exportInfo.provided === false) {\n\t\t\t// json imports have nested ExportInfo for elements that things that are not actually exported, so check .provided\n\t\t\ttrimmedIds = ids.slice(0, i);\n\t\t\tbreak;\n\t\t}\n\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\n\t\tif (!nestedInfo) {\n\t\t\t// once all nested exports are traversed, the next item is the actual import so stop there\n\t\t\ttrimmedIds = ids.slice(0, i + 1);\n\t\t\tbreak;\n\t\t}\n\t\tcurrentExportsInfo = nestedInfo;\n\t}\n\t// Never trim to nothing.  This can happen for invalid imports (e.g. import { notThere } from \"./module\", or import { anything } from \"./missingModule\")\n\treturn trimmedIds.length ? trimmedIds : ids;\n}\n"]},"metadata":{},"sourceType":"script"}